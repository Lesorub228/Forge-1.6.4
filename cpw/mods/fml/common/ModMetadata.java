// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import cpw.mods.fml.common.functions.ModNameFunction;
import com.google.common.base.Joiner;
import java.util.Iterator;
import cpw.mods.fml.common.versioning.VersionParser;
import java.util.Collection;
import argo.jdom.JsonStringNode;
import java.util.Map;
import java.util.ArrayList;
import java.util.HashSet;
import com.google.common.base.Objects;
import java.util.logging.Level;
import com.google.common.base.Strings;
import argo.jdom.JsonNodeBuilders;
import com.google.common.base.Function;
import com.google.common.collect.Maps;
import com.google.common.collect.Lists;
import argo.jdom.JsonNode;
import cpw.mods.fml.common.versioning.ArtifactVersion;
import java.util.Set;
import java.util.List;

public class ModMetadata
{
    public String modId;
    public String name;
    public String description;
    public String url;
    public String updateUrl;
    public String logoFile;
    public String version;
    public List<String> authorList;
    public String credits;
    public String parent;
    public String[] screenshots;
    public ModContainer parentMod;
    public List<ModContainer> childMods;
    public boolean useDependencyInformation;
    public Set<ArtifactVersion> requiredMods;
    public List<ArtifactVersion> dependencies;
    public List<ArtifactVersion> dependants;
    public boolean autogenerated;
    
    public ModMetadata(final JsonNode node) {
        this.description = "";
        this.url = "";
        this.updateUrl = "";
        this.logoFile = "";
        this.version = "";
        this.authorList = Lists.newArrayList();
        this.credits = "";
        this.parent = "";
        this.childMods = Lists.newArrayList();
        final Map<JsonStringNode, Object> processedFields = Maps.transformValues(node.getFields(), (Function)new JsonStringConverter());
        this.modId = processedFields.get(JsonNodeBuilders.aStringBuilder("modid"));
        if (Strings.isNullOrEmpty(this.modId)) {
            FMLLog.log(Level.SEVERE, "Found an invalid mod metadata file - missing modid", new Object[0]);
            throw new LoaderException();
        }
        this.name = Strings.nullToEmpty((String)processedFields.get(JsonNodeBuilders.aStringBuilder("name")));
        this.description = Strings.nullToEmpty((String)processedFields.get(JsonNodeBuilders.aStringBuilder("description")));
        this.url = Strings.nullToEmpty((String)processedFields.get(JsonNodeBuilders.aStringBuilder("url")));
        this.updateUrl = Strings.nullToEmpty((String)processedFields.get(JsonNodeBuilders.aStringBuilder("updateUrl")));
        this.logoFile = Strings.nullToEmpty((String)processedFields.get(JsonNodeBuilders.aStringBuilder("logoFile")));
        this.version = Strings.nullToEmpty((String)processedFields.get(JsonNodeBuilders.aStringBuilder("version")));
        this.credits = Strings.nullToEmpty((String)processedFields.get(JsonNodeBuilders.aStringBuilder("credits")));
        this.parent = Strings.nullToEmpty((String)processedFields.get(JsonNodeBuilders.aStringBuilder("parent")));
        this.authorList = (List)Objects.firstNonNull((Object)processedFields.get(JsonNodeBuilders.aStringBuilder("authors")), Objects.firstNonNull((Object)processedFields.get(JsonNodeBuilders.aStringBuilder("authorList")), (Object)this.authorList));
        this.requiredMods = this.processReferences(processedFields.get(JsonNodeBuilders.aStringBuilder("requiredMods")), (Class<? extends Set<ArtifactVersion>>)HashSet.class);
        this.dependencies = this.processReferences(processedFields.get(JsonNodeBuilders.aStringBuilder("dependencies")), (Class<? extends List<ArtifactVersion>>)ArrayList.class);
        this.dependants = this.processReferences(processedFields.get(JsonNodeBuilders.aStringBuilder("dependants")), (Class<? extends List<ArtifactVersion>>)ArrayList.class);
        this.useDependencyInformation = Boolean.parseBoolean(Strings.nullToEmpty((String)processedFields.get(JsonNodeBuilders.aStringBuilder("useDependencyInformation"))));
    }
    
    public ModMetadata() {
        this.description = "";
        this.url = "";
        this.updateUrl = "";
        this.logoFile = "";
        this.version = "";
        this.authorList = Lists.newArrayList();
        this.credits = "";
        this.parent = "";
        this.childMods = Lists.newArrayList();
    }
    
    private <T extends Collection<ArtifactVersion>> T processReferences(final Object refs, final Class<? extends T> retType) {
        T res = null;
        try {
            res = (T)retType.newInstance();
        }
        catch (final Exception ex) {}
        if (refs == null) {
            return res;
        }
        for (final String ref : (List)refs) {
            res.add(VersionParser.parseVersionReference(ref));
        }
        return res;
    }
    
    public String getChildModCountString() {
        return String.format("%d child mod%s", this.childMods.size(), (this.childMods.size() != 1) ? "s" : "");
    }
    
    public String getAuthorList() {
        return Joiner.on(", ").join((Iterable)this.authorList);
    }
    
    public String getChildModList() {
        return Joiner.on(", ").join((Iterable)Lists.transform((List)this.childMods, (Function)new ModNameFunction()));
    }
    
    public String printableSortingRules() {
        return "";
    }
    
    private static final class JsonStringConverter implements Function<JsonNode, Object>
    {
        public Object apply(final JsonNode arg0) {
            if (arg0.hasElements()) {
                return Lists.transform(arg0.getElements(), (Function)new JsonArrayConverter());
            }
            return arg0.getText();
        }
    }
    
    private static final class JsonArrayConverter implements Function<JsonNode, String>
    {
        public String apply(final JsonNode arg0) {
            return arg0.getText();
        }
    }
}
