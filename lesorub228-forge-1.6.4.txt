Directory structure:
└── lesorub228-forge-1.6.4/
    ├── BaseMod.java
    ├── EntityRendererProxy.java
    ├── FMLRenderAccessLibrary.java
    ├── MLProp.java
    ├── ModLoader.java
    ├── TradeEntry.java
    ├── cpw/
    │   └── mods/
    │       └── fml/
    │           ├── client/
    │           │   ├── CustomModLoadingErrorDisplayException.java
    │           │   ├── FMLClientHandler.java
    │           │   ├── FMLFileResourcePack.java
    │           │   ├── FMLFolderResourcePack.java
    │           │   ├── GuiCustomModLoadingErrorScreen.java
    │           │   ├── GuiDupesFound.java
    │           │   ├── GuiIdMismatchScreen.java
    │           │   ├── GuiModList.java
    │           │   ├── GuiModsMissing.java
    │           │   ├── GuiModsMissingForServer.java
    │           │   ├── GuiScrollingList.java
    │           │   ├── GuiSlotModList.java
    │           │   ├── GuiSortingProblem.java
    │           │   ├── GuiWrongMinecraft.java
    │           │   ├── TextureFXManager.java
    │           │   ├── modloader/
    │           │   │   ├── ModLoaderBlockRendererHandler.java
    │           │   │   ├── ModLoaderClientHelper.java
    │           │   │   └── ModLoaderKeyBindingHandler.java
    │           │   └── registry/
    │           │       ├── ClientRegistry.java
    │           │       ├── ISimpleBlockRenderingHandler.java
    │           │       ├── KeyBindingRegistry.java
    │           │       └── RenderingRegistry.java
    │           ├── common/
    │           │   ├── API.java
    │           │   ├── BukkitPluginRef.java
    │           │   ├── BukkitProxy.java
    │           │   ├── CertificateHelper.java
    │           │   ├── DummyModContainer.java
    │           │   ├── DuplicateModsFoundException.java
    │           │   ├── FMLCommonHandler.java
    │           │   ├── FMLDummyContainer.java
    │           │   ├── FMLLog.java
    │           │   ├── FMLModContainer.java
    │           │   ├── IASMHook.java
    │           │   ├── IConsoleHandler.java
    │           │   ├── ICraftingHandler.java
    │           │   ├── ICrashCallable.java
    │           │   ├── IFMLHandledException.java
    │           │   ├── IFMLSidedHandler.java
    │           │   ├── IFuelHandler.java
    │           │   ├── ILanguageAdapter.java
    │           │   ├── INetworkHandler.java
    │           │   ├── InjectedModContainer.java
    │           │   ├── IPickupNotifier.java
    │           │   ├── IPlayerTracker.java
    │           │   ├── IScheduledTickHandler.java
    │           │   ├── ITickHandler.java
    │           │   ├── IWorldGenerator.java
    │           │   ├── LoadController.java
    │           │   ├── Loader.java
    │           │   ├── LoaderException.java
    │           │   ├── LoaderState.java
    │           │   ├── MCPDummyContainer.java
    │           │   ├── MetadataCollection.java
    │           │   ├── MinecraftDummyContainer.java
    │           │   ├── MissingModsException.java
    │           │   ├── Mod.java
    │           │   ├── ModAPIManager.java
    │           │   ├── ModClassLoader.java
    │           │   ├── ModContainer.java
    │           │   ├── ModContainerFactory.java
    │           │   ├── ModMetadata.java
    │           │   ├── ObfuscationReflectionHelper.java
    │           │   ├── Optional.java
    │           │   ├── ProxyInjector.java
    │           │   ├── SidedProxy.java
    │           │   ├── SingleIntervalHandler.java
    │           │   ├── TickType.java
    │           │   ├── WorldAccessContainer.java
    │           │   ├── WrongMinecraftVersionException.java
    │           │   ├── asm/
    │           │   │   ├── ASMTransformer.java
    │           │   │   ├── FMLSanityChecker.java
    │           │   │   ├── ReobfuscationMarker.java
    │           │   │   └── transformers/
    │           │   │       ├── AccessTransformer.java
    │           │   │       ├── DeobfuscationTransformer.java
    │           │   │       ├── MarkerTransformer.java
    │           │   │       ├── MCPMerger.java
    │           │   │       ├── ModAPITransformer.java
    │           │   │       ├── PatchingTransformer.java
    │           │   │       ├── SideTransformer.java
    │           │   │       └── deobf/
    │           │   │           ├── FMLDeobfuscatingRemapper.java
    │           │   │           ├── FMLRemappingAdapter.java
    │           │   │           └── LZMAInputSupplier.java
    │           │   ├── discovery/
    │           │   │   ├── ASMDataTable.java
    │           │   │   ├── ContainerType.java
    │           │   │   ├── DirectoryDiscoverer.java
    │           │   │   ├── ITypeDiscoverer.java
    │           │   │   ├── JarDiscoverer.java
    │           │   │   ├── ModCandidate.java
    │           │   │   ├── ModDiscoverer.java
    │           │   │   └── asm/
    │           │   │       ├── ASMModParser.java
    │           │   │       ├── ModAnnotation.java
    │           │   │       ├── ModAnnotationVisitor.java
    │           │   │       ├── ModClassVisitor.java
    │           │   │       ├── ModFieldVisitor.java
    │           │   │       ├── ModLoaderPropertiesMethodVisitor.java
    │           │   │       └── ModMethodVisitor.java
    │           │   ├── event/
    │           │   │   ├── FMLConstructionEvent.java
    │           │   │   ├── FMLEvent.java
    │           │   │   ├── FMLFingerprintViolationEvent.java
    │           │   │   ├── FMLInitializationEvent.java
    │           │   │   ├── FMLInterModComms.java
    │           │   │   ├── FMLLoadCompleteEvent.java
    │           │   │   ├── FMLLoadEvent.java
    │           │   │   ├── FMLPostInitializationEvent.java
    │           │   │   ├── FMLPreInitializationEvent.java
    │           │   │   ├── FMLServerAboutToStartEvent.java
    │           │   │   ├── FMLServerStartedEvent.java
    │           │   │   ├── FMLServerStartingEvent.java
    │           │   │   ├── FMLServerStoppedEvent.java
    │           │   │   ├── FMLServerStoppingEvent.java
    │           │   │   └── FMLStateEvent.java
    │           │   ├── functions/
    │           │   │   ├── ArtifactVersionNameFunction.java
    │           │   │   ├── ModIdFunction.java
    │           │   │   └── ModNameFunction.java
    │           │   ├── launcher/
    │           │   │   ├── FMLDeobfTweaker.java
    │           │   │   ├── FMLInjectionAndSortingTweaker.java
    │           │   │   ├── FMLServerTweaker.java
    │           │   │   └── FMLTweaker.java
    │           │   ├── modloader/
    │           │   │   ├── BaseModProxy.java
    │           │   │   ├── BaseModTicker.java
    │           │   │   ├── IModLoaderSidedHelper.java
    │           │   │   ├── ModLoaderChatListener.java
    │           │   │   ├── ModLoaderConnectionHandler.java
    │           │   │   ├── ModLoaderCraftingHelper.java
    │           │   │   ├── ModLoaderEntitySpawnCallback.java
    │           │   │   ├── ModLoaderFuelHelper.java
    │           │   │   ├── ModLoaderGuiHelper.java
    │           │   │   ├── ModLoaderHelper.java
    │           │   │   ├── ModLoaderModContainer.java
    │           │   │   ├── ModLoaderNetworkHandler.java
    │           │   │   ├── ModLoaderPacketHandler.java
    │           │   │   ├── ModLoaderPickupNotifier.java
    │           │   │   ├── ModLoaderVillageTradeHandler.java
    │           │   │   ├── ModLoaderWorldGenerator.java
    │           │   │   └── ModProperty.java
    │           │   ├── network/
    │           │   │   ├── EntitySpawnAdjustmentPacket.java
    │           │   │   ├── EntitySpawnPacket.java
    │           │   │   ├── FMLNetworkException.java
    │           │   │   ├── FMLNetworkHandler.java
    │           │   │   ├── FMLPacket.java
    │           │   │   ├── IChatListener.java
    │           │   │   ├── IConnectionHandler.java
    │           │   │   ├── IGuiHandler.java
    │           │   │   ├── IPacketHandler.java
    │           │   │   ├── ITinyPacketHandler.java
    │           │   │   ├── ModIdentifiersPacket.java
    │           │   │   ├── ModIdMapPacket.java
    │           │   │   ├── ModListRequestPacket.java
    │           │   │   ├── ModListResponsePacket.java
    │           │   │   ├── ModMissingPacket.java
    │           │   │   ├── NetworkMod.java
    │           │   │   ├── NetworkModHandler.java
    │           │   │   ├── NetworkRegistry.java
    │           │   │   ├── OpenGuiPacket.java
    │           │   │   ├── PacketDispatcher.java
    │           │   │   └── Player.java
    │           │   ├── patcher/
    │           │   │   ├── ClassPatch.java
    │           │   │   ├── ClassPatchManager.java
    │           │   │   └── GenDiffSet.java
    │           │   ├── registry/
    │           │   │   ├── BlockProxy.java
    │           │   │   ├── BlockTracker.java
    │           │   │   ├── EntityRegistry.java
    │           │   │   ├── GameData.java
    │           │   │   ├── GameRegistry.java
    │           │   │   ├── IEntityAdditionalSpawnData.java
    │           │   │   ├── ItemData.java
    │           │   │   ├── ItemProxy.java
    │           │   │   ├── IThrowableEntity.java
    │           │   │   ├── LanguageRegistry.java
    │           │   │   ├── TickRegistry.java
    │           │   │   └── VillagerRegistry.java
    │           │   ├── toposort/
    │           │   │   ├── ModSorter.java
    │           │   │   ├── ModSortingException.java
    │           │   │   └── TopologicalSort.java
    │           │   └── versioning/
    │           │       ├── ArtifactVersion.java
    │           │       ├── ComparableVersion.java
    │           │       ├── DefaultArtifactVersion.java
    │           │       ├── InvalidVersionSpecificationException.java
    │           │       ├── Restriction.java
    │           │       ├── VersionParser.java
    │           │       └── VersionRange.java
    │           ├── relauncher/
    │           │   ├── CoreModManager.java
    │           │   ├── FMLCorePlugin.java
    │           │   ├── FMLInjectionData.java
    │           │   ├── FMLLaunchHandler.java
    │           │   ├── FMLLogFormatter.java
    │           │   ├── FMLRelaunchLog.java
    │           │   ├── IFMLCallHook.java
    │           │   ├── IFMLLoadingPlugin.java
    │           │   ├── ILibrarySet.java
    │           │   ├── ReflectionHelper.java
    │           │   ├── ServerLaunchWrapper.java
    │           │   ├── Side.java
    │           │   └── SideOnly.java
    │           ├── repackage/
    │           │   └── com/
    │           │       └── nothome/
    │           │           └── delta/
    │           │               ├── ByteBufferSeekableSource.java
    │           │               ├── Checksum.java
    │           │               ├── DebugDiffWriter.java
    │           │               ├── Delta.java
    │           │               ├── DiffWriter.java
    │           │               ├── GDiffPatcher.java
    │           │               ├── GDiffWriter.java
    │           │               ├── PatchException.java
    │           │               ├── RandomAccessFileSeekableSource.java
    │           │               └── SeekableSource.java
    │           └── server/
    │               └── FMLServerHandler.java
    ├── ibxm/
    │   ├── Channel.java
    │   ├── Envelope.java
    │   ├── FastTracker2.java
    │   ├── IBXM.java
    │   ├── Instrument.java
    │   ├── LogTable.java
    │   ├── Module.java
    │   ├── Pattern.java
    │   ├── Player.java
    │   ├── ProTracker.java
    │   ├── Sample.java
    │   └── ScreamTracker3.java
    ├── net/
    │   └── minecraftforge/
    │       ├── classloading/
    │       │   └── FMLForgePlugin.java
    │       ├── client/
    │       │   ├── ClientCommandHandler.java
    │       │   ├── EnumHelperClient.java
    │       │   ├── ForgeHooksClient.java
    │       │   ├── GuiControlsScrollPanel.java
    │       │   ├── GuiIngameForge.java
    │       │   ├── IItemRenderer.java
    │       │   ├── IRenderContextHandler.java
    │       │   ├── IRenderHandler.java
    │       │   ├── MinecraftForgeClient.java
    │       │   ├── event/
    │       │   │   ├── ClientChatReceivedEvent.java
    │       │   │   ├── DrawBlockHighlightEvent.java
    │       │   │   ├── FOVUpdateEvent.java
    │       │   │   ├── GuiOpenEvent.java
    │       │   │   ├── MouseEvent.java
    │       │   │   ├── RenderGameOverlayEvent.java
    │       │   │   ├── RenderLivingEvent.java
    │       │   │   ├── RenderPlayerEvent.java
    │       │   │   ├── RenderWorldLastEvent.java
    │       │   │   ├── TextureStitchEvent.java
    │       │   │   └── sound/
    │       │   │       ├── PlayBackgroundMusicEvent.java
    │       │   │       ├── PlaySoundEffectEvent.java
    │       │   │       ├── PlaySoundEffectSourceEvent.java
    │       │   │       ├── PlaySoundEvent.java
    │       │   │       ├── PlaySoundSourceEvent.java
    │       │   │       ├── PlayStreamingEvent.java
    │       │   │       ├── PlayStreamingSourceEvent.java
    │       │   │       ├── SoundEvent.java
    │       │   │       ├── SoundLoadEvent.java
    │       │   │       ├── SoundResultEvent.java
    │       │   │       └── SoundSetupEvent.java
    │       │   └── model/
    │       │       ├── AdvancedModelLoader.java
    │       │       ├── IModelCustom.java
    │       │       ├── IModelCustomLoader.java
    │       │       ├── ModelFormatException.java
    │       │       ├── obj/
    │       │       │   ├── Face.java
    │       │       │   ├── GroupObject.java
    │       │       │   ├── ObjModelLoader.java
    │       │       │   ├── TextureCoordinate.java
    │       │       │   ├── Vertex.java
    │       │       │   └── WavefrontObject.java
    │       │       └── techne/
    │       │           ├── TechneModel.java
    │       │           └── TechneModelLoader.java
    │       ├── common/
    │       │   ├── AchievementPage.java
    │       │   ├── BiomeDictionary.java
    │       │   ├── BiomeManager.java
    │       │   ├── ChestGenHooks.java
    │       │   ├── ConfigCategory.java
    │       │   ├── Configuration.java
    │       │   ├── DimensionManager.java
    │       │   ├── DungeonHooks.java
    │       │   ├── EnumHelper.java
    │       │   ├── EnumPlantType.java
    │       │   ├── FakePlayer.java
    │       │   ├── FakePlayerFactory.java
    │       │   ├── ForgeChunkManager.java
    │       │   ├── ForgeDirection.java
    │       │   ├── ForgeDummyContainer.java
    │       │   ├── ForgeHooks.java
    │       │   ├── ForgeInternalHandler.java
    │       │   ├── ForgeVersion.java
    │       │   ├── IExtendedEntityProperties.java
    │       │   ├── IMinecartCollisionHandler.java
    │       │   ├── IPlantable.java
    │       │   ├── IShearable.java
    │       │   ├── ISpecialArmor.java
    │       │   ├── MinecraftForge.java
    │       │   ├── Property.java
    │       │   ├── RotationHelper.java
    │       │   ├── WorldSpecificSaveHandler.java
    │       │   └── network/
    │       │       ├── ForgeConnectionHandler.java
    │       │       ├── ForgeNetworkHandler.java
    │       │       ├── ForgePacket.java
    │       │       ├── ForgePacketHandler.java
    │       │       ├── ForgeTinyPacketHandler.java
    │       │       └── packet/
    │       │           └── DimensionRegisterPacket.java
    │       ├── event/
    │       │   ├── ASMEventHandler.java
    │       │   ├── Cancelable.java
    │       │   ├── CommandEvent.java
    │       │   ├── Event.java
    │       │   ├── EventBus.java
    │       │   ├── EventPriority.java
    │       │   ├── ForgeEventFactory.java
    │       │   ├── ForgeSubscribe.java
    │       │   ├── IEventListener.java
    │       │   ├── ListenerList.java
    │       │   ├── ServerChatEvent.java
    │       │   ├── brewing/
    │       │   │   └── PotionBrewedEvent.java
    │       │   ├── entity/
    │       │   │   ├── EntityEvent.java
    │       │   │   ├── EntityJoinWorldEvent.java
    │       │   │   ├── EntityStruckByLightningEvent.java
    │       │   │   ├── PlaySoundAtEntityEvent.java
    │       │   │   ├── item/
    │       │   │   │   ├── ItemEvent.java
    │       │   │   │   ├── ItemExpireEvent.java
    │       │   │   │   └── ItemTossEvent.java
    │       │   │   ├── living/
    │       │   │   │   ├── EnderTeleportEvent.java
    │       │   │   │   ├── LivingAttackEvent.java
    │       │   │   │   ├── LivingDeathEvent.java
    │       │   │   │   ├── LivingDropsEvent.java
    │       │   │   │   ├── LivingEvent.java
    │       │   │   │   ├── LivingFallEvent.java
    │       │   │   │   ├── LivingHurtEvent.java
    │       │   │   │   ├── LivingPackSizeEvent.java
    │       │   │   │   ├── LivingSetAttackTargetEvent.java
    │       │   │   │   ├── LivingSpawnEvent.java
    │       │   │   │   └── ZombieEvent.java
    │       │   │   ├── minecart/
    │       │   │   │   ├── MinecartCollisionEvent.java
    │       │   │   │   ├── MinecartEvent.java
    │       │   │   │   ├── MinecartInteractEvent.java
    │       │   │   │   └── MinecartUpdateEvent.java
    │       │   │   └── player/
    │       │   │       ├── ArrowLooseEvent.java
    │       │   │       ├── ArrowNockEvent.java
    │       │   │       ├── AttackEntityEvent.java
    │       │   │       ├── BonemealEvent.java
    │       │   │       ├── EntityInteractEvent.java
    │       │   │       ├── EntityItemPickupEvent.java
    │       │   │       ├── FillBucketEvent.java
    │       │   │       ├── ItemTooltipEvent.java
    │       │   │       ├── PlayerDestroyItemEvent.java
    │       │   │       ├── PlayerDropsEvent.java
    │       │   │       ├── PlayerEvent.java
    │       │   │       ├── PlayerFlyableFallEvent.java
    │       │   │       ├── PlayerInteractEvent.java
    │       │   │       ├── PlayerOpenContainerEvent.java
    │       │   │       ├── PlayerSleepInBedEvent.java
    │       │   │       └── UseHoeEvent.java
    │       │   ├── terraingen/
    │       │   │   ├── BiomeEvent.java
    │       │   │   ├── ChunkProviderEvent.java
    │       │   │   ├── DecorateBiomeEvent.java
    │       │   │   ├── DeferredBiomeDecorator.java
    │       │   │   ├── InitMapGenEvent.java
    │       │   │   ├── InitNoiseGensEvent.java
    │       │   │   ├── OreGenEvent.java
    │       │   │   ├── PopulateChunkEvent.java
    │       │   │   ├── SaplingGrowTreeEvent.java
    │       │   │   ├── TerrainGen.java
    │       │   │   └── WorldTypeEvent.java
    │       │   └── world/
    │       │       ├── BlockEvent.java
    │       │       ├── ChunkDataEvent.java
    │       │       ├── ChunkEvent.java
    │       │       ├── ChunkWatchEvent.java
    │       │       └── WorldEvent.java
    │       ├── fluids/
    │       │   ├── BlockFluidBase.java
    │       │   ├── BlockFluidClassic.java
    │       │   ├── BlockFluidFinite.java
    │       │   ├── Fluid.java
    │       │   ├── FluidContainerRegistry.java
    │       │   ├── FluidEvent.java
    │       │   ├── FluidIdMapPacket.java
    │       │   ├── FluidRegistry.java
    │       │   ├── FluidStack.java
    │       │   ├── FluidTank.java
    │       │   ├── FluidTankInfo.java
    │       │   ├── IFluidBlock.java
    │       │   ├── IFluidContainerItem.java
    │       │   ├── IFluidHandler.java
    │       │   ├── IFluidTank.java
    │       │   ├── ItemFluidContainer.java
    │       │   ├── RenderBlockFluid.java
    │       │   └── TileFluidHandler.java
    │       ├── liquids/
    │       │   ├── IBlockLiquid.java
    │       │   ├── ILiquid.java
    │       │   ├── ILiquidTank.java
    │       │   ├── ITankContainer.java
    │       │   ├── LiquidContainerData.java
    │       │   ├── LiquidContainerRegistry.java
    │       │   ├── LiquidDictionary.java
    │       │   ├── LiquidEvent.java
    │       │   ├── LiquidStack.java
    │       │   └── LiquidTank.java
    │       ├── oredict/
    │       │   ├── OreDictionary.java
    │       │   ├── RecipeSorter.java
    │       │   ├── ShapedOreRecipe.java
    │       │   └── ShapelessOreRecipe.java
    │       ├── server/
    │       │   ├── ForgeTimeTracker.java
    │       │   └── command/
    │       │       └── ForgeCommand.java
    │       └── transformers/
    │           ├── EventTransformer.java
    │           └── ForgeAccessTransformer.java
    └── paulscode/
        └── sound/
            └── codecs/
                └── CodecIBXM.java

================================================
FILE: BaseMod.java
================================================
import net.minecraft.server.MinecraftServer;
import java.util.Random;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;
import java.util.Map;
import cpw.mods.fml.client.FMLClientHandler;
import cpw.mods.fml.common.TickType;
import cpw.mods.fml.common.modloader.BaseModProxy;

// 
// Decompiled by Procyon v0.6.0
// 

@Deprecated
public abstract class BaseMod implements BaseModProxy
{
    @Deprecated
    @Override
    public final boolean doTickInGame(final TickType tick, final boolean tickEnd, final Object... data) {
        final atv mc = FMLClientHandler.instance().getClient();
        final boolean hasWorld = mc.f != null;
        return !tickEnd || (tick != TickType.RENDER && tick != TickType.CLIENT) || !hasWorld || this.onTickInGame((float)data[0], mc);
    }
    
    @Deprecated
    @Override
    public final boolean doTickInGUI(final TickType tick, final boolean tickEnd, final Object... data) {
        final atv mc = FMLClientHandler.instance().getClient();
        final boolean hasWorld = mc.f != null;
        return !tickEnd || (tick != TickType.RENDER && (tick != TickType.CLIENT || !hasWorld)) || this.onTickInGUI((float)data[0], mc, mc.n);
    }
    
    @Deprecated
    @Override
    public int addFuel(final int id, final int metadata) {
        return 0;
    }
    
    @SideOnly(Side.CLIENT)
    @Deprecated
    public void addRenderer(final Map<Class<? extends nn>, bgm> renderers) {
    }
    
    @Deprecated
    @Override
    public void generateNether(final abw world, final Random random, final int chunkX, final int chunkZ) {
    }
    
    @Deprecated
    @Override
    public void generateSurface(final abw world, final Random random, final int chunkX, final int chunkZ) {
    }
    
    @Deprecated
    @SideOnly(Side.CLIENT)
    public awy getContainerGUI(final bdi player, final int containerID, final int x, final int y, final int z) {
        return null;
    }
    
    @Deprecated
    @Override
    public String getName() {
        return this.getClass().getSimpleName();
    }
    
    @Deprecated
    @Override
    public String getPriorities() {
        return "";
    }
    
    @Deprecated
    @Override
    public abstract String getVersion();
    
    @SideOnly(Side.CLIENT)
    @Deprecated
    public void keyboardEvent(final ats event) {
    }
    
    @Deprecated
    @Override
    public abstract void load();
    
    @Deprecated
    @Override
    public void modsLoaded() {
    }
    
    @Deprecated
    @Override
    public void onItemPickup(final uf player, final ye item) {
    }
    
    @Deprecated
    @SideOnly(Side.CLIENT)
    public boolean onTickInGame(final float time, final atv minecraftInstance) {
        return false;
    }
    
    @Deprecated
    public boolean onTickInGame(final MinecraftServer minecraftServer) {
        return false;
    }
    
    @Deprecated
    @SideOnly(Side.CLIENT)
    public boolean onTickInGUI(final float tick, final atv game, final awe gui) {
        return false;
    }
    
    @Deprecated
    @Override
    public void clientChat(final String text) {
    }
    
    @SideOnly(Side.CLIENT)
    @Deprecated
    public void clientConnect(final bcw handler) {
    }
    
    @SideOnly(Side.CLIENT)
    @Deprecated
    public void clientDisconnect(final bcw handler) {
    }
    
    @Deprecated
    @Override
    public void receiveCustomPacket(final ea packet) {
    }
    
    @SideOnly(Side.CLIENT)
    @Deprecated
    public void registerAnimation(final atv game) {
    }
    
    @SideOnly(Side.CLIENT)
    @Deprecated
    public void renderInvBlock(final bfr renderer, final aqz block, final int metadata, final int modelID) {
    }
    
    @SideOnly(Side.CLIENT)
    @Deprecated
    public boolean renderWorldBlock(final bfr renderer, final acf world, final int x, final int y, final int z, final aqz block, final int modelID) {
        return false;
    }
    
    @Deprecated
    @Override
    public void serverConnect(final ez handler) {
    }
    
    @Deprecated
    @Override
    public void serverCustomPayload(final ka handler, final ea packet) {
    }
    
    @Deprecated
    @Override
    public void serverDisconnect() {
    }
    
    @Deprecated
    @Override
    public void takenFromCrafting(final uf player, final ye item, final mo matrix) {
    }
    
    @Deprecated
    @Override
    public void takenFromFurnace(final uf player, final ye item) {
    }
    
    @Override
    public String toString() {
        return this.getName() + " " + this.getVersion();
    }
    
    @Deprecated
    @Override
    public void serverChat(final ka source, final String message) {
    }
    
    @Deprecated
    @Override
    public void onClientLogin(final uf player) {
    }
    
    @Deprecated
    @Override
    public void onClientLogout(final cm mgr) {
    }
    
    @SideOnly(Side.CLIENT)
    @Deprecated
    public nn spawnEntity(final int entityId, final abw world, final double scaledX, final double scaledY, final double scaledZ) {
        return null;
    }
    
    @SideOnly(Side.CLIENT)
    @Deprecated
    public void clientCustomPayload(final bcw handler, final ea packet) {
    }
}



================================================
FILE: EntityRendererProxy.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

@Deprecated
public class EntityRendererProxy extends bfe
{
    public static final String fmlMarker = "This is an FML marker";
    private atv game;
    
    @Deprecated
    public EntityRendererProxy(final atv minecraft) {
        super(minecraft);
        this.game = minecraft;
    }
    
    @Deprecated
    public void b(final float tick) {
        super.b(tick);
    }
}



================================================
FILE: FMLRenderAccessLibrary.java
================================================
import cpw.mods.fml.client.registry.RenderingRegistry;
import java.util.logging.Level;
import cpw.mods.fml.common.FMLLog;
import java.util.logging.Logger;

// 
// Decompiled by Procyon v0.6.0
// 

public class FMLRenderAccessLibrary
{
    public static Logger getLogger() {
        final Logger l = Logger.getLogger("FMLRenderAccessLibrary");
        l.setParent(FMLLog.getLogger());
        return l;
    }
    
    public static void log(final Level level, final String message) {
        FMLLog.log("FMLRenderAccessLibrary", level, message, new Object[0]);
    }
    
    public static void log(final Level level, final String message, final Throwable throwable) {
        FMLLog.log(level, throwable, message, new Object[0]);
    }
    
    public static boolean renderWorldBlock(final bfr renderer, final acf world, final int x, final int y, final int z, final aqz block, final int modelId) {
        return RenderingRegistry.instance().renderWorldBlock(renderer, world, x, y, z, block, modelId);
    }
    
    public static void renderInventoryBlock(final bfr renderer, final aqz block, final int metadata, final int modelID) {
        RenderingRegistry.instance().renderInventoryBlock(renderer, block, metadata, modelID);
    }
    
    public static boolean renderItemAsFull3DBlock(final int modelId) {
        return RenderingRegistry.instance().renderItemAsFull3DBlock(modelId);
    }
}



================================================
FILE: MLProp.java
================================================
import java.lang.annotation.ElementType;
import java.lang.annotation.Target;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Retention;

// 
// Decompiled by Procyon v0.6.0
// 

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD })
@Deprecated
public @interface MLProp {
    @Deprecated
    String info() default "";
    
    @Deprecated
    double max() default Double.MAX_VALUE;
    
    @Deprecated
    double min() default Double.MIN_VALUE;
    
    @Deprecated
    String name() default "";
}



================================================
FILE: ModLoader.java
================================================
import java.util.Collections;
import cpw.mods.fml.client.registry.ClientRegistry;
import cpw.mods.fml.common.Loader;
import cpw.mods.fml.common.network.Player;
import cpw.mods.fml.common.network.NetworkRegistry;
import cpw.mods.fml.client.modloader.ModLoaderClientHelper;
import cpw.mods.fml.common.ObfuscationReflectionHelper;
import cpw.mods.fml.common.FMLCommonHandler;
import net.minecraft.server.MinecraftServer;
import cpw.mods.fml.client.FMLClientHandler;
import cpw.mods.fml.common.FMLLog;
import java.util.logging.Logger;
import cpw.mods.fml.common.modloader.ModLoaderModContainer;
import java.util.List;
import cpw.mods.fml.common.network.PacketDispatcher;
import cpw.mods.fml.common.registry.EntityRegistry;
import cpw.mods.fml.common.registry.LanguageRegistry;
import cpw.mods.fml.common.modloader.BaseModProxy;
import cpw.mods.fml.common.modloader.ModLoaderHelper;
import cpw.mods.fml.common.registry.GameRegistry;
import cpw.mods.fml.client.registry.RenderingRegistry;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;
import java.util.Map;

// 
// Decompiled by Procyon v0.6.0
// 

@Deprecated
public class ModLoader
{
    public static final String fmlMarker = "This is an FML marker";
    @Deprecated
    public static final Map<String, Map<String, String>> localizedStrings;
    
    @Deprecated
    public static void addAchievementDesc(final ko achievement, final String name, final String description) {
        final String achName = achievement.i();
        addLocalization(achName, name);
        addLocalization(achName + ".desc", description);
    }
    
    @Deprecated
    public static int addAllFuel(final int id, final int metadata) {
        return 0;
    }
    
    @Deprecated
    @SideOnly(Side.CLIENT)
    public static void addAllRenderers(final Map<Class<? extends nn>, bgm> renderers) {
    }
    
    @Deprecated
    @SideOnly(Side.CLIENT)
    public static int addArmor(final String armor) {
        return RenderingRegistry.addNewArmourRendererPrefix(armor);
    }
    
    @Deprecated
    public static void addBiome(final acq biome) {
        GameRegistry.addBiome(biome);
    }
    
    @Deprecated
    public static void addEntityTracker(final BaseMod mod, final Class<? extends nn> entityClass, final int entityTypeId, final int updateRange, final int updateInterval, final boolean sendVelocityInfo) {
        ModLoaderHelper.buildEntityTracker(mod, entityClass, entityTypeId, updateRange, updateInterval, sendVelocityInfo);
    }
    
    @Deprecated
    public static void addCommand(final ab command) {
        ModLoaderHelper.addCommand(command);
    }
    
    @Deprecated
    public static void addDispenserBehavior(final yc item, final bj behavior) {
        any.a.a((Object)item, (Object)behavior);
    }
    
    @Deprecated
    public static void addLocalization(final String key, final String value) {
        addLocalization(key, "en_US", value);
    }
    
    @Deprecated
    public static void addLocalization(final String key, final String lang, final String value) {
        LanguageRegistry.instance().addStringLocalization(key, lang, value);
    }
    
    @Deprecated
    public static void addName(final Object instance, final String name) {
        addName(instance, "en_US", name);
    }
    
    @Deprecated
    public static void addName(final Object instance, final String lang, final String name) {
        LanguageRegistry.instance().addNameForObject(instance, lang, name);
    }
    
    @Deprecated
    @SideOnly(Side.CLIENT)
    public static int addOverride(final String fileToOverride, final String fileToAdd) {
        return RenderingRegistry.addTextureOverride(fileToOverride, fileToAdd);
    }
    
    @Deprecated
    @SideOnly(Side.CLIENT)
    public static void addOverride(final String path, final String overlayPath, final int index) {
        RenderingRegistry.addTextureOverride(path, overlayPath, index);
    }
    
    @Deprecated
    public static void addRecipe(final ye output, final Object... params) {
        GameRegistry.addRecipe(output, params);
    }
    
    @Deprecated
    public static void addShapelessRecipe(final ye output, final Object... params) {
        GameRegistry.addShapelessRecipe(output, params);
    }
    
    @Deprecated
    public static void addSmelting(final int input, final ye output) {
        GameRegistry.addSmelting(input, output, 1.0f);
    }
    
    @Deprecated
    public static void addSmelting(final int input, final ye output, final float experience) {
        GameRegistry.addSmelting(input, output, experience);
    }
    
    @Deprecated
    public static void addSpawn(final Class<? extends og> entityClass, final int weightedProb, final int min, final int max, final oh spawnList) {
        EntityRegistry.addSpawn(entityClass, weightedProb, min, max, spawnList, acg.base12Biomes);
    }
    
    @Deprecated
    public static void addSpawn(final Class<? extends og> entityClass, final int weightedProb, final int min, final int max, final oh spawnList, final acq... biomes) {
        EntityRegistry.addSpawn(entityClass, weightedProb, min, max, spawnList, biomes);
    }
    
    @Deprecated
    public static void addSpawn(final String entityName, final int weightedProb, final int min, final int max, final oh spawnList) {
        EntityRegistry.addSpawn(entityName, weightedProb, min, max, spawnList, acg.base12Biomes);
    }
    
    @Deprecated
    public static void addSpawn(final String entityName, final int weightedProb, final int min, final int max, final oh spawnList, final acq... biomes) {
        EntityRegistry.addSpawn(entityName, weightedProb, min, max, spawnList, biomes);
    }
    
    @Deprecated
    public static void addTrade(final int profession, final TradeEntry entry) {
        ModLoaderHelper.registerTrade(profession, entry);
    }
    
    @Deprecated
    public static void clientSendPacket(final ey packet) {
        PacketDispatcher.sendPacketToServer(packet);
    }
    
    @Deprecated
    public static boolean dispenseEntity(final abw world, final double x, final double y, final double z, final int xVel, final int zVel, final ye item) {
        return false;
    }
    
    @Deprecated
    public static void genericContainerRemoval(final abw world, final int x, final int y, final int z) {
    }
    
    @Deprecated
    public static List<BaseMod> getLoadedMods() {
        return ModLoaderModContainer.findAll(BaseMod.class);
    }
    
    @Deprecated
    public static Logger getLogger() {
        return FMLLog.getLogger();
    }
    
    @SideOnly(Side.CLIENT)
    @Deprecated
    public static atv getMinecraftInstance() {
        return FMLClientHandler.instance().getClient();
    }
    
    @Deprecated
    public static MinecraftServer getMinecraftServerInstance() {
        return FMLCommonHandler.instance().getMinecraftServerInstance();
    }
    
    @Deprecated
    public static <T, E> T getPrivateValue(final Class<? super E> instanceclass, final E instance, final int fieldindex) {
        return ObfuscationReflectionHelper.getPrivateValue(instanceclass, instance, fieldindex);
    }
    
    @Deprecated
    public static <T, E> T getPrivateValue(final Class<? super E> instanceclass, final E instance, final String field) {
        return ObfuscationReflectionHelper.getPrivateValue(instanceclass, instance, field);
    }
    
    @SideOnly(Side.CLIENT)
    @Deprecated
    public static int getUniqueBlockModelID(final BaseMod mod, final boolean inventoryRenderer) {
        return ModLoaderClientHelper.obtainBlockModelIdFor(mod, inventoryRenderer);
    }
    
    @Deprecated
    public static int getUniqueEntityId() {
        return EntityRegistry.findGlobalUniqueEntityId();
    }
    
    @Deprecated
    @SideOnly(Side.CLIENT)
    public static int getUniqueSpriteIndex(final String path) {
        return -1;
    }
    
    @Deprecated
    public static boolean isChannelActive(final uf player, final String channel) {
        return NetworkRegistry.instance().isChannelActive(channel, (Player)player);
    }
    
    @SideOnly(Side.CLIENT)
    @Deprecated
    public static boolean isGUIOpen(final Class<? extends awe> gui) {
        return FMLClientHandler.instance().isGUIOpen(gui);
    }
    
    @Deprecated
    public static boolean isModLoaded(final String modname) {
        return Loader.isModLoaded(modname);
    }
    
    @Deprecated
    public static void loadConfig() {
    }
    
    @Deprecated
    public static void onItemPickup(final uf player, final ye item) {
    }
    
    @Deprecated
    @SideOnly(Side.CLIENT)
    public static void onTick(final float tick, final atv game) {
    }
    
    @Deprecated
    @SideOnly(Side.CLIENT)
    public static void openGUI(final uf player, final awe gui) {
        FMLClientHandler.instance().displayGuiScreen(player, gui);
    }
    
    @Deprecated
    public static void populateChunk(final ado generator, final int chunkX, final int chunkZ, final abw world) {
    }
    
    @Deprecated
    public static void receivePacket(final ea packet) {
    }
    
    @Deprecated
    @SideOnly(Side.CLIENT)
    public static ats[] registerAllKeys(final ats[] keys) {
        return keys;
    }
    
    @Deprecated
    public static void registerBlock(final aqz block) {
        GameRegistry.registerBlock(block);
    }
    
    @Deprecated
    public static void registerBlock(final aqz block, final Class<? extends zh> itemclass) {
        GameRegistry.registerBlock(block, itemclass);
    }
    
    @Deprecated
    public static void registerContainerID(final BaseMod mod, final int id) {
        ModLoaderHelper.buildGuiHelper(mod, id);
    }
    
    @Deprecated
    public static void registerEntityID(final Class<? extends nn> entityClass, final String entityName, final int id) {
        EntityRegistry.registerGlobalEntityID(entityClass, entityName, id);
    }
    
    @Deprecated
    public static void registerEntityID(final Class<? extends nn> entityClass, final String entityName, final int id, final int background, final int foreground) {
        EntityRegistry.registerGlobalEntityID(entityClass, entityName, id, background, foreground);
    }
    
    @SideOnly(Side.CLIENT)
    @Deprecated
    public static void registerKey(final BaseMod mod, final ats keyHandler, final boolean allowRepeat) {
        ModLoaderClientHelper.registerKeyBinding(mod, keyHandler, allowRepeat);
    }
    
    @Deprecated
    public static void registerPacketChannel(final BaseMod mod, final String channel) {
        NetworkRegistry.instance().registerChannel(ModLoaderHelper.buildPacketHandlerFor(mod), channel);
    }
    
    @Deprecated
    public static void registerTileEntity(final Class<? extends asp> tileEntityClass, final String id) {
        GameRegistry.registerTileEntity(tileEntityClass, id);
    }
    
    @SideOnly(Side.CLIENT)
    @Deprecated
    public static void registerTileEntity(final Class<? extends asp> tileEntityClass, final String id, final bje renderer) {
        ClientRegistry.registerTileEntity(tileEntityClass, id, renderer);
    }
    
    @Deprecated
    public static void removeBiome(final acq biome) {
        GameRegistry.removeBiome(biome);
    }
    
    @Deprecated
    public static void removeSpawn(final Class<? extends og> entityClass, final oh spawnList) {
        EntityRegistry.removeSpawn(entityClass, spawnList, acg.base12Biomes);
    }
    
    @Deprecated
    public static void removeSpawn(final Class<? extends og> entityClass, final oh spawnList, final acq... biomes) {
        EntityRegistry.removeSpawn(entityClass, spawnList, biomes);
    }
    
    @Deprecated
    public static void removeSpawn(final String entityName, final oh spawnList) {
        EntityRegistry.removeSpawn(entityName, spawnList, acg.base12Biomes);
    }
    
    @Deprecated
    public static void removeSpawn(final String entityName, final oh spawnList, final acq... biomes) {
        EntityRegistry.removeSpawn(entityName, spawnList, biomes);
    }
    
    @Deprecated
    @SideOnly(Side.CLIENT)
    public static boolean renderBlockIsItemFull3D(final int modelID) {
        return RenderingRegistry.instance().renderItemAsFull3DBlock(modelID);
    }
    
    @Deprecated
    @SideOnly(Side.CLIENT)
    public static void renderInvBlock(final bfr renderer, final aqz block, final int metadata, final int modelID) {
        RenderingRegistry.instance().renderInventoryBlock(renderer, block, metadata, modelID);
    }
    
    @Deprecated
    @SideOnly(Side.CLIENT)
    public static boolean renderWorldBlock(final bfr renderer, final acf world, final int x, final int y, final int z, final aqz block, final int modelID) {
        return RenderingRegistry.instance().renderWorldBlock(renderer, world, x, y, z, block, modelID);
    }
    
    @Deprecated
    public static void saveConfig() {
    }
    
    @Deprecated
    public static void sendPacket(final ey packet) {
        PacketDispatcher.sendPacketToServer(packet);
    }
    
    @Deprecated
    public static void serverChat(final String text) {
    }
    
    @Deprecated
    @SideOnly(Side.CLIENT)
    public static void serverLogin(final bcw handler, final ep loginPacket) {
    }
    
    @Deprecated
    public static void serverSendPacket(final ka handler, final ey packet) {
        if (handler != null) {
            PacketDispatcher.sendPacketToPlayer(packet, (Player)handler.getPlayer());
        }
    }
    
    @Deprecated
    public static void serverOpenWindow(final jv player, final uy container, final int ID, final int x, final int y, final int z) {
        ModLoaderHelper.openGui(ID, (uf)player, container, x, y, z);
    }
    
    @Deprecated
    public static void setInGameHook(final BaseMod mod, final boolean enable, final boolean useClock) {
        ModLoaderHelper.updateStandardTicks(mod, enable, useClock);
    }
    
    @Deprecated
    public static void setInGUIHook(final BaseMod mod, final boolean enable, final boolean useClock) {
        ModLoaderHelper.updateGUITicks(mod, enable, useClock);
    }
    
    @Deprecated
    public static <T, E> void setPrivateValue(final Class<? super T> instanceclass, final T instance, final int fieldindex, final E value) {
        ObfuscationReflectionHelper.setPrivateValue(instanceclass, instance, value, fieldindex);
    }
    
    @Deprecated
    public static <T, E> void setPrivateValue(final Class<? super T> instanceclass, final T instance, final String field, final E value) {
        ObfuscationReflectionHelper.setPrivateValue(instanceclass, instance, value, field);
    }
    
    @Deprecated
    public static void takenFromCrafting(final uf player, final ye item, final mo matrix) {
    }
    
    @Deprecated
    public static void takenFromFurnace(final uf player, final ye item) {
    }
    
    @Deprecated
    public static void throwException(final String message, final Throwable e) {
        FMLCommonHandler.instance().raiseException(e, message, true);
    }
    
    @Deprecated
    public static void throwException(final Throwable e) {
        throwException("Exception in ModLoader", e);
    }
    
    static {
        localizedStrings = Collections.emptyMap();
    }
}



================================================
FILE: TradeEntry.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

@Deprecated
public class TradeEntry
{
    @Deprecated
    public final int id;
    @Deprecated
    public float chance;
    @Deprecated
    public boolean buying;
    @Deprecated
    public int min;
    @Deprecated
    public int max;
    
    @Deprecated
    public TradeEntry(final int id, final float chance, final boolean buying, final int min, final int max) {
        this.min = 0;
        this.max = 0;
        this.id = id;
        this.chance = chance;
        this.buying = buying;
        this.min = min;
        this.max = max;
    }
    
    @Deprecated
    public TradeEntry(final int id, final float chance, final boolean buying) {
        this(id, chance, buying, 0, 0);
    }
}



================================================
FILE: cpw/mods/fml/client/CustomModLoadingErrorDisplayException.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client;

import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;
import cpw.mods.fml.common.IFMLHandledException;

@SideOnly(Side.CLIENT)
public abstract class CustomModLoadingErrorDisplayException extends RuntimeException implements IFMLHandledException
{
    public abstract void initGui(final avh p0, final avi p1);
    
    public abstract void drawScreen(final avh p0, final avi p1, final int p2, final int p3, final float p4);
}



================================================
FILE: cpw/mods/fml/client/FMLClientHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client;

import cpw.mods.fml.common.ObfuscationReflectionHelper;
import cpw.mods.fml.common.registry.GameData;
import cpw.mods.fml.common.registry.ItemData;
import com.google.common.collect.MapDifference;
import cpw.mods.fml.common.network.ModMissingPacket;
import net.minecraft.server.MinecraftServer;
import cpw.mods.fml.common.network.EntitySpawnAdjustmentPacket;
import cpw.mods.fml.common.registry.IEntityAdditionalSpawnData;
import cpw.mods.fml.common.registry.IThrowableEntity;
import cpw.mods.fml.common.network.EntitySpawnPacket;
import cpw.mods.fml.common.registry.EntityRegistry;
import cpw.mods.fml.relauncher.Side;
import com.google.common.collect.ImmutableList;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.logging.Logger;
import cpw.mods.fml.client.registry.KeyBindingRegistry;
import cpw.mods.fml.client.registry.RenderingRegistry;
import com.google.common.base.Throwables;
import java.util.Iterator;
import cpw.mods.fml.common.ModMetadata;
import cpw.mods.fml.common.ModContainer;
import net.minecraft.launchwrapper.Launch;
import cpw.mods.fml.common.LoaderException;
import java.util.logging.Level;
import cpw.mods.fml.common.MetadataCollection;
import com.google.common.collect.ImmutableMap;
import cpw.mods.fml.common.Loader;
import cpw.mods.fml.client.modloader.ModLoaderClientHelper;
import cpw.mods.fml.common.FMLCommonHandler;
import cpw.mods.fml.common.FMLLog;
import com.google.common.collect.Maps;
import java.util.Map;
import java.util.List;
import cpw.mods.fml.common.DuplicateModsFoundException;
import cpw.mods.fml.common.WrongMinecraftVersionException;
import cpw.mods.fml.common.toposort.ModSortingException;
import cpw.mods.fml.common.MissingModsException;
import cpw.mods.fml.common.DummyModContainer;
import cpw.mods.fml.common.IFMLSidedHandler;

public class FMLClientHandler implements IFMLSidedHandler
{
    private static final FMLClientHandler INSTANCE;
    private atv client;
    private DummyModContainer optifineContainer;
    private boolean guiLoaded;
    private boolean serverIsRunning;
    private MissingModsException modsMissing;
    private ModSortingException modSorting;
    private boolean loading;
    private WrongMinecraftVersionException wrongMC;
    private CustomModLoadingErrorDisplayException customError;
    private DuplicateModsFoundException dupesFound;
    private boolean serverShouldBeKilledQuietly;
    private List<bjr> resourcePackList;
    private bjm resourceManager;
    private Map<String, bjr> resourcePackMap;
    
    public FMLClientHandler() {
        this.loading = true;
    }
    
    public void beginMinecraftLoading(final atv minecraft, final List resourcePackList, final bjm resourceManager) {
        this.client = minecraft;
        this.resourcePackList = resourcePackList;
        this.resourceManager = resourceManager;
        this.resourcePackMap = Maps.newHashMap();
        if (minecraft.p()) {
            FMLLog.severe("DEMO MODE DETECTED, FML will not work. Finishing now.", new Object[0]);
            this.haltGame("FML will not run in demo mode", new RuntimeException());
            return;
        }
        FMLCommonHandler.instance().beginLoading(this);
        new ModLoaderClientHelper(this.client);
        try {
            final Class<?> optifineConfig = Class.forName("Config", false, Loader.instance().getModClassLoader());
            final String optifineVersion = (String)optifineConfig.getField("VERSION").get(null);
            final Map<String, Object> dummyOptifineMeta = (Map<String, Object>)ImmutableMap.builder().put((Object)"name", (Object)"Optifine").put((Object)"version", (Object)optifineVersion).build();
            final ModMetadata optifineMetadata = MetadataCollection.from(this.getClass().getResourceAsStream("optifinemod.info"), "optifine").getMetadataForId("optifine", dummyOptifineMeta);
            this.optifineContainer = new DummyModContainer(optifineMetadata);
            FMLLog.info("Forge Mod Loader has detected optifine %s, enabling compatibility features", this.optifineContainer.getVersion());
        }
        catch (final Exception e) {
            this.optifineContainer = null;
        }
        try {
            Loader.instance().loadMods();
        }
        catch (final WrongMinecraftVersionException wrong) {
            this.wrongMC = wrong;
        }
        catch (final DuplicateModsFoundException dupes) {
            this.dupesFound = dupes;
        }
        catch (final MissingModsException missing) {
            this.modsMissing = missing;
        }
        catch (final ModSortingException sorting) {
            this.modSorting = sorting;
        }
        catch (final CustomModLoadingErrorDisplayException custom) {
            FMLLog.log(Level.SEVERE, custom, "A custom exception was thrown by a mod, the game will now halt", new Object[0]);
            this.customError = custom;
        }
        catch (final LoaderException le) {
            this.haltGame("There was a severe problem during mod loading that has caused the game to fail", le);
            return;
        }
        Map<String, Map<String, String>> sharedModList = Launch.blackboard.get("modList");
        if (sharedModList == null) {
            sharedModList = Maps.newHashMap();
            Launch.blackboard.put("modList", sharedModList);
        }
        for (final ModContainer mc : Loader.instance().getActiveModList()) {
            final Map<String, String> sharedModDescriptor = mc.getSharedModDescriptor();
            if (sharedModDescriptor != null) {
                final String sharedModId = "fml:" + mc.getModId();
                sharedModList.put(sharedModId, sharedModDescriptor);
            }
        }
    }
    
    @Override
    public void haltGame(final String message, final Throwable t) {
        this.client.c(new b(message, t));
        throw Throwables.propagate(t);
    }
    
    public void finishMinecraftLoading() {
        if (this.modsMissing != null || this.wrongMC != null || this.customError != null || this.dupesFound != null || this.modSorting != null) {
            return;
        }
        try {
            Loader.instance().initializeMods();
        }
        catch (final CustomModLoadingErrorDisplayException custom) {
            FMLLog.log(Level.SEVERE, custom, "A custom exception was thrown by a mod, the game will now halt", new Object[0]);
            this.customError = custom;
            return;
        }
        catch (final LoaderException le) {
            this.haltGame("There was a severe problem during mod loading that has caused the game to fail", le);
            return;
        }
        this.client.v.LOAD_SOUND_SYSTEM = true;
        this.client.a();
        RenderingRegistry.instance().loadEntityRenderers(bgl.a.q);
        this.loading = false;
        KeyBindingRegistry.instance().uploadKeyBindingsToGame(this.client.u);
    }
    
    public void extendModList() {
        final Map<String, Map<String, String>> modList = Launch.blackboard.get("modList");
        if (modList != null) {
            for (final Map.Entry<String, Map<String, String>> modEntry : modList.entrySet()) {
                final String sharedModId = modEntry.getKey();
                final String system = sharedModId.split(":")[0];
                if ("fml".equals(system)) {
                    continue;
                }
                final Map<String, String> mod = modEntry.getValue();
                final String modSystem = mod.get("modsystem");
                final String modId = mod.get("id");
                final String modVersion = mod.get("version");
                final String modName = mod.get("name");
                final String modURL = mod.get("url");
                final String modAuthors = mod.get("authors");
                final String modDescription = mod.get("description");
            }
        }
    }
    
    public void onInitializationComplete() {
        if (this.wrongMC != null) {
            this.client.a((awe)new GuiWrongMinecraft(this.wrongMC));
        }
        else if (this.modsMissing != null) {
            this.client.a((awe)new GuiModsMissing(this.modsMissing));
        }
        else if (this.dupesFound != null) {
            this.client.a((awe)new GuiDupesFound(this.dupesFound));
        }
        else if (this.modSorting != null) {
            this.client.a((awe)new GuiSortingProblem(this.modSorting));
        }
        else if (this.customError != null) {
            this.client.a((awe)new GuiCustomModLoadingErrorScreen(this.customError));
        }
    }
    
    public atv getClient() {
        return this.client;
    }
    
    public Logger getMinecraftLogger() {
        return null;
    }
    
    public static FMLClientHandler instance() {
        return FMLClientHandler.INSTANCE;
    }
    
    public void displayGuiScreen(final uf player, final awe gui) {
        if (this.client.h == player && gui != null) {
            this.client.a(gui);
        }
    }
    
    public void addSpecialModEntries(final ArrayList<ModContainer> mods) {
        if (this.optifineContainer != null) {
            mods.add(this.optifineContainer);
        }
    }
    
    @Override
    public List<String> getAdditionalBrandingInformation() {
        if (this.optifineContainer != null) {
            return Arrays.asList(String.format("Optifine %s", this.optifineContainer.getVersion()));
        }
        return (List<String>)ImmutableList.of();
    }
    
    @Override
    public Side getSide() {
        return Side.CLIENT;
    }
    
    public boolean hasOptifine() {
        return this.optifineContainer != null;
    }
    
    @Override
    public void showGuiScreen(final Object clientGuiElement) {
        final awe gui = (awe)clientGuiElement;
        this.client.a(gui);
    }
    
    @Override
    public nn spawnEntityIntoClientWorld(final EntityRegistry.EntityRegistration er, final EntitySpawnPacket packet) {
        final bdd wc = this.client.f;
        final Class<? extends nn> cls = er.getEntityClass();
        try {
            nn entity;
            if (er.hasCustomSpawning()) {
                entity = er.doCustomSpawning(packet);
            }
            else {
                entity = (nn)cls.getConstructor(abw.class).newInstance(wc);
                final int offset = packet.entityId - entity.k;
                entity.k = packet.entityId;
                entity.b(packet.scaledX, packet.scaledY, packet.scaledZ, packet.scaledYaw, packet.scaledPitch);
                if (entity instanceof og) {
                    ((og)entity).aP = packet.scaledHeadYaw;
                }
                final nn[] parts = entity.ao();
                if (parts != null) {
                    for (int j = 0; j < parts.length; ++j) {
                        final nn nn = parts[j];
                        nn.k += offset;
                    }
                }
            }
            entity.bZ = packet.rawX;
            entity.ca = packet.rawY;
            entity.cb = packet.rawZ;
            if (entity instanceof IThrowableEntity) {
                final nn thrower = (nn)((this.client.h.k == packet.throwerId) ? this.client.h : wc.a(packet.throwerId));
                ((IThrowableEntity)entity).setThrower(thrower);
            }
            if (packet.metadata != null) {
                entity.v().a(packet.metadata);
            }
            if (packet.throwerId > 0) {
                entity.h(packet.speedScaledX, packet.speedScaledY, packet.speedScaledZ);
            }
            if (entity instanceof IEntityAdditionalSpawnData) {
                ((IEntityAdditionalSpawnData)entity).readSpawnData(packet.dataStream);
            }
            wc.a(packet.entityId, entity);
            return entity;
        }
        catch (final Exception e) {
            FMLLog.log(Level.SEVERE, e, "A severe problem occurred during the spawning of an entity", new Object[0]);
            throw Throwables.propagate((Throwable)e);
        }
    }
    
    @Override
    public void adjustEntityLocationOnClient(final EntitySpawnAdjustmentPacket packet) {
        final nn ent = this.client.f.a(packet.entityId);
        if (ent != null) {
            ent.bZ = packet.serverX;
            ent.ca = packet.serverY;
            ent.cb = packet.serverZ;
        }
        else {
            FMLLog.fine("Attempted to adjust the position of entity %d which is not present on the client", packet.entityId);
        }
    }
    
    @Override
    public void beginServerLoading(final MinecraftServer server) {
        this.serverShouldBeKilledQuietly = false;
    }
    
    @Override
    public void finishServerLoading() {
    }
    
    @Override
    public MinecraftServer getServer() {
        return (MinecraftServer)this.client.C();
    }
    
    @Override
    public void sendPacket(final ey packet) {
        if (this.client.h != null) {
            this.client.h.a.c(packet);
        }
    }
    
    @Override
    public void displayMissingMods(final ModMissingPacket modMissingPacket) {
        this.client.a((awe)new GuiModsMissingForServer(modMissingPacket));
    }
    
    public boolean isLoading() {
        return this.loading;
    }
    
    @Override
    public void handleTinyPacket(final ez handler, final dr mapData) {
        ((bcw)handler).fmlPacket131Callback(mapData);
    }
    
    @Override
    public void setClientCompatibilityLevel(final byte compatibilityLevel) {
        bcw.setConnectionCompatibilityLevel(compatibilityLevel);
    }
    
    @Override
    public byte getClientCompatibilityLevel() {
        return bcw.getConnectionCompatibilityLevel();
    }
    
    public void warnIDMismatch(final MapDifference<Integer, ItemData> idDifferences, final boolean mayContinue) {
        final GuiIdMismatchScreen mismatch = new GuiIdMismatchScreen(idDifferences, mayContinue);
        this.client.a((awe)mismatch);
    }
    
    public void callbackIdDifferenceResponse(final boolean response) {
        if (response) {
            this.serverShouldBeKilledQuietly = false;
            GameData.releaseGate(true);
            this.client.continueWorldLoading();
        }
        else {
            this.serverShouldBeKilledQuietly = true;
            GameData.releaseGate(false);
            this.client.a((bdd)null);
            this.client.a((awe)null);
        }
    }
    
    @Override
    public boolean shouldServerShouldBeKilledQuietly() {
        return this.serverShouldBeKilledQuietly;
    }
    
    @Override
    public void disconnectIDMismatch(final MapDifference<Integer, ItemData> s, final ez toKill, final cm mgr) {
        boolean criticalMismatch = !s.entriesOnlyOnLeft().isEmpty();
        for (final Map.Entry<Integer, MapDifference.ValueDifference<ItemData>> mismatch : s.entriesDiffering().entrySet()) {
            final MapDifference.ValueDifference<ItemData> vd = mismatch.getValue();
            if (!((ItemData)vd.leftValue()).mayDifferByOrdinal((ItemData)vd.rightValue())) {
                criticalMismatch = true;
            }
        }
        if (!criticalMismatch) {
            return;
        }
        ((bcw)toKill).f();
        bcy.forceTermination((bcy)this.client.n);
        mgr.b();
        this.client.a((bdd)null);
        this.warnIDMismatch(s, false);
    }
    
    public boolean isGUIOpen(final Class<? extends awe> gui) {
        return this.client.n != null && this.client.n.getClass().equals(gui);
    }
    
    @Override
    public void addModAsResource(final ModContainer container) {
        final Class<?> resourcePackType = container.getCustomResourcePackClass();
        if (resourcePackType != null) {
            try {
                final bjr pack = (bjr)resourcePackType.getConstructor(ModContainer.class).newInstance(container);
                this.resourcePackList.add(pack);
                this.resourcePackMap.put(container.getModId(), pack);
            }
            catch (final NoSuchMethodException e) {
                FMLLog.log(Level.SEVERE, "The container %s (type %s) returned an invalid class for it's resource pack.", container.getName(), container.getClass().getName());
            }
            catch (final Exception e2) {
                FMLLog.log(Level.SEVERE, e2, "An unexpected exception occurred constructing the custom resource pack for %s", container.getName());
                throw Throwables.propagate((Throwable)e2);
            }
        }
    }
    
    @Override
    public void updateResourcePackList() {
        this.client.a();
    }
    
    public bjr getResourcePackFor(final String modId) {
        return this.resourcePackMap.get(modId);
    }
    
    @Override
    public String getCurrentLanguage() {
        return this.client.M().c().a();
    }
    
    @Override
    public void serverStopped() {
        final MinecraftServer server = this.getServer();
        if (server != null && !server.ah()) {
            ObfuscationReflectionHelper.setPrivateValue(MinecraftServer.class, server, true, "field_71296_Q", "serverIsRunning");
        }
    }
    
    static {
        INSTANCE = new FMLClientHandler();
    }
}



================================================
FILE: cpw/mods/fml/client/FMLFileResourcePack.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.ByteArrayInputStream;
import com.google.common.base.Charsets;
import cpw.mods.fml.common.FMLLog;
import java.util.logging.Level;
import java.io.InputStream;
import cpw.mods.fml.common.ModContainer;

public class FMLFileResourcePack extends bji
{
    private ModContainer container;
    
    public FMLFileResourcePack(final ModContainer container) {
        super(container.getSource());
        this.container = container;
    }
    
    public String b() {
        return "FMLFileResourcePack:" + this.container.getName();
    }
    
    protected InputStream a(final String resourceName) throws IOException {
        try {
            return super.a(resourceName);
        }
        catch (final IOException ioe) {
            if ("pack.mcmeta".equals(resourceName)) {
                FMLLog.log(this.container.getName(), Level.WARNING, "Mod %s is missing a pack.mcmeta file, things may not work well", this.container.getName());
                return new ByteArrayInputStream(("{\n \"pack\": {\n   \"description\": \"dummy FML pack for " + this.container.getName() + "\",\n" + "   \"pack_format\": 1\n" + "}\n" + "}").getBytes(Charsets.UTF_8));
            }
            throw ioe;
        }
    }
    
    public BufferedImage a() throws IOException {
        return ImageIO.read(this.a(this.container.getMetadata().logoFile));
    }
}



================================================
FILE: cpw/mods/fml/client/FMLFolderResourcePack.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.ByteArrayInputStream;
import com.google.common.base.Charsets;
import cpw.mods.fml.common.FMLLog;
import java.util.logging.Level;
import java.io.InputStream;
import cpw.mods.fml.common.ModContainer;

public class FMLFolderResourcePack extends bjj
{
    private ModContainer container;
    
    public FMLFolderResourcePack(final ModContainer container) {
        super(container.getSource());
        this.container = container;
    }
    
    public String b() {
        return "FMLFileResourcePack:" + this.container.getName();
    }
    
    protected InputStream a(final String resourceName) throws IOException {
        try {
            return super.a(resourceName);
        }
        catch (final IOException ioe) {
            if ("pack.mcmeta".equals(resourceName)) {
                FMLLog.log(this.container.getName(), Level.WARNING, "Mod %s is missing a pack.mcmeta file, things may not work well", this.container.getName());
                return new ByteArrayInputStream(("{\n \"pack\": {\n   \"description\": \"dummy FML pack for " + this.container.getName() + "\",\n" + "   \"pack_format\": 1\n" + "}\n" + "}").getBytes(Charsets.UTF_8));
            }
            throw ioe;
        }
    }
    
    public BufferedImage a() throws IOException {
        return ImageIO.read(this.a(this.container.getMetadata().logoFile));
    }
}



================================================
FILE: cpw/mods/fml/client/GuiCustomModLoadingErrorScreen.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client;

public class GuiCustomModLoadingErrorScreen extends avh
{
    private CustomModLoadingErrorDisplayException customException;
    
    public GuiCustomModLoadingErrorScreen(final CustomModLoadingErrorDisplayException customException) {
        super((String)null, (String)null);
        this.customException = customException;
    }
    
    public void A_() {
        super.A_();
        this.customException.initGui(this, this.o);
    }
    
    public void a(final int par1, final int par2, final float par3) {
        this.e();
        this.customException.drawScreen(this, this.o, par1, par2, par3);
    }
}



================================================
FILE: cpw/mods/fml/client/GuiDupesFound.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client;

import java.util.Iterator;
import java.io.File;
import cpw.mods.fml.common.ModContainer;
import java.util.Map;
import cpw.mods.fml.common.DuplicateModsFoundException;

public class GuiDupesFound extends avh
{
    private DuplicateModsFoundException dupes;
    
    public GuiDupesFound(final DuplicateModsFoundException dupes) {
        super((String)null, (String)null);
        this.dupes = dupes;
    }
    
    public void A_() {
        super.A_();
    }
    
    public void a(final int par1, final int par2, final float par3) {
        this.e();
        int offset = Math.max(85 - this.dupes.dupes.size() * 10, 10);
        this.a(this.o, "Forge Mod Loader has found a problem with your minecraft installation", this.g / 2, offset, 16777215);
        offset += 10;
        this.a(this.o, "You have mod sources that are duplicate within your system", this.g / 2, offset, 16777215);
        offset += 10;
        this.a(this.o, "Mod Id : File name", this.g / 2, offset, 16777215);
        offset += 5;
        for (final Map.Entry<ModContainer, File> mc : this.dupes.dupes.entries()) {
            offset += 10;
            this.a(this.o, String.format("%s : %s", mc.getKey().getModId(), mc.getValue().getName()), this.g / 2, offset, 15658734);
        }
    }
}



================================================
FILE: cpw/mods/fml/client/GuiIdMismatchScreen.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client;

import java.util.Iterator;
import java.util.Map;
import com.google.common.collect.Lists;
import cpw.mods.fml.common.registry.ItemData;
import com.google.common.collect.MapDifference;
import java.util.List;

public class GuiIdMismatchScreen extends aux
{
    private List<String> missingIds;
    private List<String> mismatchedIds;
    private boolean allowContinue;
    
    public GuiIdMismatchScreen(final MapDifference<Integer, ItemData> idDifferences, final boolean allowContinue) {
        super((awe)null, "ID mismatch", "Should I continue?", 1);
        this.missingIds = Lists.newArrayList();
        this.mismatchedIds = Lists.newArrayList();
        this.a = (awe)this;
        for (final Map.Entry<Integer, ItemData> entry : idDifferences.entriesOnlyOnLeft().entrySet()) {
            this.missingIds.add(String.format("ID %d from Mod %s is missing", entry.getValue().getItemId(), entry.getValue().getModId(), entry.getValue().getItemType()));
        }
        for (final Map.Entry<Integer, MapDifference.ValueDifference<ItemData>> entry2 : idDifferences.entriesDiffering().entrySet()) {
            final ItemData world = (ItemData)entry2.getValue().leftValue();
            final ItemData game = (ItemData)entry2.getValue().rightValue();
            this.mismatchedIds.add(String.format("ID %d is mismatched between world and game", world.getItemId()));
        }
        this.allowContinue = allowContinue;
    }
    
    public void a(final boolean choice, final int par2) {
        FMLClientHandler.instance().callbackIdDifferenceResponse(choice);
    }
    
    public void a(final int par1, final int par2, final float par3) {
        this.e();
        if (!this.allowContinue && this.i.size() == 2) {
            this.i.remove(0);
        }
        int offset = Math.max(85 - (this.missingIds.size() + this.mismatchedIds.size()) * 10, 30);
        this.a(this.o, "Forge Mod Loader has found ID mismatches", this.g / 2, 10, 16777215);
        this.a(this.o, "Complete details are in the log file", this.g / 2, 20, 16777215);
        int maxLines = 20;
        for (final String s : this.missingIds) {
            this.a(this.o, s, this.g / 2, offset, 15658734);
            offset += 10;
            if (--maxLines < 0) {
                break;
            }
            if (offset >= this.h - 30) {
                break;
            }
        }
        if (maxLines > 0 && offset < this.h - 30) {
            for (final String s : this.mismatchedIds) {
                this.a(this.o, s, this.g / 2, offset, 15658734);
                offset += 10;
                if (--maxLines < 0) {
                    break;
                }
                if (offset >= this.h - 30) {
                    break;
                }
            }
        }
        if (this.allowContinue) {
            this.a(this.o, "Do you wish to continue loading?", this.g / 2, this.h - 30, 16777215);
        }
        else {
            this.a(this.o, "You cannot connect to this server", this.g / 2, this.h - 30, 16777215);
        }
        for (int var4 = 0; var4 < this.i.size(); ++var4) {
            final aut var5 = this.i.get(var4);
            var5.e = this.h - 20;
            if (!this.allowContinue) {
                var5.d = this.g / 2 - 75;
                var5.f = bkb.a("gui.done");
            }
            var5.a(this.f, par1, par2);
        }
    }
}



================================================
FILE: cpw/mods/fml/client/GuiModList.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client;

import java.io.InputStream;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.awt.Dimension;
import javax.imageio.ImageIO;
import org.lwjgl.opengl.GL11;
import java.util.Iterator;
import com.google.common.base.Strings;
import cpw.mods.fml.common.Loader;
import java.util.ArrayList;
import cpw.mods.fml.common.ModContainer;

public class GuiModList extends awe
{
    private awe mainMenu;
    private GuiSlotModList modList;
    private int selected;
    private ModContainer selectedMod;
    private int listWidth;
    private ArrayList<ModContainer> mods;
    
    public GuiModList(final awe mainMenu) {
        this.selected = -1;
        this.mainMenu = mainMenu;
        this.mods = new ArrayList<ModContainer>();
        FMLClientHandler.instance().addSpecialModEntries(this.mods);
        for (final ModContainer mod : Loader.instance().getModList()) {
            if (mod.getMetadata() != null && mod.getMetadata().parentMod == null && !Strings.isNullOrEmpty(mod.getMetadata().parent)) {
                final String parentMod = mod.getMetadata().parent;
                final ModContainer parentContainer = Loader.instance().getIndexedModList().get(parentMod);
                if (parentContainer != null) {
                    mod.getMetadata().parentMod = parentContainer;
                    parentContainer.getMetadata().childMods.add(mod);
                    continue;
                }
            }
            else if (mod.getMetadata() != null && mod.getMetadata().parentMod != null) {
                continue;
            }
            this.mods.add(mod);
        }
    }
    
    public void A_() {
        for (final ModContainer mod : this.mods) {
            this.listWidth = Math.max(this.listWidth, this.getFontRenderer().a(mod.getName()) + 10);
            this.listWidth = Math.max(this.listWidth, this.getFontRenderer().a(mod.getVersion()) + 10);
        }
        this.listWidth = Math.min(this.listWidth, 150);
        this.i.add(new awl(6, this.g / 2 - 75, this.h - 38, bkb.a("gui.done")));
        (this.modList = new GuiSlotModList(this, this.mods, this.listWidth)).registerScrollButtons(this.i, 7, 8);
    }
    
    protected void a(final aut button) {
        if (button.h) {
            switch (button.g) {
                case 6: {
                    this.f.a(this.mainMenu);
                    return;
                }
            }
        }
        super.a(button);
    }
    
    public int drawLine(final String line, final int offset, final int shifty) {
        final int r = this.o.b(line, offset, shifty, 14151146);
        return shifty + 10;
    }
    
    public void a(final int p_571_1_, final int p_571_2_, final float p_571_3_) {
        this.modList.drawScreen(p_571_1_, p_571_2_, p_571_3_);
        this.a(this.o, "Mod List", this.g / 2, 16, 16777215);
        int offset = this.listWidth + 20;
        if (this.selectedMod != null) {
            GL11.glEnable(3042);
            if (!this.selectedMod.getMetadata().autogenerated) {
                int shifty = 35;
                final String logoFile = this.selectedMod.getMetadata().logoFile;
                if (!logoFile.isEmpty()) {
                    GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
                    final bim tm = this.f.J();
                    final bjr pack = FMLClientHandler.instance().getResourcePackFor(this.selectedMod.getModId());
                    try {
                        BufferedImage logo = null;
                        if (pack != null) {
                            logo = pack.a();
                        }
                        else {
                            final InputStream logoResource = this.getClass().getResourceAsStream(logoFile);
                            if (logoResource != null) {
                                logo = ImageIO.read(logoResource);
                            }
                        }
                        if (logo != null) {
                            final bjo rl = tm.a("modlogo", new bib(logo));
                            this.f.N.a(rl);
                            final Dimension dim = new Dimension(logo.getWidth(), logo.getHeight());
                            final double scaleX = dim.width / 200.0;
                            final double scaleY = dim.height / 65.0;
                            double scale = 1.0;
                            if (scaleX > 1.0 || scaleY > 1.0) {
                                scale = 1.0 / Math.max(scaleX, scaleY);
                            }
                            final Dimension dimension = dim;
                            dimension.width *= (int)scale;
                            final Dimension dimension2 = dim;
                            dimension2.height *= (int)scale;
                            final int top = 32;
                            final bfq tess = bfq.a;
                            tess.b();
                            tess.a((double)offset, (double)(top + dim.height), (double)this.n, 0.0, 1.0);
                            tess.a((double)(offset + dim.width), (double)(top + dim.height), (double)this.n, 1.0, 1.0);
                            tess.a((double)(offset + dim.width), (double)top, (double)this.n, 1.0, 0.0);
                            tess.a((double)offset, (double)top, (double)this.n, 0.0, 0.0);
                            tess.a();
                            shifty += 65;
                        }
                    }
                    catch (final IOException ex) {}
                }
                this.o.a(this.selectedMod.getMetadata().name, offset, shifty, 16777215);
                shifty += 12;
                shifty = this.drawLine(String.format("Version: %s (%s)", this.selectedMod.getDisplayVersion(), this.selectedMod.getVersion()), offset, shifty);
                shifty = this.drawLine(String.format("Mod ID: '%s' Mod State: %s", this.selectedMod.getModId(), Loader.instance().getModState(this.selectedMod)), offset, shifty);
                if (!this.selectedMod.getMetadata().credits.isEmpty()) {
                    shifty = this.drawLine(String.format("Credits: %s", this.selectedMod.getMetadata().credits), offset, shifty);
                }
                shifty = this.drawLine(String.format("Authors: %s", this.selectedMod.getMetadata().getAuthorList()), offset, shifty);
                shifty = this.drawLine(String.format("URL: %s", this.selectedMod.getMetadata().url), offset, shifty);
                shifty = this.drawLine(this.selectedMod.getMetadata().childMods.isEmpty() ? "No child mods for this mod" : String.format("Child mods: %s", this.selectedMod.getMetadata().getChildModList()), offset, shifty);
                final int rightSide = this.g - offset - 20;
                if (rightSide > 20) {
                    this.getFontRenderer().a(this.selectedMod.getMetadata().description, offset, shifty + 10, rightSide, 14540253);
                }
            }
            else {
                offset = (this.listWidth + this.g) / 2;
                this.a(this.o, this.selectedMod.getName(), offset, 35, 16777215);
                this.a(this.o, String.format("Version: %s", this.selectedMod.getVersion()), offset, 45, 16777215);
                this.a(this.o, String.format("Mod State: %s", Loader.instance().getModState(this.selectedMod)), offset, 55, 16777215);
                this.a(this.o, "No mod information found", offset, 65, 14540253);
                this.a(this.o, "Ask your mod author to provide a mod mcmod.info file", offset, 75, 14540253);
            }
            GL11.glDisable(3042);
        }
        super.a(p_571_1_, p_571_2_, p_571_3_);
    }
    
    atv getMinecraftInstance() {
        return this.f;
    }
    
    avi getFontRenderer() {
        return this.o;
    }
    
    public void selectModIndex(final int var1) {
        this.selected = var1;
        if (var1 >= 0 && var1 <= this.mods.size()) {
            this.selectedMod = this.mods.get(this.selected);
        }
        else {
            this.selectedMod = null;
        }
    }
    
    public boolean modIndexSelected(final int var1) {
        return var1 == this.selected;
    }
}



================================================
FILE: cpw/mods/fml/client/GuiModsMissing.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client;

import java.util.Iterator;
import cpw.mods.fml.common.versioning.DefaultArtifactVersion;
import cpw.mods.fml.common.versioning.ArtifactVersion;
import cpw.mods.fml.common.MissingModsException;

public class GuiModsMissing extends avh
{
    private MissingModsException modsMissing;
    
    public GuiModsMissing(final MissingModsException modsMissing) {
        super((String)null, (String)null);
        this.modsMissing = modsMissing;
    }
    
    public void A_() {
        super.A_();
    }
    
    public void a(final int par1, final int par2, final float par3) {
        this.e();
        int offset = Math.max(85 - this.modsMissing.missingMods.size() * 10, 10);
        this.a(this.o, "Forge Mod Loader has found a problem with your minecraft installation", this.g / 2, offset, 16777215);
        offset += 10;
        this.a(this.o, "The mods and versions listed below could not be found", this.g / 2, offset, 16777215);
        offset += 5;
        for (final ArtifactVersion v : this.modsMissing.missingMods) {
            offset += 10;
            if (v instanceof DefaultArtifactVersion) {
                final DefaultArtifactVersion dav = (DefaultArtifactVersion)v;
                if (dav.getRange() != null && dav.getRange().isUnboundedAbove()) {
                    this.a(this.o, String.format("%s : minimum version required is %s", v.getLabel(), dav.getRange().getLowerBoundString()), this.g / 2, offset, 15658734);
                    continue;
                }
            }
            this.a(this.o, String.format("%s : %s", v.getLabel(), v.getRangeString()), this.g / 2, offset, 15658734);
        }
        offset += 20;
        this.a(this.o, "The file 'ForgeModLoader-client-0.log' contains more information", this.g / 2, offset, 16777215);
    }
}



================================================
FILE: cpw/mods/fml/client/GuiModsMissingForServer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client;

import java.util.Iterator;
import cpw.mods.fml.common.versioning.ArtifactVersion;
import cpw.mods.fml.common.network.ModMissingPacket;

public class GuiModsMissingForServer extends awe
{
    private ModMissingPacket modsMissing;
    
    public GuiModsMissingForServer(final ModMissingPacket modsMissing) {
        this.modsMissing = modsMissing;
    }
    
    public void A_() {
        this.i.add(new awl(1, this.g / 2 - 75, this.h - 38, bkb.a("gui.done")));
    }
    
    protected void a(final aut par1GuiButton) {
        if (par1GuiButton.h && par1GuiButton.g == 1) {
            FMLClientHandler.instance().getClient().a((awe)null);
        }
    }
    
    public void a(final int par1, final int par2, final float par3) {
        this.e();
        int offset = Math.max(85 - this.modsMissing.getModList().size() * 10, 10);
        this.a(this.o, "Forge Mod Loader could not connect to this server", this.g / 2, offset, 16777215);
        offset += 10;
        this.a(this.o, "The mods and versions listed below could not be found", this.g / 2, offset, 16777215);
        offset += 10;
        this.a(this.o, "They are required to play on this server", this.g / 2, offset, 16777215);
        offset += 5;
        for (final ArtifactVersion v : this.modsMissing.getModList()) {
            offset += 10;
            this.a(this.o, String.format("%s : %s", v.getLabel(), v.getRangeString()), this.g / 2, offset, 15658734);
        }
        super.a(par1, par2, par3);
    }
}



================================================
FILE: cpw/mods/fml/client/GuiScrollingList.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client;

import org.lwjgl.opengl.GL11;
import org.lwjgl.input.Mouse;
import java.util.List;

public abstract class GuiScrollingList
{
    private final atv client;
    protected final int listWidth;
    protected final int listHeight;
    protected final int top;
    protected final int bottom;
    private final int right;
    protected final int left;
    protected final int slotHeight;
    private int scrollUpActionId;
    private int scrollDownActionId;
    protected int mouseX;
    protected int mouseY;
    private float initialMouseClickY;
    private float scrollFactor;
    private float scrollDistance;
    private int selectedIndex;
    private long lastClickTime;
    private boolean field_25123_p;
    private boolean field_27262_q;
    private int field_27261_r;
    
    public GuiScrollingList(final atv client, final int width, final int height, final int top, final int bottom, final int left, final int entryHeight) {
        this.initialMouseClickY = -2.0f;
        this.selectedIndex = -1;
        this.lastClickTime = 0L;
        this.field_25123_p = true;
        this.client = client;
        this.listWidth = width;
        this.listHeight = height;
        this.top = top;
        this.bottom = bottom;
        this.slotHeight = entryHeight;
        this.left = left;
        this.right = width + this.left;
    }
    
    public void func_27258_a(final boolean p_27258_1_) {
        this.field_25123_p = p_27258_1_;
    }
    
    protected void func_27259_a(final boolean p_27259_1_, final int p_27259_2_) {
        this.field_27262_q = p_27259_1_;
        this.field_27261_r = p_27259_2_;
        if (!p_27259_1_) {
            this.field_27261_r = 0;
        }
    }
    
    protected abstract int getSize();
    
    protected abstract void elementClicked(final int p0, final boolean p1);
    
    protected abstract boolean isSelected(final int p0);
    
    protected int getContentHeight() {
        return this.getSize() * this.slotHeight + this.field_27261_r;
    }
    
    protected abstract void drawBackground();
    
    protected abstract void drawSlot(final int p0, final int p1, final int p2, final int p3, final bfq p4);
    
    protected void func_27260_a(final int p_27260_1_, final int p_27260_2_, final bfq p_27260_3_) {
    }
    
    protected void func_27255_a(final int p_27255_1_, final int p_27255_2_) {
    }
    
    protected void func_27257_b(final int p_27257_1_, final int p_27257_2_) {
    }
    
    public int func_27256_c(final int p_27256_1_, final int p_27256_2_) {
        final int var3 = this.left + 1;
        final int var4 = this.left + this.listWidth - 7;
        final int var5 = p_27256_2_ - this.top - this.field_27261_r + (int)this.scrollDistance - 4;
        final int var6 = var5 / this.slotHeight;
        return (p_27256_1_ >= var3 && p_27256_1_ <= var4 && var6 >= 0 && var5 >= 0 && var6 < this.getSize()) ? var6 : -1;
    }
    
    public void registerScrollButtons(final List p_22240_1_, final int p_22240_2_, final int p_22240_3_) {
        this.scrollUpActionId = p_22240_2_;
        this.scrollDownActionId = p_22240_3_;
    }
    
    private void applyScrollLimits() {
        int var1 = this.getContentHeight() - (this.bottom - this.top - 4);
        if (var1 < 0) {
            var1 /= 2;
        }
        if (this.scrollDistance < 0.0f) {
            this.scrollDistance = 0.0f;
        }
        if (this.scrollDistance > var1) {
            this.scrollDistance = (float)var1;
        }
    }
    
    public void actionPerformed(final aut button) {
        if (button.h) {
            if (button.g == this.scrollUpActionId) {
                this.scrollDistance -= this.slotHeight * 2 / 3;
                this.initialMouseClickY = -2.0f;
                this.applyScrollLimits();
            }
            else if (button.g == this.scrollDownActionId) {
                this.scrollDistance += this.slotHeight * 2 / 3;
                this.initialMouseClickY = -2.0f;
                this.applyScrollLimits();
            }
        }
    }
    
    public void drawScreen(final int mouseX, final int mouseY, final float p_22243_3_) {
        this.mouseX = mouseX;
        this.mouseY = mouseY;
        this.drawBackground();
        final int listLength = this.getSize();
        final int scrollBarXStart = this.left + this.listWidth - 6;
        final int scrollBarXEnd = scrollBarXStart + 6;
        final int boxLeft = this.left;
        final int boxRight = scrollBarXStart - 1;
        if (Mouse.isButtonDown(0)) {
            if (this.initialMouseClickY == -1.0f) {
                boolean var7 = true;
                if (mouseY >= this.top && mouseY <= this.bottom) {
                    final int var8 = mouseY - this.top - this.field_27261_r + (int)this.scrollDistance - 4;
                    final int var9 = var8 / this.slotHeight;
                    if (mouseX >= boxLeft && mouseX <= boxRight && var9 >= 0 && var8 >= 0 && var9 < listLength) {
                        final boolean var10 = var9 == this.selectedIndex && System.currentTimeMillis() - this.lastClickTime < 250L;
                        this.elementClicked(var9, var10);
                        this.selectedIndex = var9;
                        this.lastClickTime = System.currentTimeMillis();
                    }
                    else if (mouseX >= boxLeft && mouseX <= boxRight && var8 < 0) {
                        this.func_27255_a(mouseX - boxLeft, mouseY - this.top + (int)this.scrollDistance - 4);
                        var7 = false;
                    }
                    if (mouseX >= scrollBarXStart && mouseX <= scrollBarXEnd) {
                        this.scrollFactor = -1.0f;
                        int var11 = this.getContentHeight() - (this.bottom - this.top - 4);
                        if (var11 < 1) {
                            var11 = 1;
                        }
                        int var12 = (int)((this.bottom - this.top) * (this.bottom - this.top) / (float)this.getContentHeight());
                        if (var12 < 32) {
                            var12 = 32;
                        }
                        if (var12 > this.bottom - this.top - 8) {
                            var12 = this.bottom - this.top - 8;
                        }
                        this.scrollFactor /= (this.bottom - this.top - var12) / (float)var11;
                    }
                    else {
                        this.scrollFactor = 1.0f;
                    }
                    if (var7) {
                        this.initialMouseClickY = (float)mouseY;
                    }
                    else {
                        this.initialMouseClickY = -2.0f;
                    }
                }
                else {
                    this.initialMouseClickY = -2.0f;
                }
            }
            else if (this.initialMouseClickY >= 0.0f) {
                this.scrollDistance -= (mouseY - this.initialMouseClickY) * this.scrollFactor;
                this.initialMouseClickY = (float)mouseY;
            }
        }
        else {
            while (Mouse.next()) {
                int var13 = Mouse.getEventDWheel();
                if (var13 != 0) {
                    if (var13 > 0) {
                        var13 = -1;
                    }
                    else if (var13 < 0) {
                        var13 = 1;
                    }
                    this.scrollDistance += var13 * this.slotHeight / 2;
                }
            }
            this.initialMouseClickY = -1.0f;
        }
        this.applyScrollLimits();
        GL11.glDisable(2896);
        GL11.glDisable(2912);
        final bfq var14 = bfq.a;
        this.client.N.a(avk.k);
        GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
        final float var15 = 32.0f;
        var14.b();
        var14.d(2105376);
        var14.a((double)this.left, (double)this.bottom, 0.0, (double)(this.left / var15), (double)((this.bottom + (int)this.scrollDistance) / var15));
        var14.a((double)this.right, (double)this.bottom, 0.0, (double)(this.right / var15), (double)((this.bottom + (int)this.scrollDistance) / var15));
        var14.a((double)this.right, (double)this.top, 0.0, (double)(this.right / var15), (double)((this.top + (int)this.scrollDistance) / var15));
        var14.a((double)this.left, (double)this.top, 0.0, (double)(this.left / var15), (double)((this.top + (int)this.scrollDistance) / var15));
        var14.a();
        final int var8 = this.top + 4 - (int)this.scrollDistance;
        if (this.field_27262_q) {
            this.func_27260_a(boxRight, var8, var14);
        }
        for (int var9 = 0; var9 < listLength; ++var9) {
            final int var11 = var8 + var9 * this.slotHeight + this.field_27261_r;
            final int var12 = this.slotHeight - 4;
            if (var11 <= this.bottom && var11 + var12 >= this.top) {
                if (this.field_25123_p && this.isSelected(var9)) {
                    final int var16 = boxLeft;
                    final int var17 = boxRight;
                    GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
                    GL11.glDisable(3553);
                    var14.b();
                    var14.d(8421504);
                    var14.a((double)var16, (double)(var11 + var12 + 2), 0.0, 0.0, 1.0);
                    var14.a((double)var17, (double)(var11 + var12 + 2), 0.0, 1.0, 1.0);
                    var14.a((double)var17, (double)(var11 - 2), 0.0, 1.0, 0.0);
                    var14.a((double)var16, (double)(var11 - 2), 0.0, 0.0, 0.0);
                    var14.d(0);
                    var14.a((double)(var16 + 1), (double)(var11 + var12 + 1), 0.0, 0.0, 1.0);
                    var14.a((double)(var17 - 1), (double)(var11 + var12 + 1), 0.0, 1.0, 1.0);
                    var14.a((double)(var17 - 1), (double)(var11 - 1), 0.0, 1.0, 0.0);
                    var14.a((double)(var16 + 1), (double)(var11 - 1), 0.0, 0.0, 0.0);
                    var14.a();
                    GL11.glEnable(3553);
                }
                this.drawSlot(var9, boxRight, var11, var12, var14);
            }
        }
        GL11.glDisable(2929);
        final byte var18 = 4;
        this.overlayBackground(0, this.top, 255, 255);
        this.overlayBackground(this.bottom, this.listHeight, 255, 255);
        GL11.glEnable(3042);
        GL11.glBlendFunc(770, 771);
        GL11.glDisable(3008);
        GL11.glShadeModel(7425);
        GL11.glDisable(3553);
        var14.b();
        var14.a(0, 0);
        var14.a((double)this.left, (double)(this.top + var18), 0.0, 0.0, 1.0);
        var14.a((double)this.right, (double)(this.top + var18), 0.0, 1.0, 1.0);
        var14.a(0, 255);
        var14.a((double)this.right, (double)this.top, 0.0, 1.0, 0.0);
        var14.a((double)this.left, (double)this.top, 0.0, 0.0, 0.0);
        var14.a();
        var14.b();
        var14.a(0, 255);
        var14.a((double)this.left, (double)this.bottom, 0.0, 0.0, 1.0);
        var14.a((double)this.right, (double)this.bottom, 0.0, 1.0, 1.0);
        var14.a(0, 0);
        var14.a((double)this.right, (double)(this.bottom - var18), 0.0, 1.0, 0.0);
        var14.a((double)this.left, (double)(this.bottom - var18), 0.0, 0.0, 0.0);
        var14.a();
        int var11 = this.getContentHeight() - (this.bottom - this.top - 4);
        if (var11 > 0) {
            int var12 = (this.bottom - this.top) * (this.bottom - this.top) / this.getContentHeight();
            if (var12 < 32) {
                var12 = 32;
            }
            if (var12 > this.bottom - this.top - 8) {
                var12 = this.bottom - this.top - 8;
            }
            int var16 = (int)this.scrollDistance * (this.bottom - this.top - var12) / var11 + this.top;
            if (var16 < this.top) {
                var16 = this.top;
            }
            var14.b();
            var14.a(0, 255);
            var14.a((double)scrollBarXStart, (double)this.bottom, 0.0, 0.0, 1.0);
            var14.a((double)scrollBarXEnd, (double)this.bottom, 0.0, 1.0, 1.0);
            var14.a((double)scrollBarXEnd, (double)this.top, 0.0, 1.0, 0.0);
            var14.a((double)scrollBarXStart, (double)this.top, 0.0, 0.0, 0.0);
            var14.a();
            var14.b();
            var14.a(8421504, 255);
            var14.a((double)scrollBarXStart, (double)(var16 + var12), 0.0, 0.0, 1.0);
            var14.a((double)scrollBarXEnd, (double)(var16 + var12), 0.0, 1.0, 1.0);
            var14.a((double)scrollBarXEnd, (double)var16, 0.0, 1.0, 0.0);
            var14.a((double)scrollBarXStart, (double)var16, 0.0, 0.0, 0.0);
            var14.a();
            var14.b();
            var14.a(12632256, 255);
            var14.a((double)scrollBarXStart, (double)(var16 + var12 - 1), 0.0, 0.0, 1.0);
            var14.a((double)(scrollBarXEnd - 1), (double)(var16 + var12 - 1), 0.0, 1.0, 1.0);
            var14.a((double)(scrollBarXEnd - 1), (double)var16, 0.0, 1.0, 0.0);
            var14.a((double)scrollBarXStart, (double)var16, 0.0, 0.0, 0.0);
            var14.a();
        }
        this.func_27257_b(mouseX, mouseY);
        GL11.glEnable(3553);
        GL11.glShadeModel(7424);
        GL11.glEnable(3008);
        GL11.glDisable(3042);
    }
    
    private void overlayBackground(final int p_22239_1_, final int p_22239_2_, final int p_22239_3_, final int p_22239_4_) {
        final bfq var5 = bfq.a;
        this.client.N.a(avk.k);
        GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
        final float var6 = 32.0f;
        var5.b();
        var5.a(4210752, p_22239_4_);
        var5.a(0.0, (double)p_22239_2_, 0.0, 0.0, (double)(p_22239_2_ / var6));
        var5.a(this.listWidth + 30.0, (double)p_22239_2_, 0.0, (double)((this.listWidth + 30) / var6), (double)(p_22239_2_ / var6));
        var5.a(4210752, p_22239_3_);
        var5.a(this.listWidth + 30.0, (double)p_22239_1_, 0.0, (double)((this.listWidth + 30) / var6), (double)(p_22239_1_ / var6));
        var5.a(0.0, (double)p_22239_1_, 0.0, 0.0, (double)(p_22239_1_ / var6));
        var5.a();
    }
}



================================================
FILE: cpw/mods/fml/client/GuiSlotModList.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client;

import cpw.mods.fml.common.LoaderState;
import cpw.mods.fml.common.Loader;
import cpw.mods.fml.common.ModContainer;
import java.util.ArrayList;

public class GuiSlotModList extends GuiScrollingList
{
    private GuiModList parent;
    private ArrayList<ModContainer> mods;
    
    public GuiSlotModList(final GuiModList parent, final ArrayList<ModContainer> mods, final int listWidth) {
        super(parent.getMinecraftInstance(), listWidth, parent.h, 32, parent.h - 65 + 4, 10, 35);
        this.parent = parent;
        this.mods = mods;
    }
    
    @Override
    protected int getSize() {
        return this.mods.size();
    }
    
    @Override
    protected void elementClicked(final int var1, final boolean var2) {
        this.parent.selectModIndex(var1);
    }
    
    @Override
    protected boolean isSelected(final int var1) {
        return this.parent.modIndexSelected(var1);
    }
    
    @Override
    protected void drawBackground() {
        this.parent.e();
    }
    
    @Override
    protected int getContentHeight() {
        return this.getSize() * 35 + 1;
    }
    
    @Override
    protected void drawSlot(final int listIndex, final int var2, final int var3, final int var4, final bfq var5) {
        final ModContainer mc = this.mods.get(listIndex);
        if (Loader.instance().getModState(mc) == LoaderState.ModState.DISABLED) {
            this.parent.getFontRenderer().b(this.parent.getFontRenderer().a(mc.getName(), this.listWidth - 10), this.left + 3, var3 + 2, 16720418);
            this.parent.getFontRenderer().b(this.parent.getFontRenderer().a(mc.getDisplayVersion(), this.listWidth - 10), this.left + 3, var3 + 12, 16720418);
            this.parent.getFontRenderer().b(this.parent.getFontRenderer().a("DISABLED", this.listWidth - 10), this.left + 3, var3 + 22, 16720418);
        }
        else {
            this.parent.getFontRenderer().b(this.parent.getFontRenderer().a(mc.getName(), this.listWidth - 10), this.left + 3, var3 + 2, 16777215);
            this.parent.getFontRenderer().b(this.parent.getFontRenderer().a(mc.getDisplayVersion(), this.listWidth - 10), this.left + 3, var3 + 12, 13421772);
            this.parent.getFontRenderer().b(this.parent.getFontRenderer().a((mc.getMetadata() != null) ? mc.getMetadata().getChildModCountString() : "Metadata not found", this.listWidth - 10), this.left + 3, var3 + 22, 13421772);
        }
    }
}



================================================
FILE: cpw/mods/fml/client/GuiSortingProblem.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client;

import java.util.Iterator;
import cpw.mods.fml.common.ModContainer;
import cpw.mods.fml.common.toposort.ModSortingException;

public class GuiSortingProblem extends awe
{
    private ModSortingException modSorting;
    private ModSortingException.SortingExceptionData<ModContainer> failedList;
    
    public GuiSortingProblem(final ModSortingException modSorting) {
        this.modSorting = modSorting;
        this.failedList = modSorting.getExceptionData();
    }
    
    public void A_() {
        super.A_();
    }
    
    public void a(final int par1, final int par2, final float par3) {
        this.e();
        int offset = Math.max(85 - (this.failedList.getVisitedNodes().size() + 3) * 10, 10);
        this.a(this.o, "Forge Mod Loader has found a problem with your minecraft installation", this.g / 2, offset, 16777215);
        offset += 10;
        this.a(this.o, "A mod sorting cycle was detected and loading cannot continue", this.g / 2, offset, 16777215);
        offset += 10;
        this.a(this.o, String.format("The first mod in the cycle is %s", this.failedList.getFirstBadNode()), this.g / 2, offset, 16777215);
        offset += 10;
        this.a(this.o, "The remainder of the cycle involves these mods", this.g / 2, offset, 16777215);
        offset += 5;
        for (final ModContainer mc : this.failedList.getVisitedNodes()) {
            offset += 10;
            this.a(this.o, String.format("%s : before: %s, after: %s", mc.toString(), mc.getDependants(), mc.getDependencies()), this.g / 2, offset, 15658734);
        }
        offset += 20;
        this.a(this.o, "The file 'ForgeModLoader-client-0.log' contains more information", this.g / 2, offset, 16777215);
    }
}



================================================
FILE: cpw/mods/fml/client/GuiWrongMinecraft.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client;

import cpw.mods.fml.common.Loader;
import cpw.mods.fml.common.WrongMinecraftVersionException;

public class GuiWrongMinecraft extends avh
{
    private WrongMinecraftVersionException wrongMC;
    
    public GuiWrongMinecraft(final WrongMinecraftVersionException wrongMC) {
        super((String)null, (String)null);
        this.wrongMC = wrongMC;
    }
    
    public void A_() {
        super.A_();
    }
    
    public void a(final int par1, final int par2, final float par3) {
        this.e();
        int offset = 75;
        this.a(this.o, "Forge Mod Loader has found a problem with your minecraft installation", this.g / 2, offset, 16777215);
        offset += 10;
        this.a(this.o, String.format("The mod listed below does not want to run in Minecraft version %s", Loader.instance().getMinecraftModContainer().getVersion()), this.g / 2, offset, 16777215);
        offset += 5;
        offset += 10;
        this.a(this.o, String.format("%s (%s) wants Minecraft %s", this.wrongMC.mod.getName(), this.wrongMC.mod.getModId(), this.wrongMC.mod.acceptableMinecraftVersionRange()), this.g / 2, offset, 15658734);
        offset += 20;
        this.a(this.o, "The file 'ForgeModLoader-client-0.log' contains more information", this.g / 2, offset, 16777215);
    }
}



================================================
FILE: cpw/mods/fml/client/TextureFXManager.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client;

import java.awt.Dimension;
import java.awt.image.BufferedImage;
import com.google.common.collect.Maps;
import java.util.Map;

public class TextureFXManager
{
    private static final TextureFXManager INSTANCE;
    private atv client;
    private Map<Integer, TextureHolder> texturesById;
    private Map<String, TextureHolder> texturesByName;
    
    public TextureFXManager() {
        this.texturesById = Maps.newHashMap();
        this.texturesByName = Maps.newHashMap();
    }
    
    void setClient(final atv client) {
        this.client = client;
    }
    
    public static TextureFXManager instance() {
        return TextureFXManager.INSTANCE;
    }
    
    public void fixTransparency(final BufferedImage loadedImage, final String textureName) {
        if (textureName.matches("^/mob/.*_eyes.*.png$")) {
            for (int x = 0; x < loadedImage.getWidth(); ++x) {
                for (int y = 0; y < loadedImage.getHeight(); ++y) {
                    final int argb = loadedImage.getRGB(x, y);
                    if ((argb & 0xFF000000) == 0x0 && argb != 0) {
                        loadedImage.setRGB(x, y, 0);
                    }
                }
            }
        }
    }
    
    public void bindTextureToName(final String name, final int index) {
        final TextureHolder holder = new TextureHolder();
        holder.textureId = index;
        holder.textureName = name;
        this.texturesById.put(index, holder);
        this.texturesByName.put(name, holder);
    }
    
    public void setTextureDimensions(final int index, final int j, final int k) {
        final TextureHolder holder = this.texturesById.get(index);
        if (holder == null) {
            return;
        }
        holder.x = j;
        holder.y = k;
    }
    
    public Dimension getTextureDimensions(final String texture) {
        return this.texturesByName.containsKey(texture) ? new Dimension(this.texturesByName.get(texture).x, this.texturesByName.get(texture).y) : new Dimension(1, 1);
    }
    
    static {
        INSTANCE = new TextureFXManager();
    }
    
    private class TextureHolder
    {
        private int textureId;
        private String textureName;
        private int x;
        private int y;
    }
}



================================================
FILE: cpw/mods/fml/client/modloader/ModLoaderBlockRendererHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client.modloader;

import cpw.mods.fml.client.registry.ISimpleBlockRenderingHandler;

public class ModLoaderBlockRendererHandler implements ISimpleBlockRenderingHandler
{
    private int renderId;
    private boolean render3dInInventory;
    private BaseMod mod;
    
    public ModLoaderBlockRendererHandler(final int renderId, final boolean render3dInInventory, final BaseMod mod) {
        this.renderId = renderId;
        this.render3dInInventory = render3dInInventory;
        this.mod = mod;
    }
    
    @Override
    public int getRenderId() {
        return this.renderId;
    }
    
    @Override
    public boolean shouldRender3DInInventory() {
        return this.render3dInInventory;
    }
    
    @Override
    public boolean renderWorldBlock(final acf world, final int x, final int y, final int z, final aqz block, final int modelId, final bfr renderer) {
        return this.mod.renderWorldBlock(renderer, world, x, y, z, block, modelId);
    }
    
    @Override
    public void renderInventoryBlock(final aqz block, final int metadata, final int modelID, final bfr renderer) {
        this.mod.renderInvBlock(renderer, block, metadata, modelID);
    }
}



================================================
FILE: cpw/mods/fml/client/modloader/ModLoaderClientHelper.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client.modloader;

import cpw.mods.fml.common.registry.EntityRegistry;
import cpw.mods.fml.common.network.EntitySpawnPacket;
import cpw.mods.fml.client.registry.KeyBindingRegistry;
import com.google.common.collect.Iterables;
import cpw.mods.fml.common.Loader;
import cpw.mods.fml.common.modloader.BaseModProxy;
import com.google.common.collect.Multimaps;
import java.util.Collections;
import java.util.Collection;
import com.google.common.base.Supplier;
import cpw.mods.fml.common.modloader.ModLoaderHelper;
import com.google.common.collect.MapMaker;
import java.util.Iterator;
import com.google.common.collect.MapDifference;
import com.google.common.base.Equivalence;
import com.google.common.collect.Maps;
import cpw.mods.fml.common.FMLLog;
import java.util.logging.Level;
import cpw.mods.fml.client.registry.ISimpleBlockRenderingHandler;
import cpw.mods.fml.client.registry.RenderingRegistry;
import java.util.Map;
import cpw.mods.fml.common.modloader.ModLoaderModContainer;
import com.google.common.collect.Multimap;
import cpw.mods.fml.common.modloader.IModLoaderSidedHelper;

public class ModLoaderClientHelper implements IModLoaderSidedHelper
{
    private atv client;
    private static Multimap<ModLoaderModContainer, ModLoaderKeyBindingHandler> keyBindingContainers;
    private Map<cm, ez> managerLookups;
    
    public static int obtainBlockModelIdFor(final BaseMod mod, final boolean inventoryRenderer) {
        final int renderId = RenderingRegistry.getNextAvailableRenderId();
        final ModLoaderBlockRendererHandler bri = new ModLoaderBlockRendererHandler(renderId, inventoryRenderer, mod);
        RenderingRegistry.registerBlockHandler(bri);
        return renderId;
    }
    
    public static void handleFinishLoadingFor(final ModLoaderModContainer mc, final atv game) {
        FMLLog.log(mc.getModId(), Level.FINE, "Handling post startup activities for ModLoader mod %s", mc.getModId());
        final BaseMod mod = (BaseMod)mc.getMod();
        final Map<Class<? extends nn>, bgm> renderers = Maps.newHashMap(bgl.a.q);
        try {
            FMLLog.log(mc.getModId(), Level.FINEST, "Requesting renderers from basemod %s", mc.getModId());
            mod.addRenderer(renderers);
            FMLLog.log(mc.getModId(), Level.FINEST, "Received %d renderers from basemod %s", renderers.size(), mc.getModId());
        }
        catch (final Exception e) {
            FMLLog.log(mc.getModId(), Level.SEVERE, e, "A severe problem was detected with the mod %s during the addRenderer call. Continuing, but expect odd results", mc.getModId());
        }
        final MapDifference<Class<? extends nn>, bgm> difference = (MapDifference<Class<? extends nn>, bgm>)Maps.difference(bgl.a.q, (Map)renderers, Equivalence.identity());
        for (final Map.Entry<Class<? extends nn>, bgm> e2 : difference.entriesOnlyOnLeft().entrySet()) {
            FMLLog.log(mc.getModId(), Level.WARNING, "The mod %s attempted to remove an entity renderer %s from the entity map. This will be ignored.", mc.getModId(), e2.getKey().getName());
        }
        for (final Map.Entry<Class<? extends nn>, bgm> e2 : difference.entriesOnlyOnRight().entrySet()) {
            FMLLog.log(mc.getModId(), Level.FINEST, "Registering ModLoader entity renderer %s as instance of %s", e2.getKey().getName(), e2.getValue().getClass().getName());
            RenderingRegistry.registerEntityRenderingHandler(e2.getKey(), e2.getValue());
        }
        for (final Map.Entry<Class<? extends nn>, MapDifference.ValueDifference<bgm>> e3 : difference.entriesDiffering().entrySet()) {
            FMLLog.log(mc.getModId(), Level.FINEST, "Registering ModLoader entity rendering override for %s as instance of %s", e3.getKey().getName(), e3.getValue().rightValue().getClass().getName());
            RenderingRegistry.registerEntityRenderingHandler(e3.getKey(), (bgm)e3.getValue().rightValue());
        }
        try {
            mod.registerAnimation(game);
        }
        catch (final Exception e4) {
            FMLLog.log(mc.getModId(), Level.SEVERE, e4, "A severe problem was detected with the mod %s during the registerAnimation call. Continuing, but expect odd results", mc.getModId());
        }
    }
    
    public ModLoaderClientHelper(final atv client) {
        this.managerLookups = new MapMaker().weakKeys().weakValues().makeMap();
        this.client = client;
        ModLoaderHelper.sidedHelper = this;
        ModLoaderClientHelper.keyBindingContainers = (Multimap<ModLoaderModContainer, ModLoaderKeyBindingHandler>)Multimaps.newMultimap((Map)Maps.newHashMap(), (Supplier)new Supplier<Collection<ModLoaderKeyBindingHandler>>() {
            public Collection<ModLoaderKeyBindingHandler> get() {
                return Collections.singleton(new ModLoaderKeyBindingHandler());
            }
        });
    }
    
    @Override
    public void finishModLoading(final ModLoaderModContainer mc) {
        handleFinishLoadingFor(mc, this.client);
    }
    
    public static void registerKeyBinding(final BaseModProxy mod, final ats keyHandler, final boolean allowRepeat) {
        final ModLoaderModContainer mlmc = (ModLoaderModContainer)Loader.instance().activeModContainer();
        final ModLoaderKeyBindingHandler handler = (ModLoaderKeyBindingHandler)Iterables.getOnlyElement((Iterable)ModLoaderClientHelper.keyBindingContainers.get((Object)mlmc));
        handler.setModContainer(mlmc);
        handler.addKeyBinding(keyHandler, allowRepeat);
        KeyBindingRegistry.registerKeyBinding(handler);
    }
    
    @Override
    public Object getClientGui(final BaseModProxy mod, final uf player, final int ID, final int x, final int y, final int z) {
        return ((BaseMod)mod).getContainerGUI((bdi)player, ID, x, y, z);
    }
    
    @Override
    public nn spawnEntity(final BaseModProxy mod, final EntitySpawnPacket input, final EntityRegistry.EntityRegistration er) {
        return ((BaseMod)mod).spawnEntity(er.getModEntityId(), (abw)this.client.f, input.scaledX, input.scaledY, input.scaledZ);
    }
    
    @Override
    public void sendClientPacket(final BaseModProxy mod, final ea packet) {
        ((BaseMod)mod).clientCustomPayload(this.client.h.a, packet);
    }
    
    @Override
    public void clientConnectionOpened(final ez netClientHandler, final cm manager, final BaseModProxy mod) {
        this.managerLookups.put(manager, netClientHandler);
        ((BaseMod)mod).clientConnect((bcw)netClientHandler);
    }
    
    @Override
    public boolean clientConnectionClosed(final cm manager, final BaseModProxy mod) {
        if (this.managerLookups.containsKey(manager)) {
            ((BaseMod)mod).clientDisconnect((bcw)this.managerLookups.get(manager));
            return true;
        }
        return false;
    }
}



================================================
FILE: cpw/mods/fml/client/modloader/ModLoaderKeyBindingHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client.modloader;

import com.google.common.primitives.Booleans;
import java.util.Arrays;
import com.google.common.collect.ObjectArrays;
import cpw.mods.fml.common.TickType;
import java.util.EnumSet;
import java.util.List;
import cpw.mods.fml.common.modloader.ModLoaderModContainer;
import cpw.mods.fml.client.registry.KeyBindingRegistry;

public class ModLoaderKeyBindingHandler extends KeyBindingRegistry.KeyHandler
{
    private ModLoaderModContainer modContainer;
    private List<ats> helper;
    private boolean[] active;
    private boolean[] mlRepeats;
    private boolean[] armed;
    
    public ModLoaderKeyBindingHandler() {
        super(new ats[0], new boolean[0]);
        this.active = new boolean[0];
        this.mlRepeats = new boolean[0];
        this.armed = new boolean[0];
    }
    
    void setModContainer(final ModLoaderModContainer modContainer) {
        this.modContainer = modContainer;
    }
    
    public void fireKeyEvent(final ats kb) {
        ((BaseMod)this.modContainer.getMod()).keyboardEvent(kb);
    }
    
    @Override
    public void keyDown(final EnumSet<TickType> type, final ats kb, final boolean end, final boolean repeats) {
        if (!end) {
            return;
        }
        final int idx = this.helper.indexOf(kb);
        if (type.contains(TickType.CLIENT)) {
            this.armed[idx] = true;
        }
        if (this.armed[idx] && type.contains(TickType.RENDER) && (!this.active[idx] || this.mlRepeats[idx])) {
            this.fireKeyEvent(kb);
            this.active[idx] = true;
            this.armed[idx] = false;
        }
    }
    
    @Override
    public void keyUp(final EnumSet<TickType> type, final ats kb, final boolean end) {
        if (!end) {
            return;
        }
        final int idx = this.helper.indexOf(kb);
        this.active[idx] = false;
    }
    
    @Override
    public EnumSet<TickType> ticks() {
        return EnumSet.of(TickType.CLIENT, TickType.RENDER);
    }
    
    @Override
    public String getLabel() {
        return this.modContainer.getModId() + " KB " + this.keyBindings[0].d;
    }
    
    void addKeyBinding(final ats binding, final boolean repeats) {
        this.keyBindings = (ats[])ObjectArrays.concat((Object[])this.keyBindings, (Object)binding);
        Arrays.fill(this.repeatings = new boolean[this.keyBindings.length], true);
        this.active = new boolean[this.keyBindings.length];
        this.armed = new boolean[this.keyBindings.length];
        this.mlRepeats = Booleans.concat(new boolean[][] { this.mlRepeats, { repeats } });
        this.keyDown = new boolean[this.keyBindings.length];
        this.helper = Arrays.asList(this.keyBindings);
    }
}



================================================
FILE: cpw/mods/fml/client/registry/ClientRegistry.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client.registry;

import cpw.mods.fml.common.registry.GameRegistry;

public class ClientRegistry
{
    public static void registerTileEntity(final Class<? extends asp> tileEntityClass, final String id, final bje specialRenderer) {
        GameRegistry.registerTileEntity(tileEntityClass, id);
        bindTileEntitySpecialRenderer(tileEntityClass, specialRenderer);
    }
    
    public static void bindTileEntitySpecialRenderer(final Class<? extends asp> tileEntityClass, final bje specialRenderer) {
        bjd.a.m.put(tileEntityClass, specialRenderer);
        specialRenderer.a(bjd.a);
    }
}



================================================
FILE: cpw/mods/fml/client/registry/ISimpleBlockRenderingHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client.registry;

public interface ISimpleBlockRenderingHandler
{
    void renderInventoryBlock(final aqz p0, final int p1, final int p2, final bfr p3);
    
    boolean renderWorldBlock(final acf p0, final int p1, final int p2, final int p3, final aqz p4, final int p5, final bfr p6);
    
    boolean shouldRender3DInInventory();
    
    int getRenderId();
}



================================================
FILE: cpw/mods/fml/client/registry/KeyBindingRegistry.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client.registry;

import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;
import cpw.mods.fml.common.TickType;
import java.util.EnumSet;
import java.util.Iterator;
import java.util.ArrayList;
import com.google.common.collect.Lists;
import cpw.mods.fml.common.ITickHandler;
import cpw.mods.fml.common.registry.TickRegistry;
import cpw.mods.fml.relauncher.Side;
import com.google.common.collect.Sets;
import java.util.Set;

public class KeyBindingRegistry
{
    private static final KeyBindingRegistry INSTANCE;
    private Set<KeyHandler> keyHandlers;
    
    public KeyBindingRegistry() {
        this.keyHandlers = Sets.newLinkedHashSet();
    }
    
    public static void registerKeyBinding(final KeyHandler handler) {
        instance().keyHandlers.add(handler);
        if (!handler.isDummy) {
            TickRegistry.registerTickHandler(handler, Side.CLIENT);
        }
    }
    
    @Deprecated
    public static KeyBindingRegistry instance() {
        return KeyBindingRegistry.INSTANCE;
    }
    
    public void uploadKeyBindingsToGame(final aul settings) {
        final ArrayList<ats> harvestedBindings = Lists.newArrayList();
        for (final KeyHandler key : this.keyHandlers) {
            for (final ats kb : key.keyBindings) {
                harvestedBindings.add(kb);
            }
        }
        final ats[] modKeyBindings = harvestedBindings.toArray(new ats[harvestedBindings.size()]);
        final ats[] allKeys = new ats[settings.W.length + modKeyBindings.length];
        System.arraycopy(settings.W, 0, allKeys, 0, settings.W.length);
        System.arraycopy(modKeyBindings, 0, allKeys, settings.W.length, modKeyBindings.length);
        settings.W = allKeys;
        settings.a();
    }
    
    static {
        INSTANCE = new KeyBindingRegistry();
    }
    
    public abstract static class KeyHandler implements ITickHandler
    {
        protected ats[] keyBindings;
        protected boolean[] keyDown;
        protected boolean[] repeatings;
        private boolean isDummy;
        
        public KeyHandler(final ats[] keyBindings, final boolean[] repeatings) {
            assert keyBindings.length == repeatings.length : "You need to pass two arrays of identical length";
            this.keyBindings = keyBindings;
            this.repeatings = repeatings;
            this.keyDown = new boolean[keyBindings.length];
        }
        
        public KeyHandler(final ats[] keyBindings) {
            this.keyBindings = keyBindings;
            this.isDummy = true;
        }
        
        public ats[] getKeyBindings() {
            return this.keyBindings;
        }
        
        @Override
        public final void tickStart(final EnumSet<TickType> type, final Object... tickData) {
            this.keyTick(type, false);
        }
        
        @Override
        public final void tickEnd(final EnumSet<TickType> type, final Object... tickData) {
            this.keyTick(type, true);
        }
        
        private void keyTick(final EnumSet<TickType> type, final boolean tickEnd) {
            for (int i = 0; i < this.keyBindings.length; ++i) {
                final ats keyBinding = this.keyBindings[i];
                final int keyCode = keyBinding.d;
                final boolean state = (keyCode < 0) ? Mouse.isButtonDown(keyCode + 100) : Keyboard.isKeyDown(keyCode);
                if (state != this.keyDown[i] || (state && this.repeatings[i])) {
                    if (state) {
                        this.keyDown(type, keyBinding, tickEnd, state != this.keyDown[i]);
                    }
                    else {
                        this.keyUp(type, keyBinding, tickEnd);
                    }
                    if (tickEnd) {
                        this.keyDown[i] = state;
                    }
                }
            }
        }
        
        public abstract void keyDown(final EnumSet<TickType> p0, final ats p1, final boolean p2, final boolean p3);
        
        public abstract void keyUp(final EnumSet<TickType> p0, final ats p1, final boolean p2);
        
        @Override
        public abstract EnumSet<TickType> ticks();
    }
}



================================================
FILE: cpw/mods/fml/client/registry/RenderingRegistry.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.client.registry;

import java.util.Iterator;
import com.google.common.collect.ObjectArrays;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import java.util.List;
import java.util.Map;

public class RenderingRegistry
{
    private static final RenderingRegistry INSTANCE;
    private int nextRenderId;
    private Map<Integer, ISimpleBlockRenderingHandler> blockRenderers;
    private List<EntityRendererInfo> entityRenderers;
    
    public RenderingRegistry() {
        this.nextRenderId = 40;
        this.blockRenderers = Maps.newHashMap();
        this.entityRenderers = Lists.newArrayList();
    }
    
    public static int addNewArmourRendererPrefix(final String armor) {
        bgu.l = (String[])ObjectArrays.concat((Object[])bgu.l, (Object)armor);
        return bgu.l.length - 1;
    }
    
    public static void registerEntityRenderingHandler(final Class<? extends nn> entityClass, final bgm renderer) {
        instance().entityRenderers.add(new EntityRendererInfo(entityClass, renderer));
    }
    
    public static void registerBlockHandler(final ISimpleBlockRenderingHandler handler) {
        instance().blockRenderers.put(handler.getRenderId(), handler);
    }
    
    public static void registerBlockHandler(final int renderId, final ISimpleBlockRenderingHandler handler) {
        instance().blockRenderers.put(renderId, handler);
    }
    
    public static int getNextAvailableRenderId() {
        return instance().nextRenderId++;
    }
    
    @Deprecated
    public static int addTextureOverride(final String fileToOverride, final String fileToAdd) {
        return -1;
    }
    
    public static void addTextureOverride(final String path, final String overlayPath, final int index) {
    }
    
    @Deprecated
    public static int getUniqueTextureIndex(final String path) {
        return -1;
    }
    
    @Deprecated
    public static RenderingRegistry instance() {
        return RenderingRegistry.INSTANCE;
    }
    
    public boolean renderWorldBlock(final bfr renderer, final acf world, final int x, final int y, final int z, final aqz block, final int modelId) {
        if (!this.blockRenderers.containsKey(modelId)) {
            return false;
        }
        final ISimpleBlockRenderingHandler bri = this.blockRenderers.get(modelId);
        return bri.renderWorldBlock(world, x, y, z, block, modelId, renderer);
    }
    
    public void renderInventoryBlock(final bfr renderer, final aqz block, final int metadata, final int modelID) {
        if (!this.blockRenderers.containsKey(modelID)) {
            return;
        }
        final ISimpleBlockRenderingHandler bri = this.blockRenderers.get(modelID);
        bri.renderInventoryBlock(block, metadata, modelID, renderer);
    }
    
    public boolean renderItemAsFull3DBlock(final int modelId) {
        final ISimpleBlockRenderingHandler bri = this.blockRenderers.get(modelId);
        return bri != null && bri.shouldRender3DInInventory();
    }
    
    public void loadEntityRenderers(final Map<Class<? extends nn>, bgm> rendererMap) {
        for (final EntityRendererInfo info : this.entityRenderers) {
            rendererMap.put(info.target, info.renderer);
            info.renderer.a(bgl.a);
        }
    }
    
    static {
        INSTANCE = new RenderingRegistry();
    }
    
    private static class EntityRendererInfo
    {
        private Class<? extends nn> target;
        private bgm renderer;
        
        public EntityRendererInfo(final Class<? extends nn> target, final bgm renderer) {
            this.target = target;
            this.renderer = renderer;
        }
    }
}



================================================
FILE: cpw/mods/fml/common/API.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Retention;

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.PACKAGE })
public @interface API {
    String owner();
    
    String provides();
    
    String apiVersion();
}



================================================
FILE: cpw/mods/fml/common/BukkitPluginRef.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Retention;

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD })
public @interface BukkitPluginRef {
    String value();
}



================================================
FILE: cpw/mods/fml/common/BukkitProxy.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

public interface BukkitProxy
{
}



================================================
FILE: cpw/mods/fml/common/CertificateHelper.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.nio.ByteBuffer;
import java.security.MessageDigest;
import java.security.cert.Certificate;

public class CertificateHelper
{
    private static final String HEXES = "0123456789abcdef";
    
    public static String getFingerprint(final Certificate certificate) {
        if (certificate == null) {
            return "NO VALID CERTIFICATE FOUND";
        }
        try {
            final MessageDigest md = MessageDigest.getInstance("SHA-1");
            final byte[] der = certificate.getEncoded();
            md.update(der);
            final byte[] digest = md.digest();
            return hexify(digest);
        }
        catch (final Exception e) {
            return null;
        }
    }
    
    public static String getFingerprint(final ByteBuffer buffer) {
        try {
            final MessageDigest digest = MessageDigest.getInstance("SHA-1");
            digest.update(buffer);
            final byte[] chksum = digest.digest();
            return hexify(chksum);
        }
        catch (final Exception e) {
            return null;
        }
    }
    
    private static String hexify(final byte[] chksum) {
        final StringBuilder hex = new StringBuilder(2 * chksum.length);
        for (final byte b : chksum) {
            hex.append("0123456789abcdef".charAt((b & 0xF0) >> 4)).append("0123456789abcdef".charAt(b & 0xF));
        }
        return hex.toString();
    }
}



================================================
FILE: cpw/mods/fml/common/DummyModContainer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.util.Map;
import java.security.cert.Certificate;
import cpw.mods.fml.common.versioning.VersionRange;
import cpw.mods.fml.common.versioning.DefaultArtifactVersion;
import com.google.common.eventbus.EventBus;
import java.io.File;
import java.util.Set;
import java.util.Collections;
import java.util.List;
import cpw.mods.fml.common.versioning.ArtifactVersion;

public class DummyModContainer implements ModContainer
{
    private ModMetadata md;
    private ArtifactVersion processedVersion;
    private String label;
    
    public DummyModContainer(final ModMetadata md) {
        this.md = md;
    }
    
    public DummyModContainer(final String label) {
        this.label = label;
    }
    
    public DummyModContainer() {
    }
    
    @Override
    public void bindMetadata(final MetadataCollection mc) {
    }
    
    @Override
    public List<ArtifactVersion> getDependants() {
        return Collections.emptyList();
    }
    
    @Override
    public List<ArtifactVersion> getDependencies() {
        return Collections.emptyList();
    }
    
    @Override
    public Set<ArtifactVersion> getRequirements() {
        return Collections.emptySet();
    }
    
    @Override
    public ModMetadata getMetadata() {
        return this.md;
    }
    
    @Override
    public Object getMod() {
        return null;
    }
    
    @Override
    public String getModId() {
        return this.md.modId;
    }
    
    @Override
    public String getName() {
        return this.md.name;
    }
    
    @Override
    public String getSortingRules() {
        return "";
    }
    
    @Override
    public File getSource() {
        return null;
    }
    
    @Override
    public String getVersion() {
        return this.md.version;
    }
    
    @Override
    public boolean matches(final Object mod) {
        return false;
    }
    
    @Override
    public void setEnabledState(final boolean enabled) {
    }
    
    @Override
    public boolean registerBus(final EventBus bus, final LoadController controller) {
        return false;
    }
    
    @Override
    public ArtifactVersion getProcessedVersion() {
        if (this.processedVersion == null) {
            this.processedVersion = new DefaultArtifactVersion(this.getModId(), this.getVersion());
        }
        return this.processedVersion;
    }
    
    @Override
    public boolean isImmutable() {
        return false;
    }
    
    @Override
    public boolean isNetworkMod() {
        return false;
    }
    
    @Override
    public String getDisplayVersion() {
        return this.md.version;
    }
    
    @Override
    public VersionRange acceptableMinecraftVersionRange() {
        return Loader.instance().getMinecraftModContainer().getStaticVersionRange();
    }
    
    @Override
    public Certificate getSigningCertificate() {
        return null;
    }
    
    @Override
    public String toString() {
        return (this.md != null) ? this.getModId() : ("Dummy Container (" + this.label + ") @" + System.identityHashCode(this));
    }
    
    @Override
    public Map<String, String> getCustomModProperties() {
        return DummyModContainer.EMPTY_PROPERTIES;
    }
    
    @Override
    public Class<?> getCustomResourcePackClass() {
        return null;
    }
    
    @Override
    public Map<String, String> getSharedModDescriptor() {
        return null;
    }
}



================================================
FILE: cpw/mods/fml/common/DuplicateModsFoundException.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.io.File;
import com.google.common.collect.SetMultimap;

public class DuplicateModsFoundException extends LoaderException
{
    public SetMultimap<ModContainer, File> dupes;
    
    public DuplicateModsFoundException(final SetMultimap<ModContainer, File> dupes) {
        this.dupes = dupes;
    }
}



================================================
FILE: cpw/mods/fml/common/FMLCommonHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import com.google.common.base.Joiner;
import cpw.mods.fml.common.registry.ItemData;
import com.google.common.collect.MapDifference;
import com.google.common.collect.Maps;
import java.util.concurrent.Callable;
import cpw.mods.fml.server.FMLServerHandler;
import cpw.mods.fml.common.network.EntitySpawnAdjustmentPacket;
import cpw.mods.fml.common.network.EntitySpawnPacket;
import cpw.mods.fml.common.registry.EntityRegistry;
import net.minecraft.server.MinecraftServer;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableList;
import java.util.logging.Logger;
import java.util.Iterator;
import java.util.Collection;
import com.google.common.base.Objects;
import java.util.EnumSet;
import cpw.mods.fml.common.registry.TickRegistry;
import cpw.mods.fml.relauncher.Side;
import java.util.logging.Level;
import java.util.Map;
import com.google.common.collect.Sets;
import com.google.common.collect.MapMaker;
import com.google.common.collect.Lists;
import java.util.Set;
import java.util.List;

public class FMLCommonHandler
{
    private static final FMLCommonHandler INSTANCE;
    private IFMLSidedHandler sidedDelegate;
    private List<IScheduledTickHandler> scheduledClientTicks;
    private List<IScheduledTickHandler> scheduledServerTicks;
    private Class<?> forge;
    private boolean noForge;
    private List<String> brandings;
    private List<ICrashCallable> crashCallables;
    private Set<alq> handlerSet;
    
    public FMLCommonHandler() {
        this.scheduledClientTicks = Lists.newArrayList();
        this.scheduledServerTicks = Lists.newArrayList();
        this.crashCallables = Lists.newArrayList((Object[])new ICrashCallable[] { Loader.instance().getCallableCrashInformation() });
        this.handlerSet = Sets.newSetFromMap((Map)new MapMaker().weakKeys().makeMap());
    }
    
    public void beginLoading(final IFMLSidedHandler handler) {
        this.sidedDelegate = handler;
        FMLLog.log("MinecraftForge", Level.INFO, "Attempting early MinecraftForge initialization", new Object[0]);
        this.callForgeMethod("initialize");
        this.callForgeMethod("registerCrashCallable");
        FMLLog.log("MinecraftForge", Level.INFO, "Completed early MinecraftForge initialization", new Object[0]);
    }
    
    public void rescheduleTicks(final Side side) {
        TickRegistry.updateTickQueue(side.isClient() ? this.scheduledClientTicks : this.scheduledServerTicks, side);
    }
    
    public void tickStart(final EnumSet<TickType> ticks, final Side side, final Object... data) {
        final List<IScheduledTickHandler> scheduledTicks = side.isClient() ? this.scheduledClientTicks : this.scheduledServerTicks;
        if (scheduledTicks.size() == 0) {
            return;
        }
        for (final IScheduledTickHandler ticker : scheduledTicks) {
            final EnumSet<TickType> ticksToRun = EnumSet.copyOf((EnumSet<TickType>)Objects.firstNonNull((Object)ticker.ticks(), (Object)EnumSet.noneOf(TickType.class)));
            ticksToRun.retainAll(ticks);
            if (!ticksToRun.isEmpty()) {
                ticker.tickStart(ticksToRun, data);
            }
        }
    }
    
    public void tickEnd(final EnumSet<TickType> ticks, final Side side, final Object... data) {
        final List<IScheduledTickHandler> scheduledTicks = side.isClient() ? this.scheduledClientTicks : this.scheduledServerTicks;
        if (scheduledTicks.size() == 0) {
            return;
        }
        for (final IScheduledTickHandler ticker : scheduledTicks) {
            final EnumSet<TickType> ticksToRun = EnumSet.copyOf((EnumSet<TickType>)Objects.firstNonNull((Object)ticker.ticks(), (Object)EnumSet.noneOf(TickType.class)));
            ticksToRun.retainAll(ticks);
            if (!ticksToRun.isEmpty()) {
                ticker.tickEnd(ticksToRun, data);
            }
        }
    }
    
    public static FMLCommonHandler instance() {
        return FMLCommonHandler.INSTANCE;
    }
    
    public ModContainer findContainerFor(final Object mod) {
        return (ModContainer)Loader.instance().getReversedModObjectList().get(mod);
    }
    
    public Logger getFMLLogger() {
        return FMLLog.getLogger();
    }
    
    public Side getSide() {
        return this.sidedDelegate.getSide();
    }
    
    public Side getEffectiveSide() {
        final Thread thr = Thread.currentThread();
        if (thr instanceof hi || thr instanceof iy) {
            return Side.SERVER;
        }
        return Side.CLIENT;
    }
    
    public void raiseException(final Throwable exception, final String message, final boolean stopGame) {
        FMLLog.log(Level.SEVERE, exception, "Something raised an exception. The message was '%s'. 'stopGame' is %b", message, stopGame);
        if (stopGame) {
            this.getSidedDelegate().haltGame(message, exception);
        }
    }
    
    private Class<?> findMinecraftForge() {
        if (this.forge == null && !this.noForge) {
            try {
                this.forge = Class.forName("net.minecraftforge.common.MinecraftForge");
            }
            catch (final Exception ex) {
                this.noForge = true;
            }
        }
        return this.forge;
    }
    
    private Object callForgeMethod(final String method) {
        if (this.noForge) {
            return null;
        }
        try {
            return this.findMinecraftForge().getMethod(method, (Class<?>[])new Class[0]).invoke(null, new Object[0]);
        }
        catch (final Exception e) {
            return null;
        }
    }
    
    public void computeBranding() {
        if (this.brandings == null) {
            final ImmutableList.Builder brd = ImmutableList.builder();
            brd.add((Object)Loader.instance().getMCVersionString());
            brd.add((Object)Loader.instance().getMCPVersionString());
            brd.add((Object)("FML v" + Loader.instance().getFMLVersionString()));
            final String forgeBranding = (String)this.callForgeMethod("getBrandingVersion");
            if (!Strings.isNullOrEmpty(forgeBranding)) {
                brd.add((Object)forgeBranding);
            }
            if (this.sidedDelegate != null) {
                brd.addAll((Iterable)this.sidedDelegate.getAdditionalBrandingInformation());
            }
            if (Loader.instance().getFMLBrandingProperties().containsKey("fmlbranding")) {
                brd.add((Object)Loader.instance().getFMLBrandingProperties().get("fmlbranding"));
            }
            final int tModCount = Loader.instance().getModList().size();
            final int aModCount = Loader.instance().getActiveModList().size();
            brd.add((Object)String.format("%d mod%s loaded, %d mod%s active", tModCount, (tModCount != 1) ? "s" : "", aModCount, (aModCount != 1) ? "s" : ""));
            this.brandings = (List<String>)brd.build();
        }
    }
    
    public List<String> getBrandings() {
        if (this.brandings == null) {
            this.computeBranding();
        }
        return (List<String>)ImmutableList.copyOf((Collection)this.brandings);
    }
    
    public IFMLSidedHandler getSidedDelegate() {
        return this.sidedDelegate;
    }
    
    public void onPostServerTick() {
        this.tickEnd(EnumSet.of(TickType.SERVER), Side.SERVER, new Object[0]);
    }
    
    public void onPostWorldTick(final Object world) {
        this.tickEnd(EnumSet.of(TickType.WORLD), Side.SERVER, world);
    }
    
    public void onPreServerTick() {
        this.tickStart(EnumSet.of(TickType.SERVER), Side.SERVER, new Object[0]);
    }
    
    public void onPreWorldTick(final Object world) {
        this.tickStart(EnumSet.of(TickType.WORLD), Side.SERVER, world);
    }
    
    public void onWorldLoadTick(final abw[] worlds) {
        this.rescheduleTicks(Side.SERVER);
        for (final abw w : worlds) {
            this.tickStart(EnumSet.of(TickType.WORLDLOAD), Side.SERVER, w);
        }
    }
    
    public boolean handleServerAboutToStart(final MinecraftServer server) {
        return Loader.instance().serverAboutToStart(server);
    }
    
    public boolean handleServerStarting(final MinecraftServer server) {
        return Loader.instance().serverStarting(server);
    }
    
    public void handleServerStarted() {
        Loader.instance().serverStarted();
    }
    
    public void handleServerStopping() {
        Loader.instance().serverStopping();
    }
    
    public MinecraftServer getMinecraftServerInstance() {
        return this.sidedDelegate.getServer();
    }
    
    public void showGuiScreen(final Object clientGuiElement) {
        this.sidedDelegate.showGuiScreen(clientGuiElement);
    }
    
    public nn spawnEntityIntoClientWorld(final EntityRegistry.EntityRegistration registration, final EntitySpawnPacket entitySpawnPacket) {
        return this.sidedDelegate.spawnEntityIntoClientWorld(registration, entitySpawnPacket);
    }
    
    public void adjustEntityLocationOnClient(final EntitySpawnAdjustmentPacket entitySpawnAdjustmentPacket) {
        this.sidedDelegate.adjustEntityLocationOnClient(entitySpawnAdjustmentPacket);
    }
    
    public void onServerStart(final is dedicatedServer) {
        FMLServerHandler.instance();
        this.sidedDelegate.beginServerLoading((MinecraftServer)dedicatedServer);
    }
    
    public void onServerStarted() {
        this.sidedDelegate.finishServerLoading();
    }
    
    public void onPreClientTick() {
        this.tickStart(EnumSet.of(TickType.CLIENT), Side.CLIENT, new Object[0]);
    }
    
    public void onPostClientTick() {
        this.tickEnd(EnumSet.of(TickType.CLIENT), Side.CLIENT, new Object[0]);
    }
    
    public void onRenderTickStart(final float timer) {
        this.tickStart(EnumSet.of(TickType.RENDER), Side.CLIENT, timer);
    }
    
    public void onRenderTickEnd(final float timer) {
        this.tickEnd(EnumSet.of(TickType.RENDER), Side.CLIENT, timer);
    }
    
    public void onPlayerPreTick(final uf player) {
        final Side side = (player instanceof jv) ? Side.SERVER : Side.CLIENT;
        this.tickStart(EnumSet.of(TickType.PLAYER), side, player);
    }
    
    public void onPlayerPostTick(final uf player) {
        final Side side = (player instanceof jv) ? Side.SERVER : Side.CLIENT;
        this.tickEnd(EnumSet.of(TickType.PLAYER), side, player);
    }
    
    public void registerCrashCallable(final ICrashCallable callable) {
        this.crashCallables.add(callable);
    }
    
    public void enhanceCrashReport(final b crashReport, final m category) {
        for (final ICrashCallable call : this.crashCallables) {
            category.a(call.getLabel(), (Callable)call);
        }
    }
    
    public void handleTinyPacket(final ez handler, final dr mapData) {
        this.sidedDelegate.handleTinyPacket(handler, mapData);
    }
    
    public void handleWorldDataSave(final alq handler, final als worldInfo, final by tagCompound) {
        for (final ModContainer mc : Loader.instance().getModList()) {
            if (mc instanceof InjectedModContainer) {
                final WorldAccessContainer wac = ((InjectedModContainer)mc).getWrappedWorldAccessContainer();
                if (wac == null) {
                    continue;
                }
                final by dataForWriting = wac.getDataForWriting(handler, worldInfo);
                tagCompound.a(mc.getModId(), dataForWriting);
            }
        }
    }
    
    public void handleWorldDataLoad(final alq handler, final als worldInfo, final by tagCompound) {
        if (this.getEffectiveSide() != Side.SERVER) {
            return;
        }
        if (this.handlerSet.contains(handler)) {
            return;
        }
        this.handlerSet.add(handler);
        final Map<String, cl> additionalProperties = Maps.newHashMap();
        worldInfo.setAdditionalProperties((Map)additionalProperties);
        for (final ModContainer mc : Loader.instance().getModList()) {
            if (mc instanceof InjectedModContainer) {
                final WorldAccessContainer wac = ((InjectedModContainer)mc).getWrappedWorldAccessContainer();
                if (wac == null) {
                    continue;
                }
                wac.readData(handler, worldInfo, additionalProperties, tagCompound.l(mc.getModId()));
            }
        }
    }
    
    public boolean shouldServerBeKilledQuietly() {
        return this.sidedDelegate != null && this.sidedDelegate.shouldServerShouldBeKilledQuietly();
    }
    
    public void disconnectIDMismatch(final MapDifference<Integer, ItemData> serverDifference, final ez toKill, final cm network) {
        this.sidedDelegate.disconnectIDMismatch(serverDifference, toKill, network);
    }
    
    public void handleServerStopped() {
        this.sidedDelegate.serverStopped();
        final MinecraftServer server = this.getMinecraftServerInstance();
        Loader.instance().serverStopped();
        if (server != null) {
            ObfuscationReflectionHelper.setPrivateValue(MinecraftServer.class, server, false, "field_71316_v", "u", "serverStopped");
        }
    }
    
    public String getModName() {
        final List<String> modNames = Lists.newArrayListWithExpectedSize(3);
        modNames.add("fml");
        if (!this.noForge) {
            modNames.add("forge");
        }
        if (Loader.instance().getFMLBrandingProperties().containsKey("snooperbranding")) {
            modNames.add(Loader.instance().getFMLBrandingProperties().get("snooperbranding"));
        }
        return Joiner.on(',').join((Iterable)modNames);
    }
    
    public void addModToResourcePack(final ModContainer container) {
        this.sidedDelegate.addModAsResource(container);
    }
    
    public void updateResourcePackList() {
        this.sidedDelegate.updateResourcePackList();
    }
    
    public String getCurrentLanguage() {
        return this.sidedDelegate.getCurrentLanguage();
    }
    
    static {
        INSTANCE = new FMLCommonHandler();
    }
}



================================================
FILE: cpw/mods/fml/common/FMLDummyContainer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import cpw.mods.fml.client.FMLFileResourcePack;
import cpw.mods.fml.client.FMLFolderResourcePack;
import cpw.mods.fml.common.asm.FMLSanityChecker;
import java.io.File;
import java.security.cert.Certificate;
import cpw.mods.fml.common.registry.ItemData;
import java.util.Set;
import java.util.logging.Level;
import java.util.Map;
import java.util.Iterator;
import cpw.mods.fml.common.registry.GameData;
import com.google.common.eventbus.EventBus;
import java.util.Arrays;

public class FMLDummyContainer extends DummyModContainer implements WorldAccessContainer
{
    public FMLDummyContainer() {
        super(new ModMetadata());
        final ModMetadata meta = this.getMetadata();
        meta.modId = "FML";
        meta.name = "Forge Mod Loader";
        meta.version = Loader.instance().getFMLVersionString();
        meta.credits = "Made possible with help from many people";
        meta.authorList = Arrays.asList("cpw, LexManos");
        meta.description = "The Forge Mod Loader provides the ability for systems to load mods from the file system. It also provides key capabilities for mods to be able to cooperate and provide a good modding environment. The mod loading system is compatible with ModLoader, all your ModLoader mods should work.";
        meta.url = "https://github.com/MinecraftForge/FML/wiki";
        meta.updateUrl = "https://github.com/MinecraftForge/FML/wiki";
        meta.screenshots = new String[0];
        meta.logoFile = "";
    }
    
    @Override
    public boolean registerBus(final EventBus bus, final LoadController controller) {
        return true;
    }
    
    @Override
    public by getDataForWriting(final alq handler, final als info) {
        final by fmlData = new by();
        final cg list = new cg();
        for (final ModContainer mc : Loader.instance().getActiveModList()) {
            final by mod = new by();
            mod.a("ModId", mc.getModId());
            mod.a("ModVersion", mc.getVersion());
            list.a((cl)mod);
        }
        fmlData.a("ModList", (cl)list);
        final cg itemList = new cg();
        GameData.writeItemData(itemList);
        fmlData.a("ModItemData", (cl)itemList);
        return fmlData;
    }
    
    @Override
    public void readData(final alq handler, final als info, final Map<String, cl> propertyMap, final by tag) {
        if (tag.b("ModList")) {
            final cg modList = tag.m("ModList");
            for (int i = 0; i < modList.c(); ++i) {
                final by mod = (by)modList.b(i);
                final String modId = mod.i("ModId");
                final String modVersion = mod.i("ModVersion");
                final ModContainer container = Loader.instance().getIndexedModList().get(modId);
                if (container == null) {
                    FMLLog.log("fml.ModTracker", Level.SEVERE, "This world was saved with mod %s which appears to be missing, things may not work well", modId);
                }
                else if (!modVersion.equals(container.getVersion())) {
                    FMLLog.log("fml.ModTracker", Level.INFO, "This world was saved with mod %s version %s and it is now at version %s, things may not work well", modId, modVersion, container.getVersion());
                }
            }
        }
        if (tag.b("ModItemData")) {
            final cg modList = tag.m("ModItemData");
            final Set<ItemData> worldSaveItems = GameData.buildWorldItemData(modList);
            GameData.validateWorldSave(worldSaveItems);
        }
        else {
            GameData.validateWorldSave(null);
        }
    }
    
    @Override
    public Certificate getSigningCertificate() {
        final Certificate[] certificates = this.getClass().getProtectionDomain().getCodeSource().getCertificates();
        return (certificates != null) ? certificates[0] : null;
    }
    
    @Override
    public File getSource() {
        return FMLSanityChecker.fmlLocation;
    }
    
    @Override
    public Class<?> getCustomResourcePackClass() {
        return (Class<?>)(this.getSource().isDirectory() ? FMLFolderResourcePack.class : FMLFileResourcePack.class);
    }
}



================================================
FILE: cpw/mods/fml/common/FMLLog.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.util.logging.Logger;
import java.util.logging.Level;
import cpw.mods.fml.relauncher.FMLRelaunchLog;

public class FMLLog
{
    private static FMLRelaunchLog coreLog;
    
    public static void log(final String logChannel, final Level level, final String format, final Object... data) {
        final FMLRelaunchLog coreLog = FMLLog.coreLog;
        FMLRelaunchLog.log(logChannel, level, format, data);
    }
    
    public static void log(final Level level, final String format, final Object... data) {
        final FMLRelaunchLog coreLog = FMLLog.coreLog;
        FMLRelaunchLog.log(level, format, data);
    }
    
    public static void log(final String logChannel, final Level level, final Throwable ex, final String format, final Object... data) {
        final FMLRelaunchLog coreLog = FMLLog.coreLog;
        FMLRelaunchLog.log(logChannel, level, ex, format, data);
    }
    
    public static void log(final Level level, final Throwable ex, final String format, final Object... data) {
        final FMLRelaunchLog coreLog = FMLLog.coreLog;
        FMLRelaunchLog.log(level, ex, format, data);
    }
    
    public static void severe(final String format, final Object... data) {
        log(Level.SEVERE, format, data);
    }
    
    public static void warning(final String format, final Object... data) {
        log(Level.WARNING, format, data);
    }
    
    public static void info(final String format, final Object... data) {
        log(Level.INFO, format, data);
    }
    
    public static void fine(final String format, final Object... data) {
        log(Level.FINE, format, data);
    }
    
    public static void finer(final String format, final Object... data) {
        log(Level.FINER, format, data);
    }
    
    public static void finest(final String format, final Object... data) {
        log(Level.FINEST, format, data);
    }
    
    public static Logger getLogger() {
        return FMLLog.coreLog.getLogger();
    }
    
    public static void makeLog(final String logChannel) {
        final FMLRelaunchLog coreLog = FMLLog.coreLog;
        FMLRelaunchLog.makeLog(logChannel);
    }
    
    static {
        FMLLog.coreLog = FMLRelaunchLog.log;
    }
}



================================================
FILE: cpw/mods/fml/common/FMLModContainer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import cpw.mods.fml.common.event.FMLInterModComms;
import cpw.mods.fml.common.event.FMLServerStoppedEvent;
import cpw.mods.fml.common.event.FMLServerStoppingEvent;
import cpw.mods.fml.common.event.FMLServerStartedEvent;
import cpw.mods.fml.common.event.FMLServerStartingEvent;
import cpw.mods.fml.common.event.FMLServerAboutToStartEvent;
import cpw.mods.fml.common.event.FMLPostInitializationEvent;
import cpw.mods.fml.common.event.FMLInitializationEvent;
import cpw.mods.fml.common.event.FMLPreInitializationEvent;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.Maps;
import com.google.common.eventbus.Subscribe;
import cpw.mods.fml.common.event.FMLFingerprintViolationEvent;
import cpw.mods.fml.common.network.FMLNetworkHandler;
import com.google.common.collect.ImmutableMap;
import java.util.Collection;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableList;
import cpw.mods.fml.common.event.FMLConstructionEvent;
import java.lang.reflect.Field;
import java.util.Iterator;
import com.google.common.collect.SetMultimap;
import com.google.common.base.Function;
import cpw.mods.fml.common.discovery.ASMDataTable;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.zip.ZipEntry;
import com.google.common.base.Throwables;
import java.io.InputStream;
import java.io.FileInputStream;
import java.util.zip.ZipFile;
import java.util.Properties;
import java.util.List;
import cpw.mods.fml.common.versioning.ArtifactVersion;
import cpw.mods.fml.common.versioning.VersionParser;
import com.google.common.base.Strings;
import java.util.logging.Level;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.google.common.collect.ArrayListMultimap;
import cpw.mods.fml.common.discovery.ModCandidate;
import java.lang.reflect.Method;
import com.google.common.collect.ListMultimap;
import java.security.cert.Certificate;
import java.util.Set;
import cpw.mods.fml.common.versioning.VersionRange;
import java.lang.annotation.Annotation;
import cpw.mods.fml.common.event.FMLEvent;
import com.google.common.collect.BiMap;
import cpw.mods.fml.common.versioning.DefaultArtifactVersion;
import com.google.common.eventbus.EventBus;
import java.util.Map;
import java.io.File;

public class FMLModContainer implements ModContainer
{
    private Mod modDescriptor;
    private Object modInstance;
    private File source;
    private ModMetadata modMetadata;
    private String className;
    private Map<String, Object> descriptor;
    private boolean enabled;
    private String internalVersion;
    private boolean overridesMetadata;
    private EventBus eventBus;
    private LoadController controller;
    private DefaultArtifactVersion processedVersion;
    private boolean isNetworkMod;
    private static final BiMap<Class<? extends FMLEvent>, Class<? extends Annotation>> modAnnotationTypes;
    private static final BiMap<Class<? extends Annotation>, Class<? extends FMLEvent>> modTypeAnnotations;
    private String annotationDependencies;
    private VersionRange minecraftAccepted;
    private boolean fingerprintNotPresent;
    private Set<String> sourceFingerprints;
    private Certificate certificate;
    private String modLanguage;
    private ILanguageAdapter languageAdapter;
    private ListMultimap<Class<? extends FMLEvent>, Method> eventMethods;
    private Map<String, String> customModProperties;
    private ModCandidate candidate;
    
    public FMLModContainer(final String className, final ModCandidate container, final Map<String, Object> modDescriptor) {
        this.enabled = true;
        this.className = className;
        this.source = container.getModContainer();
        this.candidate = container;
        this.descriptor = modDescriptor;
        this.modLanguage = modDescriptor.get("modLanguage");
        this.languageAdapter = ("scala".equals(this.modLanguage) ? new ILanguageAdapter.ScalaAdapter() : new ILanguageAdapter.JavaAdapter());
        this.eventMethods = (ListMultimap<Class<? extends FMLEvent>, Method>)ArrayListMultimap.create();
    }
    
    private ILanguageAdapter getLanguageAdapter() {
        return this.languageAdapter;
    }
    
    @Override
    public String getModId() {
        return this.descriptor.get("modid");
    }
    
    @Override
    public String getName() {
        return this.modMetadata.name;
    }
    
    @Override
    public String getVersion() {
        return this.internalVersion;
    }
    
    @Override
    public File getSource() {
        return this.source;
    }
    
    @Override
    public ModMetadata getMetadata() {
        return this.modMetadata;
    }
    
    @Override
    public void bindMetadata(final MetadataCollection mc) {
        this.modMetadata = mc.getMetadataForId(this.getModId(), this.descriptor);
        if (this.descriptor.containsKey("useMetadata")) {
            this.overridesMetadata = !this.descriptor.get("useMetadata");
        }
        if (this.overridesMetadata || !this.modMetadata.useDependencyInformation) {
            final Set<ArtifactVersion> requirements = Sets.newHashSet();
            final List<ArtifactVersion> dependencies = Lists.newArrayList();
            final List<ArtifactVersion> dependants = Lists.newArrayList();
            this.annotationDependencies = this.descriptor.get("dependencies");
            Loader.instance().computeDependencies(this.annotationDependencies, requirements, dependencies, dependants);
            this.modMetadata.requiredMods = requirements;
            this.modMetadata.dependencies = dependencies;
            this.modMetadata.dependants = dependants;
            FMLLog.log(this.getModId(), Level.FINEST, "Parsed dependency info : %s %s %s", requirements, dependencies, dependants);
        }
        else {
            FMLLog.log(this.getModId(), Level.FINEST, "Using mcmod dependency info : %s %s %s", this.modMetadata.requiredMods, this.modMetadata.dependencies, this.modMetadata.dependants);
        }
        if (Strings.isNullOrEmpty(this.modMetadata.name)) {
            FMLLog.log(this.getModId(), Level.INFO, "Mod %s is missing the required element 'name'. Substituting %s", this.getModId(), this.getModId());
            this.modMetadata.name = this.getModId();
        }
        this.internalVersion = this.descriptor.get("version");
        if (Strings.isNullOrEmpty(this.internalVersion)) {
            final Properties versionProps = this.searchForVersionProperties();
            if (versionProps != null) {
                this.internalVersion = versionProps.getProperty(this.getModId() + ".version");
                FMLLog.log(this.getModId(), Level.FINE, "Found version %s for mod %s in version.properties, using", this.internalVersion, this.getModId());
            }
        }
        if (Strings.isNullOrEmpty(this.internalVersion) && !Strings.isNullOrEmpty(this.modMetadata.version)) {
            FMLLog.log(this.getModId(), Level.WARNING, "Mod %s is missing the required element 'version' and a version.properties file could not be found. Falling back to metadata version %s", this.getModId(), this.modMetadata.version);
            this.internalVersion = this.modMetadata.version;
        }
        if (Strings.isNullOrEmpty(this.internalVersion)) {
            FMLLog.log(this.getModId(), Level.WARNING, "Mod %s is missing the required element 'version' and no fallback can be found. Substituting '1.0'.", this.getModId());
            final ModMetadata modMetadata = this.modMetadata;
            final String s = "1.0";
            this.internalVersion = s;
            modMetadata.version = s;
        }
        final String mcVersionString = this.descriptor.get("acceptedMinecraftVersions");
        if (!Strings.isNullOrEmpty(mcVersionString)) {
            this.minecraftAccepted = VersionParser.parseRange(mcVersionString);
        }
        else {
            this.minecraftAccepted = Loader.instance().getMinecraftModContainer().getStaticVersionRange();
        }
    }
    
    public Properties searchForVersionProperties() {
        try {
            FMLLog.log(this.getModId(), Level.FINE, "Attempting to load the file version.properties from %s to locate a version number for %s", this.getSource().getName(), this.getModId());
            Properties version = null;
            if (this.getSource().isFile()) {
                final ZipFile source = new ZipFile(this.getSource());
                final ZipEntry versionFile = source.getEntry("version.properties");
                if (versionFile != null) {
                    version = new Properties();
                    version.load(source.getInputStream(versionFile));
                }
                source.close();
            }
            else if (this.getSource().isDirectory()) {
                final File propsFile = new File(this.getSource(), "version.properties");
                if (propsFile.exists() && propsFile.isFile()) {
                    version = new Properties();
                    final FileInputStream fis = new FileInputStream(propsFile);
                    version.load(fis);
                    fis.close();
                }
            }
            return version;
        }
        catch (final Exception e) {
            Throwables.propagateIfPossible((Throwable)e);
            FMLLog.log(this.getModId(), Level.FINEST, "Failed to find a usable version.properties file", new Object[0]);
            return null;
        }
    }
    
    @Override
    public void setEnabledState(final boolean enabled) {
        this.enabled = enabled;
    }
    
    @Override
    public Set<ArtifactVersion> getRequirements() {
        return this.modMetadata.requiredMods;
    }
    
    @Override
    public List<ArtifactVersion> getDependencies() {
        return this.modMetadata.dependencies;
    }
    
    @Override
    public List<ArtifactVersion> getDependants() {
        return this.modMetadata.dependants;
    }
    
    @Override
    public String getSortingRules() {
        return (this.overridesMetadata || !this.modMetadata.useDependencyInformation) ? Strings.nullToEmpty(this.annotationDependencies) : this.modMetadata.printableSortingRules();
    }
    
    @Override
    public boolean matches(final Object mod) {
        return mod == this.modInstance;
    }
    
    @Override
    public Object getMod() {
        return this.modInstance;
    }
    
    @Override
    public boolean registerBus(final EventBus bus, final LoadController controller) {
        if (this.enabled) {
            FMLLog.log(this.getModId(), Level.FINE, "Enabling mod %s", this.getModId());
            this.eventBus = bus;
            this.controller = controller;
            this.eventBus.register((Object)this);
            return true;
        }
        return false;
    }
    
    private Method gatherAnnotations(final Class<?> clazz) throws Exception {
        Method factoryMethod = null;
        for (final Method m : clazz.getDeclaredMethods()) {
            for (final Annotation a : m.getAnnotations()) {
                if (FMLModContainer.modTypeAnnotations.containsKey((Object)a.annotationType())) {
                    final Class<?>[] paramTypes = { (Class)FMLModContainer.modTypeAnnotations.get((Object)a.annotationType()) };
                    if (Arrays.equals(m.getParameterTypes(), paramTypes)) {
                        m.setAccessible(true);
                        this.eventMethods.put(FMLModContainer.modTypeAnnotations.get((Object)a.annotationType()), (Object)m);
                    }
                    else {
                        FMLLog.log(this.getModId(), Level.SEVERE, "The mod %s appears to have an invalid method annotation %s. This annotation can only apply to methods with argument types %s -it will not be called", this.getModId(), a.annotationType().getSimpleName(), Arrays.toString(paramTypes));
                    }
                }
                else if (a.annotationType().equals(Mod.EventHandler.class)) {
                    if (m.getParameterTypes().length == 1 && FMLModContainer.modAnnotationTypes.containsKey((Object)m.getParameterTypes()[0])) {
                        m.setAccessible(true);
                        this.eventMethods.put((Object)m.getParameterTypes()[0], (Object)m);
                    }
                    else {
                        FMLLog.log(this.getModId(), Level.SEVERE, "The mod %s appears to have an invalid event annotation %s. This annotation can only apply to methods with recognized event arguments - it will not be called", this.getModId(), a.annotationType().getSimpleName());
                    }
                }
                else if (a.annotationType().equals(Mod.InstanceFactory.class)) {
                    if (Modifier.isStatic(m.getModifiers()) && m.getParameterTypes().length == 0 && factoryMethod == null) {
                        m.setAccessible(true);
                        factoryMethod = m;
                    }
                    else if (!Modifier.isStatic(m.getModifiers()) || m.getParameterTypes().length != 0) {
                        FMLLog.log(this.getModId(), Level.SEVERE, "The InstanceFactory annotation can only apply to a static method, taking zero arguments - it will be ignored on %s(%s)", m.getName(), Arrays.asList(m.getParameterTypes()));
                    }
                    else if (factoryMethod != null) {
                        FMLLog.log(this.getModId(), Level.SEVERE, "The InstanceFactory annotation can only be used once, the application to %s(%s) will be ignored", m.getName(), Arrays.asList(m.getParameterTypes()));
                    }
                }
            }
        }
        return factoryMethod;
    }
    
    private void processFieldAnnotations(final ASMDataTable asmDataTable) throws Exception {
        final SetMultimap<String, ASMDataTable.ASMData> annotations = asmDataTable.getAnnotationsFor(this);
        this.parseSimpleFieldAnnotation(annotations, Mod.Instance.class.getName(), (Function<ModContainer, Object>)new Function<ModContainer, Object>() {
            public Object apply(final ModContainer mc) {
                return mc.getMod();
            }
        });
        this.parseSimpleFieldAnnotation(annotations, Mod.Metadata.class.getName(), (Function<ModContainer, Object>)new Function<ModContainer, Object>() {
            public Object apply(final ModContainer mc) {
                return mc.getMetadata();
            }
        });
    }
    
    private void parseSimpleFieldAnnotation(final SetMultimap<String, ASMDataTable.ASMData> annotations, final String annotationClassName, final Function<ModContainer, Object> retreiver) throws IllegalAccessException {
        final String[] annName = annotationClassName.split("\\.");
        final String annotationName = annName[annName.length - 1];
        for (final ASMDataTable.ASMData targets : annotations.get((Object)annotationClassName)) {
            final String targetMod = targets.getAnnotationInfo().get("value");
            Field f = null;
            Object injectedMod = null;
            ModContainer mc = this;
            boolean isStatic = false;
            Class<?> clz = this.modInstance.getClass();
            if (!Strings.isNullOrEmpty(targetMod)) {
                if (Loader.isModLoaded(targetMod)) {
                    mc = Loader.instance().getIndexedModList().get(targetMod);
                }
                else {
                    mc = null;
                }
            }
            if (mc != null) {
                try {
                    clz = Class.forName(targets.getClassName(), true, Loader.instance().getModClassLoader());
                    f = clz.getDeclaredField(targets.getObjectName());
                    f.setAccessible(true);
                    isStatic = Modifier.isStatic(f.getModifiers());
                    injectedMod = retreiver.apply((Object)mc);
                }
                catch (final Exception e) {
                    Throwables.propagateIfPossible((Throwable)e);
                    FMLLog.log(this.getModId(), Level.WARNING, e, "Attempting to load @%s in class %s for %s and failing", annotationName, targets.getClassName(), mc.getModId());
                }
            }
            if (f != null) {
                Object target = null;
                if (!isStatic) {
                    target = this.modInstance;
                    if (!this.modInstance.getClass().equals(clz)) {
                        FMLLog.log(this.getModId(), Level.WARNING, "Unable to inject @%s in non-static field %s.%s for %s as it is NOT the primary mod instance", annotationName, targets.getClassName(), targets.getObjectName(), mc.getModId());
                        continue;
                    }
                }
                f.set(target, injectedMod);
            }
        }
    }
    
    @Subscribe
    public void constructMod(final FMLConstructionEvent event) {
        try {
            final ModClassLoader modClassLoader = event.getModClassLoader();
            modClassLoader.addFile(this.source);
            modClassLoader.clearNegativeCacheFor(this.candidate.getClassList());
            final Class<?> clazz = Class.forName(this.className, true, modClassLoader);
            final Certificate[] certificates = clazz.getProtectionDomain().getCodeSource().getCertificates();
            int len = 0;
            if (certificates != null) {
                len = certificates.length;
            }
            final ImmutableList.Builder<String> certBuilder = (ImmutableList.Builder<String>)ImmutableList.builder();
            for (int i = 0; i < len; ++i) {
                certBuilder.add((Object)CertificateHelper.getFingerprint(certificates[i]));
            }
            final ImmutableList<String> certList = (ImmutableList<String>)certBuilder.build();
            this.sourceFingerprints = (Set<String>)ImmutableSet.copyOf((Collection)certList);
            final String expectedFingerprint = this.descriptor.get("certificateFingerprint");
            this.fingerprintNotPresent = true;
            if (expectedFingerprint != null && !expectedFingerprint.isEmpty()) {
                if (!this.sourceFingerprints.contains(expectedFingerprint)) {
                    Level warnLevel = Level.SEVERE;
                    if (this.source.isDirectory()) {
                        warnLevel = Level.FINER;
                    }
                    FMLLog.log(this.getModId(), warnLevel, "The mod %s is expecting signature %s for source %s, however there is no signature matching that description", this.getModId(), expectedFingerprint, this.source.getName());
                }
                else {
                    this.certificate = certificates[certList.indexOf((Object)expectedFingerprint)];
                    this.fingerprintNotPresent = false;
                }
            }
            final List<Map<String, Object>> props = this.descriptor.get("customProperties");
            if (props != null) {
                final ImmutableMap.Builder<String, String> builder = (ImmutableMap.Builder<String, String>)ImmutableMap.builder();
                for (final Map<String, Object> p : props) {
                    builder.put((Object)p.get("k"), (Object)p.get("v"));
                }
                this.customModProperties = (Map<String, String>)builder.build();
            }
            else {
                this.customModProperties = FMLModContainer.EMPTY_PROPERTIES;
            }
            final Method factoryMethod = this.gatherAnnotations(clazz);
            this.modInstance = this.getLanguageAdapter().getNewInstance(this, clazz, modClassLoader, factoryMethod);
            this.isNetworkMod = FMLNetworkHandler.instance().registerNetworkMod(this, clazz, event.getASMHarvestedData());
            if (this.fingerprintNotPresent) {
                this.eventBus.post((Object)new FMLFingerprintViolationEvent(this.source.isDirectory(), this.source, (ImmutableSet<String>)ImmutableSet.copyOf((Collection)this.sourceFingerprints), expectedFingerprint));
            }
            ProxyInjector.inject(this, event.getASMHarvestedData(), FMLCommonHandler.instance().getSide(), this.getLanguageAdapter());
            this.processFieldAnnotations(event.getASMHarvestedData());
        }
        catch (final Throwable e) {
            this.controller.errorOccurred(this, e);
            Throwables.propagateIfPossible(e);
        }
    }
    
    @Subscribe
    public void handleModStateEvent(final FMLEvent event) {
        if (!this.eventMethods.containsKey((Object)event.getClass())) {
            return;
        }
        try {
            for (final Method m : this.eventMethods.get((Object)event.getClass())) {
                m.invoke(this.modInstance, event);
            }
        }
        catch (final Throwable t) {
            this.controller.errorOccurred(this, t);
        }
    }
    
    @Override
    public ArtifactVersion getProcessedVersion() {
        if (this.processedVersion == null) {
            this.processedVersion = new DefaultArtifactVersion(this.getModId(), this.getVersion());
        }
        return this.processedVersion;
    }
    
    @Override
    public boolean isImmutable() {
        return false;
    }
    
    @Override
    public boolean isNetworkMod() {
        return this.isNetworkMod;
    }
    
    @Override
    public String getDisplayVersion() {
        return this.modMetadata.version;
    }
    
    @Override
    public VersionRange acceptableMinecraftVersionRange() {
        return this.minecraftAccepted;
    }
    
    @Override
    public Certificate getSigningCertificate() {
        return this.certificate;
    }
    
    @Override
    public String toString() {
        return "FMLMod:" + this.getModId() + "{" + this.getVersion() + "}";
    }
    
    @Override
    public Map<String, String> getCustomModProperties() {
        return this.customModProperties;
    }
    
    @Override
    public Class<?> getCustomResourcePackClass() {
        try {
            return this.getSource().isDirectory() ? Class.forName("cpw.mods.fml.client.FMLFolderResourcePack", true, this.getClass().getClassLoader()) : Class.forName("cpw.mods.fml.client.FMLFileResourcePack", true, this.getClass().getClassLoader());
        }
        catch (final ClassNotFoundException e) {
            return null;
        }
    }
    
    @Override
    public Map<String, String> getSharedModDescriptor() {
        final Map<String, String> descriptor = Maps.newHashMap();
        descriptor.put("modsystem", "FML");
        descriptor.put("id", this.getModId());
        descriptor.put("version", this.getDisplayVersion());
        descriptor.put("name", this.getName());
        descriptor.put("url", this.modMetadata.url);
        descriptor.put("authors", this.modMetadata.getAuthorList());
        descriptor.put("description", this.modMetadata.description);
        return descriptor;
    }
    
    static {
        modAnnotationTypes = (BiMap)ImmutableBiMap.builder().put((Object)FMLPreInitializationEvent.class, (Object)Mod.PreInit.class).put((Object)FMLInitializationEvent.class, (Object)Mod.Init.class).put((Object)FMLPostInitializationEvent.class, (Object)Mod.PostInit.class).put((Object)FMLServerAboutToStartEvent.class, (Object)Mod.ServerAboutToStart.class).put((Object)FMLServerStartingEvent.class, (Object)Mod.ServerStarting.class).put((Object)FMLServerStartedEvent.class, (Object)Mod.ServerStarted.class).put((Object)FMLServerStoppingEvent.class, (Object)Mod.ServerStopping.class).put((Object)FMLServerStoppedEvent.class, (Object)Mod.ServerStopped.class).put((Object)FMLInterModComms.IMCEvent.class, (Object)Mod.IMCCallback.class).put((Object)FMLFingerprintViolationEvent.class, (Object)Mod.FingerprintWarning.class).build();
        modTypeAnnotations = FMLModContainer.modAnnotationTypes.inverse();
    }
}



================================================
FILE: cpw/mods/fml/common/IASMHook.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import org.objectweb.asm.tree.ClassNode;

public interface IASMHook
{
    ClassNode[] inject(final ClassNode p0);
    
    void modifyClass(final String p0, final ClassNode p1);
}



================================================
FILE: cpw/mods/fml/common/IConsoleHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

public interface IConsoleHandler
{
    boolean handleCommand(final String p0, final Object... p1);
}



================================================
FILE: cpw/mods/fml/common/ICraftingHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

public interface ICraftingHandler
{
    void onCrafting(final uf p0, final ye p1, final mo p2);
    
    void onSmelting(final uf p0, final ye p1);
}



================================================
FILE: cpw/mods/fml/common/ICrashCallable.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.util.concurrent.Callable;

public interface ICrashCallable extends Callable<String>
{
    String getLabel();
}



================================================
FILE: cpw/mods/fml/common/IFMLHandledException.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

public interface IFMLHandledException
{
}



================================================
FILE: cpw/mods/fml/common/IFMLSidedHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import cpw.mods.fml.common.registry.ItemData;
import com.google.common.collect.MapDifference;
import cpw.mods.fml.common.network.ModMissingPacket;
import net.minecraft.server.MinecraftServer;
import cpw.mods.fml.common.network.EntitySpawnAdjustmentPacket;
import cpw.mods.fml.common.network.EntitySpawnPacket;
import cpw.mods.fml.common.registry.EntityRegistry;
import cpw.mods.fml.relauncher.Side;
import java.util.List;

public interface IFMLSidedHandler
{
    List<String> getAdditionalBrandingInformation();
    
    Side getSide();
    
    void haltGame(final String p0, final Throwable p1);
    
    void showGuiScreen(final Object p0);
    
    nn spawnEntityIntoClientWorld(final EntityRegistry.EntityRegistration p0, final EntitySpawnPacket p1);
    
    void adjustEntityLocationOnClient(final EntitySpawnAdjustmentPacket p0);
    
    void beginServerLoading(final MinecraftServer p0);
    
    void finishServerLoading();
    
    MinecraftServer getServer();
    
    void sendPacket(final ey p0);
    
    void displayMissingMods(final ModMissingPacket p0);
    
    void handleTinyPacket(final ez p0, final dr p1);
    
    void setClientCompatibilityLevel(final byte p0);
    
    byte getClientCompatibilityLevel();
    
    boolean shouldServerShouldBeKilledQuietly();
    
    void disconnectIDMismatch(final MapDifference<Integer, ItemData> p0, final ez p1, final cm p2);
    
    void addModAsResource(final ModContainer p0);
    
    void updateResourcePackList();
    
    String getCurrentLanguage();
    
    void serverStopped();
}



================================================
FILE: cpw/mods/fml/common/IFuelHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

public interface IFuelHandler
{
    int getBurnTime(final ye p0);
}



================================================
FILE: cpw/mods/fml/common/ILanguageAdapter.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.lang.reflect.InvocationTargetException;
import java.util.logging.Level;
import cpw.mods.fml.relauncher.Side;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

public interface ILanguageAdapter
{
    Object getNewInstance(final FMLModContainer p0, final Class<?> p1, final ClassLoader p2, final Method p3) throws Exception;
    
    boolean supportsStatics();
    
    void setProxy(final Field p0, final Class<?> p1, final Object p2) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, SecurityException;
    
    void setInternalProxies(final ModContainer p0, final Side p1, final ClassLoader p2);
    
    public static class ScalaAdapter implements ILanguageAdapter
    {
        @Override
        public Object getNewInstance(final FMLModContainer container, final Class<?> scalaObjectClass, final ClassLoader classLoader, final Method factoryMarkedAnnotation) throws Exception {
            final Class<?> sObjectClass = Class.forName(scalaObjectClass.getName() + "$", true, classLoader);
            return sObjectClass.getField("MODULE$").get(null);
        }
        
        @Override
        public boolean supportsStatics() {
            return false;
        }
        
        @Override
        public void setProxy(final Field target, Class<?> proxyTarget, final Object proxy) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, SecurityException {
            try {
                if (!proxyTarget.getName().endsWith("$")) {
                    proxyTarget = Class.forName(proxyTarget.getName() + "$", true, proxyTarget.getClassLoader());
                }
            }
            catch (final ClassNotFoundException e) {
                FMLLog.log(Level.INFO, e, "An error occured trying to load a proxy into %s.%s. Did you declare your mod as 'class' instead of 'object'?", proxyTarget.getSimpleName(), target.getName());
                return;
            }
            final Object targetInstance = proxyTarget.getField("MODULE$").get(null);
            try {
                final String setterName = target.getName() + "_$eq";
                for (final Method setter : proxyTarget.getMethods()) {
                    final Class<?>[] setterParameters = setter.getParameterTypes();
                    if (setterName.equals(setter.getName()) && setterParameters.length == 1 && setterParameters[0].isAssignableFrom(proxy.getClass())) {
                        setter.invoke(targetInstance, proxy);
                        return;
                    }
                }
            }
            catch (final InvocationTargetException e2) {
                FMLLog.log(Level.SEVERE, e2, "An error occured trying to load a proxy into %s.%s", proxyTarget.getSimpleName(), target.getName());
                throw new LoaderException(e2);
            }
            FMLLog.severe("Failed loading proxy into %s.%s, could not find setter function. Did you declare the field with 'val' instead of 'var'?", proxyTarget.getSimpleName(), target.getName());
            throw new LoaderException();
        }
        
        @Override
        public void setInternalProxies(final ModContainer mod, final Side side, final ClassLoader loader) {
            final Class<?> proxyTarget = mod.getMod().getClass();
            if (proxyTarget.getName().endsWith("$")) {
                for (final Field target : proxyTarget.getDeclaredFields()) {
                    if (target.getAnnotation(SidedProxy.class) != null) {
                        final String targetType = side.isClient() ? target.getAnnotation(SidedProxy.class).clientSide() : target.getAnnotation(SidedProxy.class).serverSide();
                        try {
                            final Object proxy = Class.forName(targetType, true, loader).newInstance();
                            if (!target.getType().isAssignableFrom(proxy.getClass())) {
                                FMLLog.severe("Attempted to load a proxy type %s into %s.%s, but the types don't match", targetType, proxyTarget.getSimpleName(), target.getName());
                                throw new LoaderException();
                            }
                            this.setProxy(target, proxyTarget, proxy);
                        }
                        catch (final Exception e) {
                            FMLLog.log(Level.SEVERE, e, "An error occured trying to load a proxy into %s.%s", proxyTarget.getSimpleName(), target.getName());
                            throw new LoaderException(e);
                        }
                    }
                }
            }
            else {
                FMLLog.finer("Mod does not appear to be a singleton.", new Object[0]);
            }
        }
    }
    
    public static class JavaAdapter implements ILanguageAdapter
    {
        @Override
        public Object getNewInstance(final FMLModContainer container, final Class<?> objectClass, final ClassLoader classLoader, final Method factoryMarkedMethod) throws Exception {
            if (factoryMarkedMethod != null) {
                return factoryMarkedMethod.invoke(null, new Object[0]);
            }
            return objectClass.newInstance();
        }
        
        @Override
        public boolean supportsStatics() {
            return true;
        }
        
        @Override
        public void setProxy(final Field target, final Class<?> proxyTarget, final Object proxy) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, SecurityException {
            target.set(null, proxy);
        }
        
        @Override
        public void setInternalProxies(final ModContainer mod, final Side side, final ClassLoader loader) {
        }
    }
}



================================================
FILE: cpw/mods/fml/common/INetworkHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

public interface INetworkHandler
{
    boolean onChat(final Object... p0);
    
    void onPacket250Packet(final Object... p0);
    
    void onServerLogin(final Object p0);
}



================================================
FILE: cpw/mods/fml/common/InjectedModContainer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.util.Map;
import java.security.cert.Certificate;
import cpw.mods.fml.common.versioning.VersionRange;
import com.google.common.eventbus.EventBus;
import java.util.List;
import cpw.mods.fml.common.versioning.ArtifactVersion;
import java.util.Set;
import java.io.File;

public class InjectedModContainer implements ModContainer
{
    private File source;
    public final ModContainer wrappedContainer;
    
    public InjectedModContainer(final ModContainer mc, final File source) {
        this.source = ((source != null) ? source : new File("minecraft.jar"));
        this.wrappedContainer = mc;
    }
    
    @Override
    public String getModId() {
        return this.wrappedContainer.getModId();
    }
    
    @Override
    public String getName() {
        return this.wrappedContainer.getName();
    }
    
    @Override
    public String getVersion() {
        return this.wrappedContainer.getVersion();
    }
    
    @Override
    public File getSource() {
        return this.source;
    }
    
    @Override
    public ModMetadata getMetadata() {
        return this.wrappedContainer.getMetadata();
    }
    
    @Override
    public void bindMetadata(final MetadataCollection mc) {
        this.wrappedContainer.bindMetadata(mc);
    }
    
    @Override
    public void setEnabledState(final boolean enabled) {
        this.wrappedContainer.setEnabledState(enabled);
    }
    
    @Override
    public Set<ArtifactVersion> getRequirements() {
        return this.wrappedContainer.getRequirements();
    }
    
    @Override
    public List<ArtifactVersion> getDependencies() {
        return this.wrappedContainer.getDependencies();
    }
    
    @Override
    public List<ArtifactVersion> getDependants() {
        return this.wrappedContainer.getDependants();
    }
    
    @Override
    public String getSortingRules() {
        return this.wrappedContainer.getSortingRules();
    }
    
    @Override
    public boolean registerBus(final EventBus bus, final LoadController controller) {
        return this.wrappedContainer.registerBus(bus, controller);
    }
    
    @Override
    public boolean matches(final Object mod) {
        return this.wrappedContainer.matches(mod);
    }
    
    @Override
    public Object getMod() {
        return this.wrappedContainer.getMod();
    }
    
    @Override
    public ArtifactVersion getProcessedVersion() {
        return this.wrappedContainer.getProcessedVersion();
    }
    
    @Override
    public boolean isNetworkMod() {
        return this.wrappedContainer.isNetworkMod();
    }
    
    @Override
    public boolean isImmutable() {
        return true;
    }
    
    @Override
    public String getDisplayVersion() {
        return this.wrappedContainer.getDisplayVersion();
    }
    
    @Override
    public VersionRange acceptableMinecraftVersionRange() {
        return this.wrappedContainer.acceptableMinecraftVersionRange();
    }
    
    public WorldAccessContainer getWrappedWorldAccessContainer() {
        if (this.wrappedContainer instanceof WorldAccessContainer) {
            return (WorldAccessContainer)this.wrappedContainer;
        }
        return null;
    }
    
    @Override
    public Certificate getSigningCertificate() {
        return this.wrappedContainer.getSigningCertificate();
    }
    
    @Override
    public String toString() {
        return "Wrapped{" + this.wrappedContainer.toString() + "}";
    }
    
    @Override
    public Map<String, String> getCustomModProperties() {
        return this.wrappedContainer.getCustomModProperties();
    }
    
    @Override
    public Class<?> getCustomResourcePackClass() {
        return this.wrappedContainer.getCustomResourcePackClass();
    }
    
    @Override
    public Map<String, String> getSharedModDescriptor() {
        return this.wrappedContainer.getSharedModDescriptor();
    }
}



================================================
FILE: cpw/mods/fml/common/IPickupNotifier.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

public interface IPickupNotifier
{
    void notifyPickup(final ss p0, final uf p1);
}



================================================
FILE: cpw/mods/fml/common/IPlayerTracker.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

public interface IPlayerTracker
{
    void onPlayerLogin(final uf p0);
    
    void onPlayerLogout(final uf p0);
    
    void onPlayerChangedDimension(final uf p0);
    
    void onPlayerRespawn(final uf p0);
}



================================================
FILE: cpw/mods/fml/common/IScheduledTickHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

public interface IScheduledTickHandler extends ITickHandler
{
    int nextTickSpacing();
}



================================================
FILE: cpw/mods/fml/common/ITickHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.util.EnumSet;

public interface ITickHandler
{
    void tickStart(final EnumSet<TickType> p0, final Object... p1);
    
    void tickEnd(final EnumSet<TickType> p0, final Object... p1);
    
    EnumSet<TickType> ticks();
    
    String getLabel();
}



================================================
FILE: cpw/mods/fml/common/IWorldGenerator.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.util.Random;

public interface IWorldGenerator
{
    void generate(final Random p0, final int p1, final int p2, final abw p3, final ado p4, final ado p5);
}



================================================
FILE: cpw/mods/fml/common/LoadController.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import com.google.common.collect.Iterables;
import com.google.common.base.Joiner;
import java.lang.reflect.InvocationTargetException;
import com.google.common.collect.ImmutableBiMap;
import cpw.mods.fml.common.event.FMLStateEvent;
import cpw.mods.fml.common.versioning.ArtifactVersion;
import com.google.common.base.Function;
import java.util.Collection;
import com.google.common.collect.Collections2;
import cpw.mods.fml.common.functions.ArtifactVersionNameFunction;
import cpw.mods.fml.common.event.FMLPreInitializationEvent;
import cpw.mods.fml.common.event.FMLEvent;
import com.google.common.eventbus.Subscribe;
import java.util.Iterator;
import java.util.logging.Level;
import java.util.logging.Logger;
import cpw.mods.fml.relauncher.FMLRelaunchLog;
import cpw.mods.fml.common.event.FMLLoadEvent;
import com.google.common.collect.Lists;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.BiMap;
import java.util.List;
import java.util.Map;
import com.google.common.collect.Multimap;
import com.google.common.collect.ImmutableMap;
import com.google.common.eventbus.EventBus;

public class LoadController
{
    private Loader loader;
    private EventBus masterChannel;
    private ImmutableMap<String, EventBus> eventChannels;
    private LoaderState state;
    private Multimap<String, LoaderState.ModState> modStates;
    private Multimap<String, Throwable> errors;
    private Map<String, ModContainer> modList;
    private List<ModContainer> activeModList;
    private ModContainer activeContainer;
    private BiMap<ModContainer, Object> modObjectList;
    
    public LoadController(final Loader loader) {
        this.modStates = (Multimap<String, LoaderState.ModState>)ArrayListMultimap.create();
        this.errors = (Multimap<String, Throwable>)ArrayListMultimap.create();
        this.activeModList = Lists.newArrayList();
        this.loader = loader;
        (this.masterChannel = new EventBus("FMLMainChannel")).register((Object)this);
        this.state = LoaderState.NOINIT;
    }
    
    @Subscribe
    public void buildModList(final FMLLoadEvent event) {
        this.modList = this.loader.getIndexedModList();
        final ImmutableMap.Builder<String, EventBus> eventBus = (ImmutableMap.Builder<String, EventBus>)ImmutableMap.builder();
        for (final ModContainer mod : this.loader.getModList()) {
            FMLRelaunchLog.makeLog(mod.getModId());
            final Logger modLogger = Logger.getLogger(mod.getModId());
            final Logger eventLog = Logger.getLogger(EventBus.class.getName() + "." + mod.getModId());
            eventLog.setParent(modLogger);
            final EventBus bus = new EventBus(mod.getModId());
            final boolean isActive = mod.registerBus(bus, this);
            if (isActive) {
                final Level level = Logger.getLogger(mod.getModId()).getLevel();
                FMLLog.log(mod.getModId(), Level.FINE, "Mod Logging channel %s configured at %s level.", mod.getModId(), (level == null) ? "default" : level);
                FMLLog.log(mod.getModId(), Level.INFO, "Activating mod %s", mod.getModId());
                this.activeModList.add(mod);
                this.modStates.put((Object)mod.getModId(), (Object)LoaderState.ModState.UNLOADED);
                eventBus.put((Object)mod.getModId(), (Object)bus);
                FMLCommonHandler.instance().addModToResourcePack(mod);
            }
            else {
                FMLLog.log(mod.getModId(), Level.WARNING, "Mod %s has been disabled through configuration", mod.getModId());
                this.modStates.put((Object)mod.getModId(), (Object)LoaderState.ModState.UNLOADED);
                this.modStates.put((Object)mod.getModId(), (Object)LoaderState.ModState.DISABLED);
            }
        }
        this.eventChannels = (ImmutableMap<String, EventBus>)eventBus.build();
        FMLCommonHandler.instance().updateResourcePackList();
    }
    
    public void distributeStateMessage(final LoaderState state, final Object... eventData) {
        if (state.hasEvent()) {
            this.masterChannel.post((Object)state.getEvent(eventData));
        }
    }
    
    public void transition(final LoaderState desiredState, final boolean forceState) {
        final LoaderState oldState = this.state;
        this.state = this.state.transition(!this.errors.isEmpty());
        if (this.state == desiredState || forceState) {
            if (this.state != desiredState && forceState) {
                FMLLog.info("The state engine was in incorrect state %s and forced into state %s. Errors may have been discarded.", this.state, desiredState);
                this.forceState(desiredState);
            }
            return;
        }
        Throwable toThrow = null;
        FMLLog.severe("Fatal errors were detected during the transition from %s to %s. Loading cannot continue", oldState, desiredState);
        final StringBuilder sb = new StringBuilder();
        this.printModStates(sb);
        FMLLog.getLogger().severe(sb.toString());
        if (this.errors.size() <= 0) {
            FMLLog.severe("The ForgeModLoader state engine has become corrupted. Probably, a state was missed by and invalid modification to a base classForgeModLoader depends on. This is a critical error and not recoverable. Investigate any modifications to base classes outside ofForgeModLoader, especially Optifine, to see if there are fixes available.", new Object[0]);
            throw new RuntimeException("The ForgeModLoader state engine is invalid");
        }
        FMLLog.severe("The following problems were captured during this phase", new Object[0]);
        for (final Map.Entry<String, Throwable> error : this.errors.entries()) {
            FMLLog.log(Level.SEVERE, error.getValue(), "Caught exception from %s", error.getKey());
            if (error.getValue() instanceof IFMLHandledException) {
                toThrow = error.getValue();
            }
            else {
                if (toThrow != null) {
                    continue;
                }
                toThrow = error.getValue();
            }
        }
        if (toThrow != null && toThrow instanceof RuntimeException) {
            throw (RuntimeException)toThrow;
        }
        throw new LoaderException(toThrow);
    }
    
    public ModContainer activeContainer() {
        return this.activeContainer;
    }
    
    @Subscribe
    public void propogateStateMessage(final FMLEvent stateEvent) {
        if (stateEvent instanceof FMLPreInitializationEvent) {
            this.modObjectList = (BiMap<ModContainer, Object>)this.buildModObjectList();
        }
        for (final ModContainer mc : this.activeModList) {
            this.sendEventToModContainer(stateEvent, mc);
        }
    }
    
    private void sendEventToModContainer(final FMLEvent stateEvent, final ModContainer mc) {
        final String modId = mc.getModId();
        final Collection<String> requirements = Collections2.transform((Collection)mc.getRequirements(), (Function)new ArtifactVersionNameFunction());
        for (final ArtifactVersion av : mc.getDependencies()) {
            if (av.getLabel() != null && requirements.contains(av.getLabel()) && this.modStates.containsEntry((Object)av.getLabel(), (Object)LoaderState.ModState.ERRORED)) {
                FMLLog.log(modId, Level.SEVERE, "Skipping event %s and marking errored mod %s since required dependency %s has errored", stateEvent.getEventType(), modId, av.getLabel());
                this.modStates.put((Object)modId, (Object)LoaderState.ModState.ERRORED);
                return;
            }
        }
        this.activeContainer = mc;
        stateEvent.applyModContainer(this.activeContainer());
        FMLLog.log(modId, Level.FINEST, "Sending event %s to mod %s", stateEvent.getEventType(), modId);
        ((EventBus)this.eventChannels.get((Object)modId)).post((Object)stateEvent);
        FMLLog.log(modId, Level.FINEST, "Sent event %s to mod %s", stateEvent.getEventType(), modId);
        this.activeContainer = null;
        if (stateEvent instanceof FMLStateEvent) {
            if (!this.errors.containsKey((Object)modId)) {
                this.modStates.put((Object)modId, (Object)((FMLStateEvent)stateEvent).getModState());
            }
            else {
                this.modStates.put((Object)modId, (Object)LoaderState.ModState.ERRORED);
            }
        }
    }
    
    public ImmutableBiMap<ModContainer, Object> buildModObjectList() {
        final ImmutableBiMap.Builder<ModContainer, Object> builder = (ImmutableBiMap.Builder<ModContainer, Object>)ImmutableBiMap.builder();
        for (final ModContainer mc : this.activeModList) {
            if (!mc.isImmutable() && mc.getMod() != null) {
                builder.put((Object)mc, mc.getMod());
            }
            if (mc.getMod() == null && !mc.isImmutable() && this.state != LoaderState.CONSTRUCTING) {
                FMLLog.severe("There is a severe problem with %s - it appears not to have constructed correctly", mc.getModId());
                if (this.state == LoaderState.CONSTRUCTING) {
                    continue;
                }
                this.errorOccurred(mc, new RuntimeException());
            }
        }
        return (ImmutableBiMap<ModContainer, Object>)builder.build();
    }
    
    public void errorOccurred(final ModContainer modContainer, final Throwable exception) {
        if (exception instanceof InvocationTargetException) {
            this.errors.put((Object)modContainer.getModId(), (Object)((InvocationTargetException)exception).getCause());
        }
        else {
            this.errors.put((Object)modContainer.getModId(), (Object)exception);
        }
    }
    
    public void printModStates(final StringBuilder ret) {
        for (final ModContainer mc : this.loader.getModList()) {
            ret.append("\n\t").append(mc.getModId()).append("{").append(mc.getVersion()).append("} [").append(mc.getName()).append("] (").append(mc.getSource().getName()).append(") ");
            Joiner.on("->").appendTo(ret, (Iterable)this.modStates.get((Object)mc.getModId()));
        }
    }
    
    public List<ModContainer> getActiveModList() {
        return this.activeModList;
    }
    
    public LoaderState.ModState getModState(final ModContainer selectedMod) {
        return (LoaderState.ModState)Iterables.getLast((Iterable)this.modStates.get((Object)selectedMod.getModId()), (Object)LoaderState.ModState.AVAILABLE);
    }
    
    public void distributeStateMessage(final Class<?> customEvent) {
        try {
            this.masterChannel.post((Object)customEvent.newInstance());
        }
        catch (final Exception e) {
            FMLLog.log(Level.SEVERE, e, "An unexpected exception", new Object[0]);
            throw new LoaderException(e);
        }
    }
    
    public BiMap<ModContainer, Object> getModObjectList() {
        if (this.modObjectList == null) {
            FMLLog.severe("Detected an attempt by a mod %s to perform game activity during mod construction. This is a serious programming error.", this.activeContainer);
            return (BiMap<ModContainer, Object>)this.buildModObjectList();
        }
        return (BiMap<ModContainer, Object>)ImmutableBiMap.copyOf((Map)this.modObjectList);
    }
    
    public boolean isInState(final LoaderState state) {
        return this.state == state;
    }
    
    boolean hasReachedState(final LoaderState state) {
        return this.state.ordinal() >= state.ordinal() && this.state != LoaderState.ERRORED;
    }
    
    void forceState(final LoaderState newState) {
        this.state = newState;
    }
}



================================================
FILE: cpw/mods/fml/common/Loader.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import cpw.mods.fml.common.event.FMLInterModComms;
import cpw.mods.fml.common.versioning.VersionParser;
import com.google.common.base.Joiner;
import java.io.Reader;
import java.io.FileReader;
import java.util.Properties;
import com.google.common.base.CharMatcher;
import cpw.mods.fml.common.registry.GameData;
import java.net.MalformedURLException;
import cpw.mods.fml.common.event.FMLLoadEvent;
import com.google.common.collect.Lists;
import cpw.mods.fml.relauncher.FMLRelaunchLog;
import java.io.IOException;
import com.google.common.collect.SetMultimap;
import com.google.common.collect.ImmutableMultiset;
import com.google.common.collect.Multiset;
import com.google.common.collect.LinkedHashMultimap;
import com.google.common.collect.Multisets;
import java.util.Comparator;
import com.google.common.collect.TreeMultimap;
import com.google.common.collect.Ordering;
import cpw.mods.fml.common.functions.ModIdFunction;
import cpw.mods.fml.common.discovery.ModDiscoverer;
import java.util.Iterator;
import com.google.common.collect.BiMap;
import cpw.mods.fml.common.toposort.ModSortingException;
import java.util.logging.Level;
import java.util.Collection;
import cpw.mods.fml.common.toposort.ModSorter;
import cpw.mods.fml.common.versioning.ArtifactVersion;
import com.google.common.collect.ImmutableList;
import java.util.Set;
import com.google.common.collect.Sets;
import com.google.common.base.Function;
import com.google.common.collect.Maps;
import cpw.mods.fml.common.functions.ArtifactVersionNameFunction;
import com.google.common.collect.HashBiMap;
import com.google.common.collect.ImmutableMap;
import java.io.File;
import java.util.Map;
import java.util.List;
import com.google.common.base.Splitter;

public class Loader
{
    private static final Splitter DEPENDENCYPARTSPLITTER;
    private static final Splitter DEPENDENCYSPLITTER;
    private static Loader instance;
    private static String major;
    private static String minor;
    private static String rev;
    private static String build;
    private static String mccversion;
    private static String mcpversion;
    private ModClassLoader modClassLoader;
    private List<ModContainer> mods;
    private Map<String, ModContainer> namedMods;
    private File canonicalConfigDir;
    private File canonicalMinecraftDir;
    private Exception capturedError;
    private File canonicalModsDir;
    private LoadController modController;
    private MinecraftDummyContainer minecraft;
    private MCPDummyContainer mcp;
    private static File minecraftDir;
    private static List<String> injectedContainers;
    private File loggingProperties;
    private ImmutableMap<String, String> fmlBrandingProperties;
    
    public static Loader instance() {
        if (Loader.instance == null) {
            Loader.instance = new Loader();
        }
        return Loader.instance;
    }
    
    public static void injectData(final Object... data) {
        Loader.major = (String)data[0];
        Loader.minor = (String)data[1];
        Loader.rev = (String)data[2];
        Loader.build = (String)data[3];
        Loader.mccversion = (String)data[4];
        Loader.mcpversion = (String)data[5];
        Loader.minecraftDir = (File)data[6];
        Loader.injectedContainers = (List)data[7];
    }
    
    private Loader() {
        this.modClassLoader = new ModClassLoader(this.getClass().getClassLoader());
        final String actualMCVersion = new c((b)null).a();
        if (!Loader.mccversion.equals(actualMCVersion)) {
            FMLLog.severe("This version of FML is built for Minecraft %s, we have detected Minecraft %s in your minecraft jar file", Loader.mccversion, actualMCVersion);
            throw new LoaderException();
        }
        this.minecraft = new MinecraftDummyContainer(actualMCVersion);
        this.mcp = new MCPDummyContainer(MetadataCollection.from(this.getClass().getResourceAsStream("/mcpmod.info"), "MCP").getMetadataForId("mcp", null));
    }
    
    private void sortModList() {
        FMLLog.finer("Verifying mod requirements are satisfied", new Object[0]);
        try {
            final BiMap<String, ArtifactVersion> modVersions = (BiMap<String, ArtifactVersion>)HashBiMap.create();
            for (final ModContainer mod : this.getActiveModList()) {
                modVersions.put((Object)mod.getModId(), (Object)mod.getProcessedVersion());
            }
            for (final ModContainer mod : this.getActiveModList()) {
                if (!mod.acceptableMinecraftVersionRange().containsVersion(this.minecraft.getProcessedVersion())) {
                    FMLLog.severe("The mod %s does not wish to run in Minecraft version %s. You will have to remove it to play.", mod.getModId(), this.getMCVersionString());
                    throw new WrongMinecraftVersionException(mod);
                }
                final Map<String, ArtifactVersion> names = (Map<String, ArtifactVersion>)Maps.uniqueIndex((Iterable)mod.getRequirements(), (Function)new ArtifactVersionNameFunction());
                final Set<ArtifactVersion> versionMissingMods = Sets.newHashSet();
                final Set<String> missingMods = (Set<String>)Sets.difference((Set)names.keySet(), modVersions.keySet());
                if (!missingMods.isEmpty()) {
                    FMLLog.severe("The mod %s (%s) requires mods %s to be available", mod.getModId(), mod.getName(), missingMods);
                    for (final String modid : missingMods) {
                        versionMissingMods.add(names.get(modid));
                    }
                    throw new MissingModsException(versionMissingMods);
                }
                final ImmutableList<ArtifactVersion> allDeps = (ImmutableList<ArtifactVersion>)ImmutableList.builder().addAll((Iterable)mod.getDependants()).addAll((Iterable)mod.getDependencies()).build();
                for (final ArtifactVersion v : allDeps) {
                    if (modVersions.containsKey((Object)v.getLabel()) && !v.containsVersion((ArtifactVersion)modVersions.get((Object)v.getLabel()))) {
                        versionMissingMods.add(v);
                    }
                }
                if (!versionMissingMods.isEmpty()) {
                    FMLLog.severe("The mod %s (%s) requires mod versions %s to be available", mod.getModId(), mod.getName(), versionMissingMods);
                    throw new MissingModsException(versionMissingMods);
                }
            }
            FMLLog.finer("All mod requirements are satisfied", new Object[0]);
            final ModSorter sorter = new ModSorter(this.getActiveModList(), this.namedMods);
            try {
                FMLLog.finer("Sorting mods into an ordered list", new Object[0]);
                final List<ModContainer> sortedMods = sorter.sort();
                this.modController.getActiveModList().clear();
                this.modController.getActiveModList().addAll(sortedMods);
                this.mods.removeAll(sortedMods);
                sortedMods.addAll(this.mods);
                this.mods = sortedMods;
                FMLLog.finer("Mod sorting completed successfully", new Object[0]);
            }
            catch (final ModSortingException sortException) {
                FMLLog.severe("A dependency cycle was detected in the input mod set so an ordering cannot be determined", new Object[0]);
                final ModSortingException.SortingExceptionData<ModContainer> exceptionData = sortException.getExceptionData();
                FMLLog.severe("The first mod in the cycle is %s", exceptionData.getFirstBadNode());
                FMLLog.severe("The mod cycle involves", new Object[0]);
                for (final ModContainer mc : exceptionData.getVisitedNodes()) {
                    FMLLog.severe("%s : before: %s, after: %s", mc.toString(), mc.getDependants(), mc.getDependencies());
                }
                FMLLog.log(Level.SEVERE, sortException, "The full error", new Object[0]);
                throw sortException;
            }
        }
        finally {
            FMLLog.fine("Mod sorting data", new Object[0]);
            int unprintedMods = this.mods.size();
            for (final ModContainer mod2 : this.getActiveModList()) {
                if (!mod2.isImmutable()) {
                    FMLLog.fine("\t%s(%s:%s): %s (%s)", mod2.getModId(), mod2.getName(), mod2.getVersion(), mod2.getSource().getName(), mod2.getSortingRules());
                    --unprintedMods;
                }
            }
            if (unprintedMods == this.mods.size()) {
                FMLLog.fine("No user mods found to sort", new Object[0]);
            }
        }
    }
    
    private ModDiscoverer identifyMods() {
        FMLLog.fine("Building injected Mod Containers %s", Loader.injectedContainers);
        this.mods.add(new InjectedModContainer(this.mcp, new File("minecraft.jar")));
        for (final String cont : Loader.injectedContainers) {
            ModContainer mc;
            try {
                mc = (ModContainer)Class.forName(cont, true, this.modClassLoader).newInstance();
            }
            catch (final Exception e) {
                FMLLog.log(Level.SEVERE, e, "A problem occured instantiating the injected mod container %s", cont);
                throw new LoaderException(e);
            }
            this.mods.add(new InjectedModContainer(mc, mc.getSource()));
        }
        final ModDiscoverer discoverer = new ModDiscoverer();
        FMLLog.fine("Attempting to load mods contained in the minecraft jar file and associated classes", new Object[0]);
        discoverer.findClasspathMods(this.modClassLoader);
        FMLLog.fine("Minecraft jar mods loaded successfully", new Object[0]);
        FMLLog.info("Searching %s for mods", this.canonicalModsDir.getAbsolutePath());
        discoverer.findModDirMods(this.canonicalModsDir);
        final File versionSpecificModsDir = new File(this.canonicalModsDir, Loader.mccversion);
        if (versionSpecificModsDir.isDirectory()) {
            FMLLog.info("Also searching %s for mods", versionSpecificModsDir);
            discoverer.findModDirMods(versionSpecificModsDir);
        }
        this.mods.addAll(discoverer.identifyMods());
        this.identifyDuplicates(this.mods);
        this.namedMods = (Map<String, ModContainer>)Maps.uniqueIndex((Iterable)this.mods, (Function)new ModIdFunction());
        FMLLog.info("Forge Mod Loader has identified %d mod%s to load", this.mods.size(), (this.mods.size() != 1) ? "s" : "");
        for (final String modId : this.namedMods.keySet()) {
            FMLLog.makeLog(modId);
        }
        return discoverer;
    }
    
    private void identifyDuplicates(final List<ModContainer> mods) {
        final TreeMultimap<ModContainer, File> dupsearch = (TreeMultimap<ModContainer, File>)TreeMultimap.create((Comparator)new ModIdComparator(), (Comparator)Ordering.arbitrary());
        for (final ModContainer mc : mods) {
            if (mc.getSource() != null) {
                dupsearch.put((Object)mc, (Object)mc.getSource());
            }
        }
        final ImmutableMultiset<ModContainer> duplist = (ImmutableMultiset<ModContainer>)Multisets.copyHighestCountFirst(dupsearch.keys());
        final SetMultimap<ModContainer, File> dupes = (SetMultimap<ModContainer, File>)LinkedHashMultimap.create();
        for (final Multiset.Entry<ModContainer> e : duplist.entrySet()) {
            if (e.getCount() > 1) {
                FMLLog.severe("Found a duplicate mod %s at %s", ((ModContainer)e.getElement()).getModId(), dupsearch.get(e.getElement()));
                dupes.putAll(e.getElement(), (Iterable)dupsearch.get(e.getElement()));
            }
        }
        if (!dupes.isEmpty()) {
            throw new DuplicateModsFoundException(dupes);
        }
    }
    
    private void initializeLoader() {
        final File modsDir = new File(Loader.minecraftDir, "mods");
        final File configDir = new File(Loader.minecraftDir, "config");
        String canonicalModsPath;
        String canonicalConfigPath;
        try {
            this.canonicalMinecraftDir = Loader.minecraftDir.getCanonicalFile();
            canonicalModsPath = modsDir.getCanonicalPath();
            canonicalConfigPath = configDir.getCanonicalPath();
            this.canonicalConfigDir = configDir.getCanonicalFile();
            this.canonicalModsDir = modsDir.getCanonicalFile();
        }
        catch (final IOException ioe) {
            FMLLog.log(Level.SEVERE, ioe, "Failed to resolve loader directories: mods : %s ; config %s", this.canonicalModsDir.getAbsolutePath(), configDir.getAbsolutePath());
            throw new LoaderException(ioe);
        }
        if (!this.canonicalModsDir.exists()) {
            FMLLog.info("No mod directory found, creating one: %s", canonicalModsPath);
            final boolean dirMade = this.canonicalModsDir.mkdir();
            if (!dirMade) {
                FMLLog.severe("Unable to create the mod directory %s", canonicalModsPath);
                throw new LoaderException();
            }
            FMLLog.info("Mod directory created successfully", new Object[0]);
        }
        if (!this.canonicalConfigDir.exists()) {
            FMLLog.fine("No config directory found, creating one: %s", canonicalConfigPath);
            final boolean dirMade = this.canonicalConfigDir.mkdir();
            if (!dirMade) {
                FMLLog.severe("Unable to create the config directory %s", canonicalConfigPath);
                throw new LoaderException();
            }
            FMLLog.info("Config directory created successfully", new Object[0]);
        }
        if (!this.canonicalModsDir.isDirectory()) {
            FMLLog.severe("Attempting to load mods from %s, which is not a directory", canonicalModsPath);
            throw new LoaderException();
        }
        if (!configDir.isDirectory()) {
            FMLLog.severe("Attempting to load configuration from %s, which is not a directory", canonicalConfigPath);
            throw new LoaderException();
        }
        this.loggingProperties = new File(this.canonicalConfigDir, "logging.properties");
        FMLLog.info("Reading custom logging properties from %s", this.loggingProperties.getPath());
        FMLRelaunchLog.loadLogConfiguration(this.loggingProperties);
        FMLLog.log(Level.OFF, "Logging level for ForgeModLoader logging is set to %s", FMLRelaunchLog.log.getLogger().getLevel());
    }
    
    public List<ModContainer> getModList() {
        return (List<ModContainer>)((instance().mods != null) ? ImmutableList.copyOf((Collection)instance().mods) : ImmutableList.of());
    }
    
    public void loadMods() {
        this.initializeLoader();
        this.mods = Lists.newArrayList();
        this.namedMods = Maps.newHashMap();
        (this.modController = new LoadController(this)).transition(LoaderState.LOADING, false);
        final ModDiscoverer disc = this.identifyMods();
        ModAPIManager.INSTANCE.manageAPI(this.modClassLoader, disc);
        this.disableRequestedMods();
        FMLLog.fine("Reloading logging properties from %s", this.loggingProperties.getPath());
        FMLRelaunchLog.loadLogConfiguration(this.loggingProperties);
        FMLLog.fine("Reloaded logging properties", new Object[0]);
        this.modController.distributeStateMessage(FMLLoadEvent.class);
        this.sortModList();
        ModAPIManager.INSTANCE.cleanupAPIContainers(this.modController.getActiveModList());
        ModAPIManager.INSTANCE.cleanupAPIContainers(this.mods);
        this.mods = (List<ModContainer>)ImmutableList.copyOf((Collection)this.mods);
        for (final File nonMod : disc.getNonModLibs()) {
            if (nonMod.isFile()) {
                FMLLog.info("FML has found a non-mod file %s in your mods directory. It will now be injected into your classpath. This could severe stability issues, it should be removed if possible.", nonMod.getName());
                try {
                    this.modClassLoader.addFile(nonMod);
                }
                catch (final MalformedURLException e) {
                    FMLLog.log(Level.SEVERE, e, "Encountered a weird problem with non-mod file injection : %s", nonMod.getName());
                }
            }
        }
        this.modController.transition(LoaderState.CONSTRUCTING, false);
        this.modController.distributeStateMessage(LoaderState.CONSTRUCTING, this.modClassLoader, disc.getASMTable());
        FMLLog.fine("Mod signature data", new Object[0]);
        for (final ModContainer mod : this.getActiveModList()) {
            FMLLog.fine("\t%s(%s:%s): %s (%s)", mod.getModId(), mod.getName(), mod.getVersion(), mod.getSource().getName(), CertificateHelper.getFingerprint(mod.getSigningCertificate()));
        }
        if (this.getActiveModList().isEmpty()) {
            FMLLog.fine("No user mod signature data found", new Object[0]);
        }
        this.modController.transition(LoaderState.PREINITIALIZATION, false);
        this.modController.distributeStateMessage(LoaderState.PREINITIALIZATION, disc.getASMTable(), this.canonicalConfigDir);
        this.modController.transition(LoaderState.INITIALIZATION, false);
        GameData.validateRegistry();
    }
    
    private void disableRequestedMods() {
        final String forcedModList = System.getProperty("fml.modStates", "");
        FMLLog.finer("Received a system property request '%s'", forcedModList);
        final Map<String, String> sysPropertyStateList = Splitter.on(CharMatcher.anyOf((CharSequence)";:")).omitEmptyStrings().trimResults().withKeyValueSeparator("=").split((CharSequence)forcedModList);
        FMLLog.finer("System property request managing the state of %d mods", sysPropertyStateList.size());
        final Map<String, String> modStates = Maps.newHashMap();
        final File forcedModFile = new File(this.canonicalConfigDir, "fmlModState.properties");
        final Properties forcedModListProperties = new Properties();
        if (forcedModFile.exists() && forcedModFile.isFile()) {
            FMLLog.finer("Found a mod state file %s", forcedModFile.getName());
            try {
                forcedModListProperties.load(new FileReader(forcedModFile));
                FMLLog.finer("Loaded states for %d mods from file", forcedModListProperties.size());
            }
            catch (final Exception e) {
                FMLLog.log(Level.INFO, e, "An error occurred reading the fmlModState.properties file", new Object[0]);
            }
        }
        modStates.putAll((Map<? extends String, ? extends String>)Maps.fromProperties(forcedModListProperties));
        modStates.putAll(sysPropertyStateList);
        FMLLog.fine("After merging, found state information for %d mods", modStates.size());
        final Map<String, Boolean> isEnabled = Maps.transformValues((Map)modStates, (Function)new Function<String, Boolean>() {
            public Boolean apply(final String input) {
                return Boolean.parseBoolean(input);
            }
        });
        for (final Map.Entry<String, Boolean> entry : isEnabled.entrySet()) {
            if (this.namedMods.containsKey(entry.getKey())) {
                FMLLog.info("Setting mod %s to enabled state %b", entry.getKey(), entry.getValue());
                this.namedMods.get(entry.getKey()).setEnabledState(entry.getValue());
            }
        }
    }
    
    public static boolean isModLoaded(final String modname) {
        return instance().namedMods.containsKey(modname) && instance().modController.getModState(Loader.instance.namedMods.get(modname)) != LoaderState.ModState.DISABLED;
    }
    
    public File getConfigDir() {
        return this.canonicalConfigDir;
    }
    
    public String getCrashInformation() {
        if (this.modController == null) {
            return "";
        }
        final StringBuilder ret = new StringBuilder();
        final List<String> branding = FMLCommonHandler.instance().getBrandings();
        Joiner.on(' ').skipNulls().appendTo(ret, (Iterable)branding.subList(1, branding.size()));
        if (this.modController != null) {
            this.modController.printModStates(ret);
        }
        return ret.toString();
    }
    
    public String getFMLVersionString() {
        return String.format("%s.%s.%s.%s", Loader.major, Loader.minor, Loader.rev, Loader.build);
    }
    
    public ClassLoader getModClassLoader() {
        return this.modClassLoader;
    }
    
    public void computeDependencies(final String dependencyString, final Set<ArtifactVersion> requirements, final List<ArtifactVersion> dependencies, final List<ArtifactVersion> dependants) {
        if (dependencyString == null || dependencyString.length() == 0) {
            return;
        }
        boolean parseFailure = false;
        for (final String dep : Loader.DEPENDENCYSPLITTER.split((CharSequence)dependencyString)) {
            final List<String> depparts = Lists.newArrayList(Loader.DEPENDENCYPARTSPLITTER.split((CharSequence)dep));
            if (depparts.size() != 2) {
                parseFailure = true;
            }
            else {
                final String instruction = depparts.get(0);
                final String target = depparts.get(1);
                final boolean targetIsAll = target.startsWith("*");
                if (targetIsAll && target.length() > 1) {
                    parseFailure = true;
                }
                else {
                    if ("required-before".equals(instruction) || "required-after".equals(instruction)) {
                        if (targetIsAll) {
                            parseFailure = true;
                            continue;
                        }
                        requirements.add(VersionParser.parseVersionReference(target));
                    }
                    if (targetIsAll && target.indexOf(64) > -1) {
                        parseFailure = true;
                    }
                    else if ("required-before".equals(instruction) || "before".equals(instruction)) {
                        dependants.add(VersionParser.parseVersionReference(target));
                    }
                    else if ("required-after".equals(instruction) || "after".equals(instruction)) {
                        dependencies.add(VersionParser.parseVersionReference(target));
                    }
                    else {
                        parseFailure = true;
                    }
                }
            }
        }
        if (parseFailure) {
            FMLLog.log(Level.WARNING, "Unable to parse dependency string %s", dependencyString);
            throw new LoaderException();
        }
    }
    
    public Map<String, ModContainer> getIndexedModList() {
        return (Map<String, ModContainer>)ImmutableMap.copyOf((Map)this.namedMods);
    }
    
    public void initializeMods() {
        this.modController.distributeStateMessage(LoaderState.INITIALIZATION, new Object[0]);
        this.modController.transition(LoaderState.POSTINITIALIZATION, false);
        GameData.buildModObjectTable();
        this.modController.distributeStateMessage(FMLInterModComms.IMCEvent.class);
        this.modController.distributeStateMessage(LoaderState.POSTINITIALIZATION, new Object[0]);
        this.modController.transition(LoaderState.AVAILABLE, false);
        this.modController.distributeStateMessage(LoaderState.AVAILABLE, new Object[0]);
        GameData.dumpRegistry(Loader.minecraftDir);
        FMLLog.info("Forge Mod Loader has successfully loaded %d mod%s", this.mods.size(), (this.mods.size() == 1) ? "" : "s");
    }
    
    public ICrashCallable getCallableCrashInformation() {
        return new ICrashCallable() {
            @Override
            public String call() throws Exception {
                return Loader.this.getCrashInformation();
            }
            
            @Override
            public String getLabel() {
                return "FML";
            }
        };
    }
    
    public List<ModContainer> getActiveModList() {
        return (List<ModContainer>)((this.modController != null) ? this.modController.getActiveModList() : ImmutableList.of());
    }
    
    public LoaderState.ModState getModState(final ModContainer selectedMod) {
        return this.modController.getModState(selectedMod);
    }
    
    public String getMCVersionString() {
        return "Minecraft " + Loader.mccversion;
    }
    
    public boolean serverStarting(final Object server) {
        try {
            this.modController.distributeStateMessage(LoaderState.SERVER_STARTING, server);
            this.modController.transition(LoaderState.SERVER_STARTING, false);
        }
        catch (final Throwable t) {
            FMLLog.log(Level.SEVERE, t, "A fatal exception occurred during the server starting event", new Object[0]);
            return false;
        }
        return true;
    }
    
    public void serverStarted() {
        this.modController.distributeStateMessage(LoaderState.SERVER_STARTED, new Object[0]);
        this.modController.transition(LoaderState.SERVER_STARTED, false);
    }
    
    public void serverStopping() {
        this.modController.distributeStateMessage(LoaderState.SERVER_STOPPING, new Object[0]);
        this.modController.transition(LoaderState.SERVER_STOPPING, false);
    }
    
    public BiMap<ModContainer, Object> getModObjectList() {
        return this.modController.getModObjectList();
    }
    
    public BiMap<Object, ModContainer> getReversedModObjectList() {
        return (BiMap<Object, ModContainer>)this.getModObjectList().inverse();
    }
    
    public ModContainer activeModContainer() {
        return (this.modController != null) ? this.modController.activeContainer() : null;
    }
    
    public boolean isInState(final LoaderState state) {
        return this.modController.isInState(state);
    }
    
    public MinecraftDummyContainer getMinecraftModContainer() {
        return this.minecraft;
    }
    
    public boolean hasReachedState(final LoaderState state) {
        return this.modController != null && this.modController.hasReachedState(state);
    }
    
    public String getMCPVersionString() {
        return String.format("MCP v%s", Loader.mcpversion);
    }
    
    public void serverStopped() {
        this.modController.distributeStateMessage(LoaderState.SERVER_STOPPED, new Object[0]);
        this.modController.transition(LoaderState.SERVER_STOPPED, true);
        this.modController.transition(LoaderState.AVAILABLE, true);
    }
    
    public boolean serverAboutToStart(final Object server) {
        try {
            this.modController.distributeStateMessage(LoaderState.SERVER_ABOUT_TO_START, server);
            this.modController.transition(LoaderState.SERVER_ABOUT_TO_START, false);
        }
        catch (final Throwable t) {
            FMLLog.log(Level.SEVERE, t, "A fatal exception occurred during the server about to start event", new Object[0]);
            return false;
        }
        return true;
    }
    
    public Map<String, String> getFMLBrandingProperties() {
        if (this.fmlBrandingProperties == null) {
            final Properties loaded = new Properties();
            try {
                loaded.load(this.getClass().getClassLoader().getResourceAsStream("fmlbranding.properties"));
            }
            catch (final Exception ex) {}
            this.fmlBrandingProperties = (ImmutableMap<String, String>)Maps.fromProperties(loaded);
        }
        return (Map<String, String>)this.fmlBrandingProperties;
    }
    
    public Map<String, String> getCustomModProperties(final String modId) {
        return this.getIndexedModList().get(modId).getCustomModProperties();
    }
    
    static {
        DEPENDENCYPARTSPLITTER = Splitter.on(":").omitEmptyStrings().trimResults();
        DEPENDENCYSPLITTER = Splitter.on(";").omitEmptyStrings().trimResults();
    }
    
    private class ModIdComparator implements Comparator<ModContainer>
    {
        @Override
        public int compare(final ModContainer o1, final ModContainer o2) {
            return o1.getModId().compareTo(o2.getModId());
        }
    }
}



================================================
FILE: cpw/mods/fml/common/LoaderException.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

public class LoaderException extends RuntimeException
{
    private static final long serialVersionUID = -5675297950958861378L;
    
    public LoaderException(final Throwable wrapped) {
        super(wrapped);
    }
    
    public LoaderException() {
    }
}



================================================
FILE: cpw/mods/fml/common/LoaderState.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import cpw.mods.fml.common.event.FMLServerStoppedEvent;
import cpw.mods.fml.common.event.FMLServerStoppingEvent;
import cpw.mods.fml.common.event.FMLServerStartedEvent;
import cpw.mods.fml.common.event.FMLServerStartingEvent;
import cpw.mods.fml.common.event.FMLServerAboutToStartEvent;
import cpw.mods.fml.common.event.FMLLoadCompleteEvent;
import cpw.mods.fml.common.event.FMLPostInitializationEvent;
import cpw.mods.fml.common.event.FMLInitializationEvent;
import cpw.mods.fml.common.event.FMLPreInitializationEvent;
import cpw.mods.fml.common.event.FMLConstructionEvent;
import com.google.common.base.Throwables;
import cpw.mods.fml.common.event.FMLStateEvent;

public enum LoaderState
{
    NOINIT("Uninitialized", (Class<? extends FMLStateEvent>)null), 
    LOADING("Loading", (Class<? extends FMLStateEvent>)null), 
    CONSTRUCTING("Constructing mods", (Class<? extends FMLStateEvent>)FMLConstructionEvent.class), 
    PREINITIALIZATION("Pre-initializing mods", (Class<? extends FMLStateEvent>)FMLPreInitializationEvent.class), 
    INITIALIZATION("Initializing mods", (Class<? extends FMLStateEvent>)FMLInitializationEvent.class), 
    POSTINITIALIZATION("Post-initializing mods", (Class<? extends FMLStateEvent>)FMLPostInitializationEvent.class), 
    AVAILABLE("Mod loading complete", (Class<? extends FMLStateEvent>)FMLLoadCompleteEvent.class), 
    SERVER_ABOUT_TO_START("Server about to start", (Class<? extends FMLStateEvent>)FMLServerAboutToStartEvent.class), 
    SERVER_STARTING("Server starting", (Class<? extends FMLStateEvent>)FMLServerStartingEvent.class), 
    SERVER_STARTED("Server started", (Class<? extends FMLStateEvent>)FMLServerStartedEvent.class), 
    SERVER_STOPPING("Server stopping", (Class<? extends FMLStateEvent>)FMLServerStoppingEvent.class), 
    SERVER_STOPPED("Server stopped", (Class<? extends FMLStateEvent>)FMLServerStoppedEvent.class), 
    ERRORED("Mod Loading errored", (Class<? extends FMLStateEvent>)null);
    
    private Class<? extends FMLStateEvent> eventClass;
    private String name;
    
    private LoaderState(final String name, final Class<? extends FMLStateEvent> event) {
        this.name = name;
        this.eventClass = event;
    }
    
    public LoaderState transition(final boolean errored) {
        if (errored) {
            return LoaderState.ERRORED;
        }
        if (this == LoaderState.SERVER_STOPPED) {
            return LoaderState.AVAILABLE;
        }
        return values()[(this.ordinal() < values().length) ? (this.ordinal() + 1) : this.ordinal()];
    }
    
    public boolean hasEvent() {
        return this.eventClass != null;
    }
    
    public FMLStateEvent getEvent(final Object... eventData) {
        try {
            return (FMLStateEvent)this.eventClass.getConstructor(Object[].class).newInstance(eventData);
        }
        catch (final Exception e) {
            throw Throwables.propagate((Throwable)e);
        }
    }
    
    public LoaderState requiredState() {
        if (this == LoaderState.NOINIT) {
            return LoaderState.NOINIT;
        }
        return values()[this.ordinal() - 1];
    }
    
    public enum ModState
    {
        UNLOADED("Unloaded"), 
        LOADED("Loaded"), 
        CONSTRUCTED("Constructed"), 
        PREINITIALIZED("Pre-initialized"), 
        INITIALIZED("Initialized"), 
        POSTINITIALIZED("Post-initialized"), 
        AVAILABLE("Available"), 
        DISABLED("Disabled"), 
        ERRORED("Errored");
        
        private String label;
        
        private ModState(final String label) {
            this.label = label;
        }
        
        @Override
        public String toString() {
            return this.label;
        }
    }
}



================================================
FILE: cpw/mods/fml/common/MCPDummyContainer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import com.google.common.eventbus.EventBus;

public class MCPDummyContainer extends DummyModContainer
{
    public MCPDummyContainer(final ModMetadata metadata) {
        super(metadata);
    }
    
    @Override
    public boolean registerBus(final EventBus bus, final LoadController controller) {
        return true;
    }
}



================================================
FILE: cpw/mods/fml/common/MetadataCollection.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.util.Iterator;
import argo.jdom.JsonNode;
import argo.jdom.JsonRootNode;
import com.google.common.base.Throwables;
import argo.saj.InvalidSyntaxException;
import java.util.logging.Level;
import java.io.Reader;
import java.io.InputStreamReader;
import java.io.InputStream;
import com.google.common.collect.Maps;
import java.util.Map;
import argo.jdom.JdomParser;

public class MetadataCollection
{
    private static JdomParser parser;
    private Map<String, ModMetadata> metadatas;
    private int metadataVersion;
    
    public MetadataCollection() {
        this.metadatas = Maps.newHashMap();
        this.metadataVersion = 1;
    }
    
    public static MetadataCollection from(final InputStream inputStream, final String sourceName) {
        if (inputStream == null) {
            return new MetadataCollection();
        }
        final InputStreamReader reader = new InputStreamReader(inputStream);
        try {
            final JsonRootNode root = MetadataCollection.parser.parse((Reader)reader);
            if (root.hasElements()) {
                return parse10ModInfo(root);
            }
            return parseModInfo(root);
        }
        catch (final InvalidSyntaxException e) {
            FMLLog.log(Level.SEVERE, (Throwable)e, "The mcmod.info file in %s cannot be parsed as valid JSON. It will be ignored", sourceName);
            return new MetadataCollection();
        }
        catch (final Exception e2) {
            throw Throwables.propagate((Throwable)e2);
        }
    }
    
    private static MetadataCollection parseModInfo(final JsonRootNode root) {
        final MetadataCollection mc = new MetadataCollection();
        mc.metadataVersion = Integer.parseInt(root.getNumberValue(new Object[] { "modinfoversion" }));
        mc.parseModMetadataList(root.getNode(new Object[] { "modlist" }));
        return mc;
    }
    
    private static MetadataCollection parse10ModInfo(final JsonRootNode root) {
        final MetadataCollection mc = new MetadataCollection();
        mc.parseModMetadataList((JsonNode)root);
        return mc;
    }
    
    private void parseModMetadataList(final JsonNode metadataList) {
        for (final JsonNode node : metadataList.getElements()) {
            final ModMetadata mmd = new ModMetadata(node);
            this.metadatas.put(mmd.modId, mmd);
        }
    }
    
    public ModMetadata getMetadataForId(final String modId, final Map<String, Object> extraData) {
        if (!this.metadatas.containsKey(modId)) {
            final ModMetadata dummy = new ModMetadata();
            dummy.modId = modId;
            dummy.name = extraData.get("name");
            dummy.version = extraData.get("version");
            dummy.autogenerated = true;
            this.metadatas.put(modId, dummy);
        }
        return this.metadatas.get(modId);
    }
    
    static {
        MetadataCollection.parser = new JdomParser();
    }
}



================================================
FILE: cpw/mods/fml/common/MinecraftDummyContainer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import cpw.mods.fml.common.versioning.VersionParser;
import cpw.mods.fml.common.versioning.VersionRange;

public class MinecraftDummyContainer extends DummyModContainer
{
    private VersionRange staticRange;
    
    public MinecraftDummyContainer(final String actualMCVersion) {
        super(new ModMetadata());
        this.getMetadata().modId = "Minecraft";
        this.getMetadata().name = "Minecraft";
        this.getMetadata().version = actualMCVersion;
        this.staticRange = VersionParser.parseRange("[" + actualMCVersion + "]");
    }
    
    public VersionRange getStaticVersionRange() {
        return this.staticRange;
    }
}



================================================
FILE: cpw/mods/fml/common/MissingModsException.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import cpw.mods.fml.common.versioning.ArtifactVersion;
import java.util.Set;

public class MissingModsException extends RuntimeException
{
    public Set<ArtifactVersion> missingMods;
    
    public MissingModsException(final Set<ArtifactVersion> missingMods) {
        this.missingMods = missingMods;
    }
}



================================================
FILE: cpw/mods/fml/common/Mod.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Retention;

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE })
public @interface Mod {
    String modid();
    
    String name() default "";
    
    String version() default "";
    
    String dependencies() default "";
    
    boolean useMetadata() default false;
    
    String acceptedMinecraftVersions() default "";
    
    String bukkitPlugin() default "";
    
    @Deprecated
    String modExclusionList() default "";
    
    String certificateFingerprint() default "";
    
    String modLanguage() default "java";
    
    @Deprecated
    String asmHookClass() default "";
    
    CustomProperty[] customProperties() default {};
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.METHOD })
    public @interface InstanceFactory {
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.FIELD })
    @Deprecated
    public @interface Item {
        String name();
        
        String typeClass();
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.FIELD })
    @Deprecated
    public @interface Block {
        String name();
        
        Class<?> itemTypeClass() default zh.class;
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.FIELD })
    public @interface Metadata {
        String value() default "";
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.FIELD })
    public @interface Instance {
        String value() default "";
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.METHOD })
    @Deprecated
    public @interface IMCCallback {
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.METHOD })
    @Deprecated
    public @interface ServerStopped {
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.METHOD })
    @Deprecated
    public @interface ServerStopping {
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.METHOD })
    @Deprecated
    public @interface ServerStarted {
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.METHOD })
    @Deprecated
    public @interface ServerStarting {
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.METHOD })
    @Deprecated
    public @interface ServerAboutToStart {
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.METHOD })
    @Deprecated
    public @interface PostInit {
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.METHOD })
    @Deprecated
    public @interface Init {
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.METHOD })
    @Deprecated
    public @interface PreInit {
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.METHOD })
    @Deprecated
    public @interface FingerprintWarning {
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.METHOD })
    public @interface EventHandler {
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({})
    public @interface CustomProperty {
        String k();
        
        String v();
    }
}



================================================
FILE: cpw/mods/fml/common/ModAPIManager.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Sets;
import cpw.mods.fml.common.versioning.DefaultArtifactVersion;
import java.io.File;
import cpw.mods.fml.common.discovery.ModDiscoverer;
import cpw.mods.fml.common.versioning.ArtifactVersion;
import java.util.Iterator;
import java.util.Set;
import java.util.Collection;
import com.google.common.base.Function;
import java.util.List;
import com.google.common.collect.Lists;
import cpw.mods.fml.common.functions.ModIdFunction;
import cpw.mods.fml.common.discovery.ModCandidate;
import cpw.mods.fml.common.versioning.VersionParser;
import com.google.common.collect.Maps;
import java.util.Map;
import cpw.mods.fml.common.discovery.ASMDataTable;
import cpw.mods.fml.common.asm.transformers.ModAPITransformer;

public class ModAPIManager
{
    public static final ModAPIManager INSTANCE;
    private ModAPITransformer transformer;
    private ASMDataTable dataTable;
    private Map<String, APIContainer> apiContainers;
    
    public void registerDataTableAndParseAPI(final ASMDataTable dataTable) {
        this.dataTable = dataTable;
        final Set<ASMDataTable.ASMData> apiList = dataTable.getAll("cpw.mods.fml.common.API");
        this.apiContainers = Maps.newHashMap();
        for (final ASMDataTable.ASMData data : apiList) {
            final Map<String, Object> annotationInfo = data.getAnnotationInfo();
            final String apiPackage = data.getClassName().substring(0, data.getClassName().indexOf(".package-info"));
            final String providedAPI = annotationInfo.get("provides");
            final String apiOwner = annotationInfo.get("owner");
            final String apiVersion = annotationInfo.get("apiVersion");
            APIContainer container = this.apiContainers.get(providedAPI);
            if (container == null) {
                container = new APIContainer(providedAPI, apiVersion, data.getCandidate().getModContainer(), VersionParser.parseVersionReference(apiOwner));
                this.apiContainers.put(providedAPI, container);
            }
            else {
                container.validate(providedAPI, apiOwner, apiVersion);
            }
            container.addOwnedPackage(apiPackage);
            for (final ModContainer mc : data.getCandidate().getContainedMods()) {
                final String embeddedIn = mc.getModId();
                if (container.currentReferents.contains(embeddedIn)) {
                    continue;
                }
                FMLLog.fine("Found API %s (owned by %s providing %s) embedded in %s", apiPackage, apiOwner, providedAPI, embeddedIn);
                if (embeddedIn.equals(apiOwner)) {
                    continue;
                }
                container.addAPIReference(embeddedIn);
            }
        }
        for (final APIContainer container2 : this.apiContainers.values()) {
            for (final String pkg : container2.packages) {
                final Set<ModCandidate> candidates = dataTable.getCandidatesFor(pkg);
                for (final ModCandidate candidate : candidates) {
                    final List<String> candidateIds = Lists.transform((List)candidate.getContainedMods(), (Function)new ModIdFunction());
                    if (!candidateIds.contains(container2.ownerMod.getLabel()) && !container2.currentReferents.containsAll(candidateIds)) {
                        FMLLog.info("Found mod(s) %s containing declared API package %s (owned by %s) without associated API reference", candidateIds, pkg, container2.ownerMod);
                        container2.addAPIReferences(candidateIds);
                    }
                }
            }
            if (this.apiContainers.containsKey(container2.ownerMod.getLabel())) {
                ArtifactVersion owner = container2.ownerMod;
                do {
                    final APIContainer parent = this.apiContainers.get(owner.getLabel());
                    FMLLog.finest("Removing upstream parent %s from %s", parent.ownerMod.getLabel(), container2);
                    container2.currentReferents.remove(parent.ownerMod.getLabel());
                    container2.referredMods.remove(parent.ownerMod);
                    owner = parent.ownerMod;
                } while (this.apiContainers.containsKey(owner.getLabel()));
            }
            FMLLog.fine("Creating API container dummy for API %s: owner: %s, dependents: %s", container2.providedAPI, container2.ownerMod, container2.referredMods);
        }
    }
    
    public void manageAPI(final ModClassLoader modClassLoader, final ModDiscoverer discoverer) {
        this.registerDataTableAndParseAPI(discoverer.getASMTable());
        this.transformer = modClassLoader.addModAPITransformer(this.dataTable);
    }
    
    public void injectAPIModContainers(final List<ModContainer> mods, final Map<String, ModContainer> nameLookup) {
        mods.addAll(this.apiContainers.values());
        nameLookup.putAll(this.apiContainers);
    }
    
    public void cleanupAPIContainers(final List<ModContainer> mods) {
        mods.removeAll(this.apiContainers.values());
    }
    
    public boolean hasAPI(final String modId) {
        return this.apiContainers.containsKey(modId);
    }
    
    static {
        INSTANCE = new ModAPIManager();
    }
    
    private static class APIContainer extends DummyModContainer
    {
        private List<ArtifactVersion> referredMods;
        private ArtifactVersion ownerMod;
        private ArtifactVersion ourVersion;
        private String providedAPI;
        private File source;
        private String version;
        private Set<String> currentReferents;
        private Set<String> packages;
        
        public APIContainer(final String providedAPI, final String apiVersion, final File source, final ArtifactVersion ownerMod) {
            this.providedAPI = providedAPI;
            this.version = apiVersion;
            this.ownerMod = ownerMod;
            this.ourVersion = new DefaultArtifactVersion(providedAPI, apiVersion);
            this.referredMods = Lists.newArrayList();
            this.source = source;
            this.currentReferents = Sets.newHashSet();
            this.packages = Sets.newHashSet();
        }
        
        @Override
        public File getSource() {
            return this.source;
        }
        
        @Override
        public String getVersion() {
            return this.version;
        }
        
        @Override
        public String getName() {
            return "API: " + this.providedAPI;
        }
        
        @Override
        public String getModId() {
            return "API:" + this.providedAPI;
        }
        
        @Override
        public List<ArtifactVersion> getDependants() {
            return this.referredMods;
        }
        
        @Override
        public List<ArtifactVersion> getDependencies() {
            return (List<ArtifactVersion>)ImmutableList.of((Object)this.ownerMod);
        }
        
        @Override
        public ArtifactVersion getProcessedVersion() {
            return this.ourVersion;
        }
        
        public void validate(final String providedAPI, final String apiOwner, final String apiVersion) {
        }
        
        @Override
        public String toString() {
            return "APIContainer{" + this.providedAPI + ":" + this.version + "}";
        }
        
        public void addAPIReference(final String embedded) {
            if (this.currentReferents.add(embedded)) {
                this.referredMods.add(VersionParser.parseVersionReference(embedded));
            }
        }
        
        public void addOwnedPackage(final String apiPackage) {
            this.packages.add(apiPackage);
        }
        
        public void addAPIReferences(final List<String> candidateIds) {
            for (final String modId : candidateIds) {
                this.addAPIReference(modId);
            }
        }
    }
}



================================================
FILE: cpw/mods/fml/common/ModClassLoader.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import com.google.common.collect.ImmutableList;
import cpw.mods.fml.common.asm.transformers.ModAPITransformer;
import cpw.mods.fml.common.discovery.ASMDataTable;
import java.util.Set;
import java.util.Iterator;
import cpw.mods.fml.common.asm.transformers.AccessTransformer;
import net.minecraft.launchwrapper.IClassTransformer;
import cpw.mods.fml.common.modloader.BaseModProxy;
import java.net.URISyntaxException;
import java.util.logging.Level;
import java.net.MalformedURLException;
import java.io.File;
import java.net.URL;
import net.minecraft.launchwrapper.LaunchClassLoader;
import java.util.List;
import java.net.URLClassLoader;

public class ModClassLoader extends URLClassLoader
{
    private static final List<String> STANDARD_LIBRARIES;
    private LaunchClassLoader mainClassLoader;
    
    public ModClassLoader(final ClassLoader parent) {
        super(new URL[0], (ClassLoader)null);
        this.mainClassLoader = (LaunchClassLoader)parent;
    }
    
    public void addFile(final File modFile) throws MalformedURLException {
        final URL url = modFile.toURI().toURL();
        this.mainClassLoader.addURL(url);
    }
    
    @Override
    public Class<?> loadClass(final String name) throws ClassNotFoundException {
        return this.mainClassLoader.loadClass(name);
    }
    
    public File[] getParentSources() {
        final List<URL> urls = this.mainClassLoader.getSources();
        final File[] sources = new File[urls.size()];
        try {
            for (int i = 0; i < urls.size(); ++i) {
                sources[i] = new File(urls.get(i).toURI());
            }
            return sources;
        }
        catch (final URISyntaxException e) {
            FMLLog.log(Level.SEVERE, e, "Unable to process our input to locate the minecraft code", new Object[0]);
            throw new LoaderException(e);
        }
    }
    
    public List<String> getDefaultLibraries() {
        return ModClassLoader.STANDARD_LIBRARIES;
    }
    
    public Class<? extends BaseModProxy> loadBaseModClass(final String modClazzName) throws Exception {
        AccessTransformer accessTransformer = null;
        for (final IClassTransformer transformer : this.mainClassLoader.getTransformers()) {
            if (transformer instanceof AccessTransformer) {
                accessTransformer = (AccessTransformer)transformer;
                break;
            }
        }
        if (accessTransformer == null) {
            FMLLog.log(Level.SEVERE, "No access transformer found", new Object[0]);
            throw new LoaderException();
        }
        accessTransformer.ensurePublicAccessFor(modClazzName);
        return (Class<? extends BaseModProxy>)Class.forName(modClazzName, true, this);
    }
    
    public void clearNegativeCacheFor(final Set<String> classList) {
        this.mainClassLoader.clearNegativeEntries((Set)classList);
    }
    
    public ModAPITransformer addModAPITransformer(final ASMDataTable dataTable) {
        this.mainClassLoader.registerTransformer("cpw.mods.fml.common.asm.transformers.ModAPITransformer");
        final List<IClassTransformer> transformers = this.mainClassLoader.getTransformers();
        final ModAPITransformer modAPI = (ModAPITransformer)transformers.get(transformers.size() - 1);
        modAPI.initTable(dataTable);
        return modAPI;
    }
    
    static {
        STANDARD_LIBRARIES = (List)ImmutableList.of((Object)"jinput.jar", (Object)"lwjgl.jar", (Object)"lwjgl_util.jar");
    }
}



================================================
FILE: cpw/mods/fml/common/ModContainer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import com.google.common.collect.ImmutableMap;
import java.security.cert.Certificate;
import cpw.mods.fml.common.versioning.VersionRange;
import com.google.common.eventbus.EventBus;
import java.util.List;
import cpw.mods.fml.common.versioning.ArtifactVersion;
import java.util.Set;
import java.io.File;
import java.util.Map;

public interface ModContainer
{
    public static final Map<String, String> EMPTY_PROPERTIES = ImmutableMap.of();
    
    String getModId();
    
    String getName();
    
    String getVersion();
    
    File getSource();
    
    ModMetadata getMetadata();
    
    void bindMetadata(final MetadataCollection p0);
    
    void setEnabledState(final boolean p0);
    
    Set<ArtifactVersion> getRequirements();
    
    List<ArtifactVersion> getDependencies();
    
    List<ArtifactVersion> getDependants();
    
    String getSortingRules();
    
    boolean registerBus(final EventBus p0, final LoadController p1);
    
    boolean matches(final Object p0);
    
    Object getMod();
    
    ArtifactVersion getProcessedVersion();
    
    boolean isImmutable();
    
    boolean isNetworkMod();
    
    String getDisplayVersion();
    
    VersionRange acceptableMinecraftVersionRange();
    
    Certificate getSigningCertificate();
    
    Map<String, String> getCustomModProperties();
    
    Class<?> getCustomResourcePackClass();
    
    Map<String, String> getSharedModDescriptor();
}



================================================
FILE: cpw/mods/fml/common/ModContainerFactory.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.util.Iterator;
import org.objectweb.asm.Type;
import cpw.mods.fml.common.discovery.asm.ModAnnotation;
import cpw.mods.fml.common.modloader.ModLoaderModContainer;
import cpw.mods.fml.common.discovery.ModCandidate;
import java.io.File;
import cpw.mods.fml.common.discovery.asm.ASMModParser;
import java.util.regex.Pattern;

public class ModContainerFactory
{
    private static Pattern modClass;
    private static ModContainerFactory INSTANCE;
    
    public static ModContainerFactory instance() {
        return ModContainerFactory.INSTANCE;
    }
    
    public ModContainer build(final ASMModParser modParser, final File modSource, final ModCandidate container) {
        final String className = modParser.getASMType().getClassName();
        if (modParser.isBaseMod(container.getRememberedBaseMods()) && ModContainerFactory.modClass.matcher(className).find()) {
            FMLLog.fine("Identified a BaseMod type mod %s", className);
            return new ModLoaderModContainer(className, modSource, modParser.getBaseModProperties());
        }
        if (ModContainerFactory.modClass.matcher(className).find()) {
            FMLLog.fine("Identified a class %s following modloader naming convention but not directly a BaseMod or currently seen subclass", className);
            container.rememberModCandidateType(modParser);
        }
        else if (modParser.isBaseMod(container.getRememberedBaseMods())) {
            FMLLog.fine("Found a basemod %s of non-standard naming format", className);
            container.rememberBaseModType(className);
        }
        if (className.startsWith("net.minecraft.src.") && container.isClasspath() && !container.isMinecraftJar()) {
            FMLLog.severe("FML has detected a mod that is using a package name based on 'net.minecraft.src' : %s. This is generally a severe programming error.  There should be no mod code in the minecraft namespace. MOVE YOUR MOD! If you're in eclipse, select your source code and 'refactor' it into a new package. Go on. DO IT NOW!", className);
        }
        for (final ModAnnotation ann : modParser.getAnnotations()) {
            if (ann.getASMType().equals((Object)Type.getType((Class)Mod.class))) {
                FMLLog.fine("Identified an FMLMod type mod %s", className);
                return new FMLModContainer(className, container, ann.getValues());
            }
        }
        return null;
    }
    
    static {
        ModContainerFactory.modClass = Pattern.compile(".*(\\.|)(mod\\_[^\\s$]+)$");
        ModContainerFactory.INSTANCE = new ModContainerFactory();
    }
}



================================================
FILE: cpw/mods/fml/common/ModMetadata.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import cpw.mods.fml.common.functions.ModNameFunction;
import com.google.common.base.Joiner;
import java.util.Iterator;
import cpw.mods.fml.common.versioning.VersionParser;
import java.util.Collection;
import argo.jdom.JsonStringNode;
import java.util.Map;
import java.util.ArrayList;
import java.util.HashSet;
import com.google.common.base.Objects;
import java.util.logging.Level;
import com.google.common.base.Strings;
import argo.jdom.JsonNodeBuilders;
import com.google.common.base.Function;
import com.google.common.collect.Maps;
import com.google.common.collect.Lists;
import argo.jdom.JsonNode;
import cpw.mods.fml.common.versioning.ArtifactVersion;
import java.util.Set;
import java.util.List;

public class ModMetadata
{
    public String modId;
    public String name;
    public String description;
    public String url;
    public String updateUrl;
    public String logoFile;
    public String version;
    public List<String> authorList;
    public String credits;
    public String parent;
    public String[] screenshots;
    public ModContainer parentMod;
    public List<ModContainer> childMods;
    public boolean useDependencyInformation;
    public Set<ArtifactVersion> requiredMods;
    public List<ArtifactVersion> dependencies;
    public List<ArtifactVersion> dependants;
    public boolean autogenerated;
    
    public ModMetadata(final JsonNode node) {
        this.description = "";
        this.url = "";
        this.updateUrl = "";
        this.logoFile = "";
        this.version = "";
        this.authorList = Lists.newArrayList();
        this.credits = "";
        this.parent = "";
        this.childMods = Lists.newArrayList();
        final Map<JsonStringNode, Object> processedFields = Maps.transformValues(node.getFields(), (Function)new JsonStringConverter());
        this.modId = processedFields.get(JsonNodeBuilders.aStringBuilder("modid"));
        if (Strings.isNullOrEmpty(this.modId)) {
            FMLLog.log(Level.SEVERE, "Found an invalid mod metadata file - missing modid", new Object[0]);
            throw new LoaderException();
        }
        this.name = Strings.nullToEmpty((String)processedFields.get(JsonNodeBuilders.aStringBuilder("name")));
        this.description = Strings.nullToEmpty((String)processedFields.get(JsonNodeBuilders.aStringBuilder("description")));
        this.url = Strings.nullToEmpty((String)processedFields.get(JsonNodeBuilders.aStringBuilder("url")));
        this.updateUrl = Strings.nullToEmpty((String)processedFields.get(JsonNodeBuilders.aStringBuilder("updateUrl")));
        this.logoFile = Strings.nullToEmpty((String)processedFields.get(JsonNodeBuilders.aStringBuilder("logoFile")));
        this.version = Strings.nullToEmpty((String)processedFields.get(JsonNodeBuilders.aStringBuilder("version")));
        this.credits = Strings.nullToEmpty((String)processedFields.get(JsonNodeBuilders.aStringBuilder("credits")));
        this.parent = Strings.nullToEmpty((String)processedFields.get(JsonNodeBuilders.aStringBuilder("parent")));
        this.authorList = (List)Objects.firstNonNull((Object)processedFields.get(JsonNodeBuilders.aStringBuilder("authors")), Objects.firstNonNull((Object)processedFields.get(JsonNodeBuilders.aStringBuilder("authorList")), (Object)this.authorList));
        this.requiredMods = this.processReferences(processedFields.get(JsonNodeBuilders.aStringBuilder("requiredMods")), (Class<? extends Set<ArtifactVersion>>)HashSet.class);
        this.dependencies = this.processReferences(processedFields.get(JsonNodeBuilders.aStringBuilder("dependencies")), (Class<? extends List<ArtifactVersion>>)ArrayList.class);
        this.dependants = this.processReferences(processedFields.get(JsonNodeBuilders.aStringBuilder("dependants")), (Class<? extends List<ArtifactVersion>>)ArrayList.class);
        this.useDependencyInformation = Boolean.parseBoolean(Strings.nullToEmpty((String)processedFields.get(JsonNodeBuilders.aStringBuilder("useDependencyInformation"))));
    }
    
    public ModMetadata() {
        this.description = "";
        this.url = "";
        this.updateUrl = "";
        this.logoFile = "";
        this.version = "";
        this.authorList = Lists.newArrayList();
        this.credits = "";
        this.parent = "";
        this.childMods = Lists.newArrayList();
    }
    
    private <T extends Collection<ArtifactVersion>> T processReferences(final Object refs, final Class<? extends T> retType) {
        T res = null;
        try {
            res = (T)retType.newInstance();
        }
        catch (final Exception ex) {}
        if (refs == null) {
            return res;
        }
        for (final String ref : (List)refs) {
            res.add(VersionParser.parseVersionReference(ref));
        }
        return res;
    }
    
    public String getChildModCountString() {
        return String.format("%d child mod%s", this.childMods.size(), (this.childMods.size() != 1) ? "s" : "");
    }
    
    public String getAuthorList() {
        return Joiner.on(", ").join((Iterable)this.authorList);
    }
    
    public String getChildModList() {
        return Joiner.on(", ").join((Iterable)Lists.transform((List)this.childMods, (Function)new ModNameFunction()));
    }
    
    public String printableSortingRules() {
        return "";
    }
    
    private static final class JsonStringConverter implements Function<JsonNode, Object>
    {
        public Object apply(final JsonNode arg0) {
            if (arg0.hasElements()) {
                return Lists.transform(arg0.getElements(), (Function)new JsonArrayConverter());
            }
            return arg0.getText();
        }
    }
    
    private static final class JsonArrayConverter implements Function<JsonNode, String>
    {
        public String apply(final JsonNode arg0) {
            return arg0.getText();
        }
    }
}



================================================
FILE: cpw/mods/fml/common/ObfuscationReflectionHelper.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.util.Arrays;
import cpw.mods.fml.common.asm.transformers.deobf.FMLDeobfuscatingRemapper;
import java.util.logging.Level;
import cpw.mods.fml.relauncher.ReflectionHelper;

public class ObfuscationReflectionHelper
{
    public static <T, E> T getPrivateValue(final Class<? super E> classToAccess, final E instance, final int fieldIndex) {
        try {
            return ReflectionHelper.getPrivateValue(classToAccess, instance, fieldIndex);
        }
        catch (final ReflectionHelper.UnableToAccessFieldException e) {
            FMLLog.log(Level.SEVERE, e, "There was a problem getting field index %d from %s", fieldIndex, classToAccess.getName());
            throw e;
        }
    }
    
    public static String[] remapFieldNames(final String className, final String... fieldNames) {
        final String internalClassName = FMLDeobfuscatingRemapper.INSTANCE.unmap(className.replace('.', '/'));
        final String[] mappedNames = new String[fieldNames.length];
        int i = 0;
        for (final String fName : fieldNames) {
            mappedNames[i++] = FMLDeobfuscatingRemapper.INSTANCE.mapFieldName(internalClassName, fName, null);
        }
        return mappedNames;
    }
    
    public static <T, E> T getPrivateValue(final Class<? super E> classToAccess, final E instance, final String... fieldNames) {
        try {
            return ReflectionHelper.getPrivateValue(classToAccess, instance, remapFieldNames(classToAccess.getName(), fieldNames));
        }
        catch (final ReflectionHelper.UnableToFindFieldException e) {
            FMLLog.log(Level.SEVERE, e, "Unable to locate any field %s on type %s", Arrays.toString(fieldNames), classToAccess.getName());
            throw e;
        }
        catch (final ReflectionHelper.UnableToAccessFieldException e2) {
            FMLLog.log(Level.SEVERE, e2, "Unable to access any field %s on type %s", Arrays.toString(fieldNames), classToAccess.getName());
            throw e2;
        }
    }
    
    @Deprecated
    public static <T, E> void setPrivateValue(final Class<? super T> classToAccess, final T instance, final int fieldIndex, final E value) {
        setPrivateValue(classToAccess, instance, value, fieldIndex);
    }
    
    public static <T, E> void setPrivateValue(final Class<? super T> classToAccess, final T instance, final E value, final int fieldIndex) {
        try {
            ReflectionHelper.setPrivateValue(classToAccess, instance, value, fieldIndex);
        }
        catch (final ReflectionHelper.UnableToAccessFieldException e) {
            FMLLog.log(Level.SEVERE, e, "There was a problem setting field index %d on type %s", fieldIndex, classToAccess.getName());
            throw e;
        }
    }
    
    @Deprecated
    public static <T, E> void setPrivateValue(final Class<? super T> classToAccess, final T instance, final String fieldName, final E value) {
        setPrivateValue(classToAccess, instance, value, fieldName);
    }
    
    public static <T, E> void setPrivateValue(final Class<? super T> classToAccess, final T instance, final E value, final String... fieldNames) {
        try {
            ReflectionHelper.setPrivateValue(classToAccess, instance, value, remapFieldNames(classToAccess.getName(), fieldNames));
        }
        catch (final ReflectionHelper.UnableToFindFieldException e) {
            FMLLog.log(Level.SEVERE, e, "Unable to locate any field %s on type %s", Arrays.toString(fieldNames), classToAccess.getName());
            throw e;
        }
        catch (final ReflectionHelper.UnableToAccessFieldException e2) {
            FMLLog.log(Level.SEVERE, e2, "Unable to set any field %s on type %s", Arrays.toString(fieldNames), classToAccess.getName());
            throw e2;
        }
    }
}



================================================
FILE: cpw/mods/fml/common/Optional.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Retention;

public final class Optional
{
    private Optional() {
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.METHOD })
    public @interface Method {
        String modid();
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.TYPE })
    public @interface Interface {
        String iface();
        
        String modid();
        
        boolean striprefs() default false;
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.TYPE })
    public @interface InterfaceList {
        Interface[] value();
    }
}



================================================
FILE: cpw/mods/fml/common/ProxyInjector.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.lang.reflect.Field;
import java.util.Iterator;
import java.util.Set;
import java.util.logging.Level;
import com.google.common.base.Strings;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.common.discovery.ASMDataTable;

public class ProxyInjector
{
    public static void inject(final ModContainer mod, final ASMDataTable data, final Side side, final ILanguageAdapter languageAdapter) {
        FMLLog.fine("Attempting to inject @SidedProxy classes into %s", mod.getModId());
        final Set<ASMDataTable.ASMData> targets = data.getAnnotationsFor(mod).get((Object)SidedProxy.class.getName());
        final ClassLoader mcl = Loader.instance().getModClassLoader();
        for (final ASMDataTable.ASMData targ : targets) {
            try {
                final Class<?> proxyTarget = Class.forName(targ.getClassName(), true, mcl);
                final Field target = proxyTarget.getDeclaredField(targ.getObjectName());
                if (target == null) {
                    FMLLog.severe("Attempted to load a proxy type into %s.%s but the field was not found", targ.getClassName(), targ.getObjectName());
                    throw new LoaderException();
                }
                final SidedProxy annotation = target.getAnnotation(SidedProxy.class);
                if (!Strings.isNullOrEmpty(annotation.modId()) && !annotation.modId().equals(mod.getModId())) {
                    FMLLog.fine("Skipping proxy injection for %s.%s since it is not for mod %s", targ.getClassName(), targ.getObjectName(), mod.getModId());
                }
                else {
                    final String targetType = side.isClient() ? annotation.clientSide() : annotation.serverSide();
                    final Object proxy = Class.forName(targetType, true, mcl).newInstance();
                    if (languageAdapter.supportsStatics() && (target.getModifiers() & 0x8) == 0x0) {
                        FMLLog.severe("Attempted to load a proxy type %s into %s.%s, but the field is not static", targetType, targ.getClassName(), targ.getObjectName());
                        throw new LoaderException();
                    }
                    if (!target.getType().isAssignableFrom(proxy.getClass())) {
                        FMLLog.severe("Attempted to load a proxy type %s into %s.%s, but the types don't match", targetType, targ.getClassName(), targ.getObjectName());
                        throw new LoaderException();
                    }
                    languageAdapter.setProxy(target, proxyTarget, proxy);
                }
            }
            catch (final Exception e) {
                FMLLog.log(Level.SEVERE, e, "An error occured trying to load a proxy into %s.%s", targ.getAnnotationInfo(), targ.getClassName(), targ.getObjectName());
                throw new LoaderException(e);
            }
        }
        languageAdapter.setInternalProxies(mod, side, mcl);
    }
}



================================================
FILE: cpw/mods/fml/common/SidedProxy.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Retention;

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD })
public @interface SidedProxy {
    String clientSide() default "";
    
    String serverSide() default "";
    
    @Deprecated
    String bukkitSide() default "";
    
    String modId() default "";
}



================================================
FILE: cpw/mods/fml/common/SingleIntervalHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.util.EnumSet;

public class SingleIntervalHandler implements IScheduledTickHandler
{
    private ITickHandler wrapped;
    
    public SingleIntervalHandler(final ITickHandler handler) {
        this.wrapped = handler;
    }
    
    @Override
    public void tickStart(final EnumSet<TickType> type, final Object... tickData) {
        this.wrapped.tickStart(type, tickData);
    }
    
    @Override
    public void tickEnd(final EnumSet<TickType> type, final Object... tickData) {
        this.wrapped.tickEnd(type, tickData);
    }
    
    @Override
    public EnumSet<TickType> ticks() {
        return this.wrapped.ticks();
    }
    
    @Override
    public String getLabel() {
        return this.wrapped.getLabel();
    }
    
    @Override
    public int nextTickSpacing() {
        return 1;
    }
}



================================================
FILE: cpw/mods/fml/common/TickType.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.util.EnumSet;

public enum TickType
{
    WORLD, 
    RENDER, 
    WORLDLOAD, 
    CLIENT, 
    PLAYER, 
    SERVER;
    
    public EnumSet<TickType> partnerTicks() {
        if (this == TickType.CLIENT) {
            return EnumSet.of(TickType.RENDER);
        }
        if (this == TickType.RENDER) {
            return EnumSet.of(TickType.CLIENT);
        }
        return EnumSet.noneOf(TickType.class);
    }
}



================================================
FILE: cpw/mods/fml/common/WorldAccessContainer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

import java.util.Map;

public interface WorldAccessContainer
{
    by getDataForWriting(final alq p0, final als p1);
    
    void readData(final alq p0, final als p1, final Map<String, cl> p2, final by p3);
}



================================================
FILE: cpw/mods/fml/common/WrongMinecraftVersionException.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common;

public class WrongMinecraftVersionException extends RuntimeException
{
    public ModContainer mod;
    
    public WrongMinecraftVersionException(final ModContainer mod) {
        this.mod = mod;
    }
}



================================================
FILE: cpw/mods/fml/common/asm/ASMTransformer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.asm;

import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Type;
import cpw.mods.fml.common.registry.BlockProxy;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.ClassReader;
import net.minecraft.launchwrapper.IClassTransformer;

public class ASMTransformer implements IClassTransformer
{
    public byte[] transform(final String name, final String transformedName, final byte[] bytes) {
        if ("net.minecraft.src.Block".equals(name)) {
            final ClassReader cr = new ClassReader(bytes);
            final ClassNode cn = new ClassNode(262144);
            cr.accept((ClassVisitor)cn, 8);
            cn.interfaces.add(Type.getInternalName((Class)BlockProxy.class));
            final ClassWriter cw = new ClassWriter(3);
            cn.accept((ClassVisitor)cw);
            return cw.toByteArray();
        }
        return bytes;
    }
}



================================================
FILE: cpw/mods/fml/common/asm/FMLSanityChecker.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.asm;

import org.objectweb.asm.FieldVisitor;
import cpw.mods.fml.common.asm.transformers.deobf.FMLDeobfuscatingRemapper;
import cpw.mods.fml.common.patcher.ClassPatchManager;
import java.util.Map;
import java.util.jar.JarEntry;
import java.security.cert.Certificate;
import java.security.CodeSource;
import java.awt.Component;
import javax.swing.JOptionPane;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassReader;
import java.io.IOException;
import java.util.logging.Level;
import com.google.common.io.ByteStreams;
import java.util.zip.ZipEntry;
import java.util.jar.JarFile;
import java.net.URLDecoder;
import com.google.common.base.Charsets;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.FMLLaunchHandler;
import cpw.mods.fml.relauncher.FMLRelaunchLog;
import cpw.mods.fml.common.CertificateHelper;
import java.io.File;
import net.minecraft.launchwrapper.LaunchClassLoader;
import cpw.mods.fml.relauncher.IFMLCallHook;

public class FMLSanityChecker implements IFMLCallHook
{
    private static final String FMLFINGERPRINT;
    private static final String FORGEFINGERPRINT;
    private static final String MCFINGERPRINT;
    private LaunchClassLoader cl;
    public static File fmlLocation;
    
    @Override
    public Void call() throws Exception {
        CodeSource codeSource = this.getClass().getProtectionDomain().getCodeSource();
        boolean goodFML = false;
        boolean fmlIsJar = false;
        if (codeSource.getLocation().getProtocol().equals("jar")) {
            fmlIsJar = true;
            final Certificate[] certificates = codeSource.getCertificates();
            if (certificates != null) {
                for (final Certificate cert : certificates) {
                    final String fingerprint = CertificateHelper.getFingerprint(cert);
                    if (fingerprint.equals(FMLSanityChecker.FMLFINGERPRINT)) {
                        FMLRelaunchLog.info("Found valid fingerprint for FML. Certificate fingerprint %s", fingerprint);
                        goodFML = true;
                    }
                    else if (fingerprint.equals(FMLSanityChecker.FORGEFINGERPRINT)) {
                        FMLRelaunchLog.info("Found valid fingerprint for Minecraft Forge. Certificate fingerprint %s", fingerprint);
                        goodFML = true;
                    }
                    else {
                        FMLRelaunchLog.severe("Found invalid fingerprint for FML: %s", fingerprint);
                    }
                }
            }
        }
        else {
            goodFML = true;
        }
        boolean goodMC = FMLLaunchHandler.side() == Side.SERVER;
        int certCount = 0;
        try {
            final Class cbr = Class.forName("net.minecraft.client.ClientBrandRetriever", false, (ClassLoader)this.cl);
            codeSource = cbr.getProtectionDomain().getCodeSource();
        }
        catch (final Exception e) {
            goodMC = true;
        }
        JarFile mcJarFile = null;
        if (fmlIsJar && !goodMC && codeSource.getLocation().getProtocol().equals("jar")) {
            try {
                String mcPath = codeSource.getLocation().getPath().substring(5);
                mcPath = mcPath.substring(0, mcPath.lastIndexOf(33));
                mcPath = URLDecoder.decode(mcPath, Charsets.UTF_8.name());
                mcJarFile = new JarFile(mcPath, true);
                mcJarFile.getManifest();
                final JarEntry cbrEntry = mcJarFile.getJarEntry("net/minecraft/client/ClientBrandRetriever.class");
                ByteStreams.toByteArray(mcJarFile.getInputStream(cbrEntry));
                final Certificate[] certificates2 = cbrEntry.getCertificates();
                certCount = ((certificates2 != null) ? certificates2.length : 0);
                if (certificates2 != null) {
                    for (final Certificate cert2 : certificates2) {
                        final String fingerprint2 = CertificateHelper.getFingerprint(cert2);
                        if (fingerprint2.equals(FMLSanityChecker.MCFINGERPRINT)) {
                            FMLRelaunchLog.info("Found valid fingerprint for Minecraft. Certificate fingerprint %s", fingerprint2);
                            goodMC = true;
                        }
                    }
                }
            }
            catch (final Throwable e2) {
                FMLRelaunchLog.log(Level.SEVERE, e2, "A critical error occurred trying to read the minecraft jar file", new Object[0]);
            }
            finally {
                if (mcJarFile != null) {
                    try {
                        mcJarFile.close();
                    }
                    catch (final IOException ex) {}
                }
            }
        }
        else {
            goodMC = true;
        }
        if (!goodMC) {
            FMLRelaunchLog.severe("The minecraft jar %s appears to be corrupt! There has been CRITICAL TAMPERING WITH MINECRAFT, it is highly unlikely minecraft will work! STOP NOW, get a clean copy and try again!", codeSource.getLocation().getFile());
            if (!Boolean.parseBoolean(System.getProperty("fml.ignoreInvalidMinecraftCertificates", "false"))) {
                FMLRelaunchLog.severe("For your safety, FML will not launch minecraft. You will need to fetch a clean version of the minecraft jar file", new Object[0]);
                FMLRelaunchLog.severe("Technical information: The class net.minecraft.client.ClientBrandRetriever should have been associated with the minecraft jar file, and should have returned us a valid, intact minecraft jar location. This did not work. Either you have modified the minecraft jar file (if so run the forge installer again), or you are using a base editing jar that is changing this class (and likely others too). If you REALLY want to run minecraft in this configuration, add the flag -Dfml.ignoreInvalidMinecraftCertificates=true to the 'JVM settings' in your launcher profile.", new Object[0]);
                System.exit(1);
            }
            else {
                FMLRelaunchLog.severe("FML has been ordered to ignore the invalid or missing minecraft certificate. This is very likely to cause a problem!", new Object[0]);
                FMLRelaunchLog.severe("Technical information: ClientBrandRetriever was at %s, there were %d certificates for it", codeSource.getLocation(), certCount);
            }
        }
        if (!goodFML) {
            FMLRelaunchLog.severe("FML appears to be missing any signature data. This is not a good thing", new Object[0]);
        }
        final byte[] mlClass = this.cl.getClassBytes("ModLoader");
        if (mlClass == null) {
            return null;
        }
        final MLDetectorClassVisitor mlTester = new MLDetectorClassVisitor();
        final ClassReader cr = new ClassReader(mlClass);
        cr.accept((ClassVisitor)mlTester, 1);
        if (!mlTester.foundMarker) {
            JOptionPane.showMessageDialog(null, "<html>CRITICAL ERROR<br/>ModLoader was detected in this environment<br/>ForgeModLoader cannot be installed alongside ModLoader<br/>All mods should work without ModLoader being installed<br/>Because ForgeModLoader is 100% compatible with ModLoader<br/>Re-install Minecraft Forge or Forge ModLoader into a clean<br/>jar and try again.", "ForgeModLoader critical error", 0);
            throw new RuntimeException("Invalid ModLoader class detected");
        }
        return null;
    }
    
    @Override
    public void injectData(final Map<String, Object> data) {
        this.cl = data.get("classLoader");
        final File mcDir = data.get("mcLocation");
        FMLSanityChecker.fmlLocation = data.get("coremodLocation");
        ClassPatchManager.INSTANCE.setup(FMLLaunchHandler.side());
        FMLDeobfuscatingRemapper.INSTANCE.setup(mcDir, this.cl, data.get("deobfuscationFileName"));
    }
    
    static {
        FMLFINGERPRINT = "51:0A:FB:4C:AF:A4:A0:F2:F5:CF:C5:0E:B4:CC:3C:30:24:4A:E3:8E".toLowerCase().replace(":", "");
        FORGEFINGERPRINT = "E3:C3:D5:0C:7C:98:6D:F7:4C:64:5C:0A:C5:46:39:74:1C:90:A5:57".toLowerCase().replace(":", "");
        MCFINGERPRINT = "CD:99:95:96:56:F7:53:DC:28:D8:63:B4:67:69:F7:F8:FB:AE:FC:FC".toLowerCase().replace(":", "");
    }
    
    static class MLDetectorClassVisitor extends ClassVisitor
    {
        private boolean foundMarker;
        
        private MLDetectorClassVisitor() {
            super(262144);
            this.foundMarker = false;
        }
        
        public FieldVisitor visitField(final int arg0, final String arg1, final String arg2, final String arg3, final Object arg4) {
            if ("fmlMarker".equals(arg1)) {
                this.foundMarker = true;
            }
            return null;
        }
    }
}



================================================
FILE: cpw/mods/fml/common/asm/ReobfuscationMarker.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.asm;

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Retention;

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE })
public @interface ReobfuscationMarker {
}



================================================
FILE: cpw/mods/fml/common/asm/transformers/AccessTransformer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.asm.transformers;

import java.util.zip.ZipEntry;
import java.io.ByteArrayOutputStream;
import java.util.zip.ZipOutputStream;
import java.io.OutputStream;
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;
import java.util.zip.ZipInputStream;
import java.io.InputStream;
import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.util.Iterator;
import java.util.Collection;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;
import cpw.mods.fml.common.asm.transformers.deobf.FMLDeobfuscatingRemapper;
import java.net.URL;
import java.util.List;
import com.google.common.collect.Lists;
import com.google.common.collect.Iterables;
import com.google.common.base.Splitter;
import com.google.common.io.LineProcessor;
import com.google.common.base.Charsets;
import com.google.common.io.Resources;
import java.io.File;
import com.google.common.collect.ArrayListMultimap;
import java.io.IOException;
import com.google.common.collect.Multimap;
import net.minecraft.launchwrapper.IClassTransformer;

public class AccessTransformer implements IClassTransformer
{
    private static final boolean DEBUG = false;
    private Multimap<String, Modifier> modifiers;
    
    public AccessTransformer() throws IOException {
        this("fml_at.cfg");
    }
    
    protected AccessTransformer(final String rulesFile) throws IOException {
        this.modifiers = (Multimap<String, Modifier>)ArrayListMultimap.create();
        this.readMapFile(rulesFile);
    }
    
    private void readMapFile(final String rulesFile) throws IOException {
        final File file = new File(rulesFile);
        URL rulesResource;
        if (file.exists()) {
            rulesResource = file.toURI().toURL();
        }
        else {
            rulesResource = Resources.getResource(rulesFile);
        }
        Resources.readLines(rulesResource, Charsets.UTF_8, (LineProcessor)new LineProcessor<Void>() {
            public Void getResult() {
                return null;
            }
            
            public boolean processLine(final String input) throws IOException {
                final String line = ((String)Iterables.getFirst(Splitter.on('#').limit(2).split((CharSequence)input), (Object)"")).trim();
                if (line.length() == 0) {
                    return true;
                }
                final List<String> parts = Lists.newArrayList(Splitter.on(" ").trimResults().split((CharSequence)line));
                if (parts.size() > 2) {
                    throw new RuntimeException("Invalid config file line " + input);
                }
                final Modifier m = new Modifier();
                m.setTargetAccess(parts.get(0));
                final List<String> descriptor = Lists.newArrayList(Splitter.on(".").trimResults().split((CharSequence)parts.get(1)));
                if (descriptor.size() == 1) {
                    m.modifyClassVisibility = true;
                }
                else {
                    final String nameReference = descriptor.get(1);
                    final int parenIdx = nameReference.indexOf(40);
                    if (parenIdx > 0) {
                        m.desc = nameReference.substring(parenIdx);
                        m.name = nameReference.substring(0, parenIdx);
                    }
                    else {
                        m.name = nameReference;
                    }
                }
                AccessTransformer.this.modifiers.put((Object)descriptor.get(0).replace('/', '.'), (Object)m);
                return true;
            }
        });
        System.out.printf("Loaded %d rules from AccessTransformer config file %s\n", this.modifiers.size(), rulesFile);
    }
    
    public byte[] transform(final String name, final String transformedName, final byte[] bytes) {
        if (bytes == null) {
            return null;
        }
        final boolean makeAllPublic = FMLDeobfuscatingRemapper.INSTANCE.isRemappedClass(name);
        if (!makeAllPublic && !this.modifiers.containsKey((Object)name)) {
            return bytes;
        }
        final ClassNode classNode = new ClassNode();
        final ClassReader classReader = new ClassReader(bytes);
        classReader.accept((ClassVisitor)classNode, 0);
        if (makeAllPublic) {
            Modifier m = new Modifier();
            m.targetAccess = 1;
            m.modifyClassVisibility = true;
            this.modifiers.put((Object)name, (Object)m);
            m = new Modifier();
            m.targetAccess = 1;
            m.name = "*";
            this.modifiers.put((Object)name, (Object)m);
            m = new Modifier();
            m.targetAccess = 1;
            m.name = "*";
            m.desc = "<dummy>";
            this.modifiers.put((Object)name, (Object)m);
        }
        final Collection<Modifier> mods = this.modifiers.get((Object)name);
        for (final Modifier i : mods) {
            if (i.modifyClassVisibility) {
                classNode.access = this.getFixedAccess(classNode.access, i);
            }
            else if (i.desc.isEmpty()) {
                for (final FieldNode n : classNode.fields) {
                    if (n.name.equals(i.name) || i.name.equals("*")) {
                        n.access = this.getFixedAccess(n.access, i);
                        if (!i.name.equals("*")) {
                            break;
                        }
                        continue;
                    }
                }
            }
            else {
                for (final MethodNode n2 : classNode.methods) {
                    if ((n2.name.equals(i.name) && n2.desc.equals(i.desc)) || i.name.equals("*")) {
                        n2.access = this.getFixedAccess(n2.access, i);
                        if (!i.name.equals("*")) {
                            break;
                        }
                        continue;
                    }
                }
            }
        }
        final ClassWriter writer = new ClassWriter(1);
        classNode.accept((ClassVisitor)writer);
        return writer.toByteArray();
    }
    
    private String toBinary(final int num) {
        return String.format("%16s", Integer.toBinaryString(num)).replace(' ', '0');
    }
    
    private int getFixedAccess(final int access, final Modifier target) {
        target.oldAccess = access;
        final int t = target.targetAccess;
        int ret = access & 0xFFFFFFF8;
        switch (access & 0x7) {
            case 2: {
                ret |= t;
                break;
            }
            case 0: {
                ret |= ((t != 2) ? t : 0);
                break;
            }
            case 4: {
                ret |= ((t != 2 && t != 0) ? t : 4);
                break;
            }
            case 1: {
                ret |= ((t != 2 && t != 0 && t != 4) ? t : 1);
                break;
            }
            default: {
                throw new RuntimeException("The fuck?");
            }
        }
        if (target.changeFinal) {
            if (target.markFinal) {
                ret |= 0x10;
            }
            else {
                ret &= 0xFFFFFFEF;
            }
        }
        return target.newAccess = ret;
    }
    
    public static void main(final String[] args) {
        if (args.length < 2) {
            System.out.println("Usage: AccessTransformer <JarPath> <MapFile> [MapFile2]... ");
            System.exit(1);
        }
        boolean hasTransformer = false;
        final AccessTransformer[] trans = new AccessTransformer[args.length - 1];
        for (int x = 1; x < args.length; ++x) {
            try {
                trans[x - 1] = new AccessTransformer(args[x]);
                hasTransformer = true;
            }
            catch (final IOException e) {
                System.out.println("Could not read Transformer Map: " + args[x]);
                e.printStackTrace();
            }
        }
        if (!hasTransformer) {
            System.out.println("Culd not find a valid transformer to perform");
            System.exit(1);
        }
        final File orig = new File(args[0]);
        final File temp = new File(args[0] + ".ATBack");
        if (!orig.exists() && !temp.exists()) {
            System.out.println("Could not find target jar: " + orig);
            System.exit(1);
        }
        if (!orig.renameTo(temp)) {
            System.out.println("Could not rename file: " + orig + " -> " + temp);
            System.exit(1);
        }
        try {
            processJar(temp, orig, trans);
        }
        catch (final IOException e2) {
            e2.printStackTrace();
            System.exit(1);
        }
        if (!temp.delete()) {
            System.out.println("Could not delete temp file: " + temp);
        }
    }
    
    private static void processJar(final File inFile, final File outFile, final AccessTransformer[] transformers) throws IOException {
        ZipInputStream inJar = null;
        ZipOutputStream outJar = null;
        try {
            try {
                inJar = new ZipInputStream(new BufferedInputStream(new FileInputStream(inFile)));
            }
            catch (final FileNotFoundException e) {
                throw new FileNotFoundException("Could not open input file: " + e.getMessage());
            }
            try {
                outJar = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
            }
            catch (final FileNotFoundException e) {
                throw new FileNotFoundException("Could not open output file: " + e.getMessage());
            }
            ZipEntry entry;
            while ((entry = inJar.getNextEntry()) != null) {
                if (entry.isDirectory()) {
                    outJar.putNextEntry(entry);
                }
                else {
                    final byte[] data = new byte[4096];
                    final ByteArrayOutputStream entryBuffer = new ByteArrayOutputStream();
                    int len;
                    do {
                        len = inJar.read(data);
                        if (len > 0) {
                            entryBuffer.write(data, 0, len);
                        }
                    } while (len != -1);
                    byte[] entryData = entryBuffer.toByteArray();
                    final String entryName = entry.getName();
                    if (entryName.endsWith(".class") && !entryName.startsWith(".")) {
                        final ClassNode cls = new ClassNode();
                        final ClassReader rdr = new ClassReader(entryData);
                        rdr.accept((ClassVisitor)cls, 0);
                        final String name = cls.name.replace('/', '.').replace('\\', '.');
                        for (final AccessTransformer trans : transformers) {
                            entryData = trans.transform(name, name, entryData);
                        }
                    }
                    final ZipEntry newEntry = new ZipEntry(entryName);
                    outJar.putNextEntry(newEntry);
                    outJar.write(entryData);
                }
            }
        }
        finally {
            if (outJar != null) {
                try {
                    outJar.close();
                }
                catch (final IOException ex) {}
            }
            if (inJar != null) {
                try {
                    inJar.close();
                }
                catch (final IOException ex2) {}
            }
        }
    }
    
    public void ensurePublicAccessFor(final String modClazzName) {
        final Modifier m = new Modifier();
        m.setTargetAccess("public");
        m.modifyClassVisibility = true;
        this.modifiers.put((Object)modClazzName, (Object)m);
    }
    
    private class Modifier
    {
        public String name;
        public String desc;
        public int oldAccess;
        public int newAccess;
        public int targetAccess;
        public boolean changeFinal;
        public boolean markFinal;
        protected boolean modifyClassVisibility;
        
        private Modifier() {
            this.name = "";
            this.desc = "";
            this.oldAccess = 0;
            this.newAccess = 0;
            this.targetAccess = 0;
            this.changeFinal = false;
            this.markFinal = false;
        }
        
        private void setTargetAccess(final String name) {
            if (name.startsWith("public")) {
                this.targetAccess = 1;
            }
            else if (name.startsWith("private")) {
                this.targetAccess = 2;
            }
            else if (name.startsWith("protected")) {
                this.targetAccess = 4;
            }
            if (name.endsWith("-f")) {
                this.changeFinal = true;
                this.markFinal = false;
            }
            else if (name.endsWith("+f")) {
                this.changeFinal = true;
                this.markFinal = true;
            }
        }
    }
}



================================================
FILE: cpw/mods/fml/common/asm/transformers/DeobfuscationTransformer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.asm.transformers;

import cpw.mods.fml.common.asm.transformers.deobf.FMLDeobfuscatingRemapper;
import org.objectweb.asm.commons.RemappingClassAdapter;
import org.objectweb.asm.ClassVisitor;
import cpw.mods.fml.common.asm.transformers.deobf.FMLRemappingAdapter;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.ClassReader;
import net.minecraft.launchwrapper.IClassNameTransformer;
import net.minecraft.launchwrapper.IClassTransformer;

public class DeobfuscationTransformer implements IClassTransformer, IClassNameTransformer
{
    public byte[] transform(final String name, final String transformedName, final byte[] bytes) {
        if (bytes == null) {
            return null;
        }
        final ClassReader classReader = new ClassReader(bytes);
        final ClassWriter classWriter = new ClassWriter(1);
        final RemappingClassAdapter remapAdapter = new FMLRemappingAdapter((ClassVisitor)classWriter);
        classReader.accept((ClassVisitor)remapAdapter, 8);
        return classWriter.toByteArray();
    }
    
    public String remapClassName(final String name) {
        return FMLDeobfuscatingRemapper.INSTANCE.map(name.replace('.', '/')).replace('/', '.');
    }
    
    public String unmapClassName(final String name) {
        return FMLDeobfuscatingRemapper.INSTANCE.unmap(name.replace('.', '/')).replace('/', '.');
    }
}



================================================
FILE: cpw/mods/fml/common/asm/transformers/MarkerTransformer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.asm.transformers;

import java.util.zip.ZipEntry;
import java.io.ByteArrayOutputStream;
import java.util.zip.ZipOutputStream;
import java.io.OutputStream;
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;
import java.util.zip.ZipInputStream;
import java.io.InputStream;
import java.io.BufferedInputStream;
import java.io.FileInputStream;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;
import java.net.URL;
import java.util.Iterator;
import java.util.List;
import com.google.common.collect.Lists;
import com.google.common.collect.Iterables;
import com.google.common.base.Splitter;
import com.google.common.io.LineProcessor;
import com.google.common.base.Charsets;
import com.google.common.io.Resources;
import java.io.File;
import com.google.common.collect.ArrayListMultimap;
import java.io.IOException;
import com.google.common.collect.ListMultimap;
import net.minecraft.launchwrapper.IClassTransformer;

public class MarkerTransformer implements IClassTransformer
{
    private ListMultimap<String, String> markers;
    
    public MarkerTransformer() throws IOException {
        this("fml_marker.cfg");
    }
    
    protected MarkerTransformer(final String rulesFile) throws IOException {
        this.markers = (ListMultimap<String, String>)ArrayListMultimap.create();
        this.readMapFile(rulesFile);
    }
    
    private void readMapFile(final String rulesFile) throws IOException {
        final File file = new File(rulesFile);
        URL rulesResource;
        if (file.exists()) {
            rulesResource = file.toURI().toURL();
        }
        else {
            rulesResource = Resources.getResource(rulesFile);
        }
        Resources.readLines(rulesResource, Charsets.UTF_8, (LineProcessor)new LineProcessor<Void>() {
            public Void getResult() {
                return null;
            }
            
            public boolean processLine(final String input) throws IOException {
                final String line = ((String)Iterables.getFirst(Splitter.on('#').limit(2).split((CharSequence)input), (Object)"")).trim();
                if (line.length() == 0) {
                    return true;
                }
                final List<String> parts = Lists.newArrayList(Splitter.on(" ").trimResults().split((CharSequence)line));
                if (parts.size() != 2) {
                    throw new RuntimeException("Invalid config file line " + input);
                }
                final List<String> markerInterfaces = Lists.newArrayList(Splitter.on(",").trimResults().split((CharSequence)parts.get(1)));
                for (final String marker : markerInterfaces) {
                    MarkerTransformer.this.markers.put((Object)parts.get(0), (Object)marker);
                }
                return true;
            }
        });
    }
    
    public byte[] transform(final String name, final String transformedName, final byte[] bytes) {
        if (bytes == null) {
            return null;
        }
        if (!this.markers.containsKey((Object)name)) {
            return bytes;
        }
        final ClassNode classNode = new ClassNode();
        final ClassReader classReader = new ClassReader(bytes);
        classReader.accept((ClassVisitor)classNode, 0);
        for (final String marker : this.markers.get((Object)name)) {
            classNode.interfaces.add(marker);
        }
        final ClassWriter writer = new ClassWriter(1);
        classNode.accept((ClassVisitor)writer);
        return writer.toByteArray();
    }
    
    public static void main(final String[] args) {
        if (args.length < 2) {
            System.out.println("Usage: MarkerTransformer <JarPath> <MapFile> [MapFile2]... ");
            return;
        }
        boolean hasTransformer = false;
        final MarkerTransformer[] trans = new MarkerTransformer[args.length - 1];
        for (int x = 1; x < args.length; ++x) {
            try {
                trans[x - 1] = new MarkerTransformer(args[x]);
                hasTransformer = true;
            }
            catch (final IOException e) {
                System.out.println("Could not read Transformer Map: " + args[x]);
                e.printStackTrace();
            }
        }
        if (!hasTransformer) {
            System.out.println("Culd not find a valid transformer to perform");
            return;
        }
        final File orig = new File(args[0]);
        final File temp = new File(args[0] + ".ATBack");
        if (!orig.exists() && !temp.exists()) {
            System.out.println("Could not find target jar: " + orig);
            return;
        }
        if (!orig.renameTo(temp)) {
            System.out.println("Could not rename file: " + orig + " -> " + temp);
            return;
        }
        try {
            processJar(temp, orig, trans);
        }
        catch (final IOException e2) {
            e2.printStackTrace();
        }
        if (!temp.delete()) {
            System.out.println("Could not delete temp file: " + temp);
        }
    }
    
    private static void processJar(final File inFile, final File outFile, final MarkerTransformer[] transformers) throws IOException {
        ZipInputStream inJar = null;
        ZipOutputStream outJar = null;
        try {
            try {
                inJar = new ZipInputStream(new BufferedInputStream(new FileInputStream(inFile)));
            }
            catch (final FileNotFoundException e) {
                throw new FileNotFoundException("Could not open input file: " + e.getMessage());
            }
            try {
                outJar = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));
            }
            catch (final FileNotFoundException e) {
                throw new FileNotFoundException("Could not open output file: " + e.getMessage());
            }
            ZipEntry entry;
            while ((entry = inJar.getNextEntry()) != null) {
                if (entry.isDirectory()) {
                    outJar.putNextEntry(entry);
                }
                else {
                    final byte[] data = new byte[4096];
                    final ByteArrayOutputStream entryBuffer = new ByteArrayOutputStream();
                    int len;
                    do {
                        len = inJar.read(data);
                        if (len > 0) {
                            entryBuffer.write(data, 0, len);
                        }
                    } while (len != -1);
                    byte[] entryData = entryBuffer.toByteArray();
                    final String entryName = entry.getName();
                    if (entryName.endsWith(".class") && !entryName.startsWith(".")) {
                        final ClassNode cls = new ClassNode();
                        final ClassReader rdr = new ClassReader(entryData);
                        rdr.accept((ClassVisitor)cls, 0);
                        final String name = cls.name.replace('/', '.').replace('\\', '.');
                        for (final MarkerTransformer trans : transformers) {
                            entryData = trans.transform(name, name, entryData);
                        }
                    }
                    final ZipEntry newEntry = new ZipEntry(entryName);
                    outJar.putNextEntry(newEntry);
                    outJar.write(entryData);
                }
            }
        }
        finally {
            if (outJar != null) {
                try {
                    outJar.close();
                }
                catch (final IOException ex) {}
            }
            if (inJar != null) {
                try {
                    inJar.close();
                }
                catch (final IOException ex2) {}
            }
        }
    }
}



================================================
FILE: cpw/mods/fml/common/asm/transformers/MCPMerger.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.asm.transformers;

import com.google.common.base.Objects;
import java.util.LinkedHashSet;
import com.google.common.collect.Lists;
import org.objectweb.asm.tree.MethodNode;
import com.google.common.collect.Sets;
import java.util.List;
import org.objectweb.asm.tree.FieldNode;
import java.io.ByteArrayOutputStream;
import java.util.Collections;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AnnotationNode;
import org.objectweb.asm.ClassWriter;
import java.util.ArrayList;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.ClassReader;
import java.util.Iterator;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;
import java.util.zip.ZipEntry;
import java.util.Map;
import java.util.zip.ZipOutputStream;
import java.io.OutputStream;
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;
import java.util.zip.ZipFile;
import java.io.Reader;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;
import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.File;
import java.util.HashSet;
import java.util.Hashtable;

public class MCPMerger
{
    private static Hashtable<String, ClassInfo> clients;
    private static Hashtable<String, ClassInfo> shared;
    private static Hashtable<String, ClassInfo> servers;
    private static HashSet<String> copyToServer;
    private static HashSet<String> copyToClient;
    private static HashSet<String> dontAnnotate;
    private static HashSet<String> dontProcess;
    private static final boolean DEBUG = false;
    
    public static void main(final String[] args) {
        if (args.length != 3) {
            System.out.println("Usage: MCPMerger <MapFile> <minecraft.jar> <minecraft_server.jar>");
            System.exit(1);
        }
        final File map_file = new File(args[0]);
        final File client_jar = new File(args[1]);
        final File server_jar = new File(args[2]);
        final File client_jar_tmp = new File(args[1] + ".backup_merge");
        final File server_jar_tmp = new File(args[2] + ".backup_merge");
        if (client_jar_tmp.exists() && !client_jar_tmp.delete()) {
            System.out.println("Could not delete temp file: " + client_jar_tmp);
        }
        if (server_jar_tmp.exists() && !server_jar_tmp.delete()) {
            System.out.println("Could not delete temp file: " + server_jar_tmp);
        }
        if (!client_jar.exists()) {
            System.out.println("Could not find minecraft.jar: " + client_jar);
            System.exit(1);
        }
        if (!server_jar.exists()) {
            System.out.println("Could not find minecraft_server.jar: " + server_jar);
            System.exit(1);
        }
        if (!client_jar.renameTo(client_jar_tmp)) {
            System.out.println("Could not rename file: " + client_jar + " -> " + client_jar_tmp);
            System.exit(1);
        }
        if (!server_jar.renameTo(server_jar_tmp)) {
            System.out.println("Could not rename file: " + server_jar + " -> " + server_jar_tmp);
            System.exit(1);
        }
        if (!readMapFile(map_file)) {
            System.out.println("Could not read map file: " + map_file);
            System.exit(1);
        }
        try {
            processJar(client_jar_tmp, server_jar_tmp, client_jar, server_jar);
        }
        catch (final IOException e) {
            e.printStackTrace();
            System.exit(1);
        }
        if (!client_jar_tmp.delete()) {
            System.out.println("Could not delete temp file: " + client_jar_tmp);
        }
        if (!server_jar_tmp.delete()) {
            System.out.println("Could not delete temp file: " + server_jar_tmp);
        }
    }
    
    private static boolean readMapFile(final File mapFile) {
        try {
            final FileInputStream fstream = new FileInputStream(mapFile);
            final DataInputStream in = new DataInputStream(fstream);
            final BufferedReader br = new BufferedReader(new InputStreamReader(in));
            String line;
            while ((line = br.readLine()) != null) {
                line = line.split("#")[0];
                final char cmd = line.charAt(0);
                line = line.substring(1).trim();
                switch (cmd) {
                    case '!': {
                        MCPMerger.dontAnnotate.add(line);
                        continue;
                    }
                    case '<': {
                        MCPMerger.copyToClient.add(line);
                        continue;
                    }
                    case '>': {
                        MCPMerger.copyToServer.add(line);
                        continue;
                    }
                    case '^': {
                        MCPMerger.dontProcess.add(line);
                        continue;
                    }
                }
            }
            in.close();
            return true;
        }
        catch (final Exception e) {
            System.err.println("Error: " + e.getMessage());
            return false;
        }
    }
    
    public static void processJar(final File clientInFile, final File serverInFile, final File clientOutFile, final File serverOutFile) throws IOException {
        ZipFile cInJar = null;
        ZipFile sInJar = null;
        ZipOutputStream cOutJar = null;
        ZipOutputStream sOutJar = null;
        try {
            try {
                cInJar = new ZipFile(clientInFile);
                sInJar = new ZipFile(serverInFile);
            }
            catch (final FileNotFoundException e) {
                throw new FileNotFoundException("Could not open input file: " + e.getMessage());
            }
            try {
                cOutJar = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(clientOutFile)));
                sOutJar = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(serverOutFile)));
            }
            catch (final FileNotFoundException e) {
                throw new FileNotFoundException("Could not open output file: " + e.getMessage());
            }
            final Hashtable<String, ZipEntry> cClasses = getClassEntries(cInJar, cOutJar);
            final Hashtable<String, ZipEntry> sClasses = getClassEntries(sInJar, sOutJar);
            final HashSet<String> cAdded = new HashSet<String>();
            final HashSet<String> sAdded = new HashSet<String>();
            for (final Map.Entry<String, ZipEntry> entry : cClasses.entrySet()) {
                final String name = entry.getKey();
                final ZipEntry cEntry = entry.getValue();
                final ZipEntry sEntry = sClasses.get(name);
                if (sEntry == null) {
                    if (!MCPMerger.copyToServer.contains(name)) {
                        copyClass(cInJar, cEntry, cOutJar, null, true);
                        cAdded.add(name);
                    }
                    else {
                        copyClass(cInJar, cEntry, cOutJar, sOutJar, true);
                        cAdded.add(name);
                        sAdded.add(name);
                    }
                }
                else {
                    sClasses.remove(name);
                    final ClassInfo info = new ClassInfo(name);
                    MCPMerger.shared.put(name, info);
                    final byte[] cData = readEntry(cInJar, entry.getValue());
                    final byte[] sData = readEntry(sInJar, sEntry);
                    final byte[] data = processClass(cData, sData, info);
                    final ZipEntry newEntry = new ZipEntry(cEntry.getName());
                    cOutJar.putNextEntry(newEntry);
                    cOutJar.write(data);
                    sOutJar.putNextEntry(newEntry);
                    sOutJar.write(data);
                    cAdded.add(name);
                    sAdded.add(name);
                }
            }
            for (final Map.Entry<String, ZipEntry> entry : sClasses.entrySet()) {
                copyClass(sInJar, entry.getValue(), cOutJar, sOutJar, false);
            }
            for (final String name2 : new String[] { SideOnly.class.getName(), Side.class.getName() }) {
                final String eName = name2.replace(".", "/");
                final byte[] data2 = getClassBytes(name2);
                final ZipEntry newEntry2 = new ZipEntry(name2.replace(".", "/").concat(".class"));
                if (!cAdded.contains(eName)) {
                    cOutJar.putNextEntry(newEntry2);
                    cOutJar.write(data2);
                }
                if (!sAdded.contains(eName)) {
                    sOutJar.putNextEntry(newEntry2);
                    sOutJar.write(data2);
                }
            }
        }
        finally {
            if (cInJar != null) {
                try {
                    cInJar.close();
                }
                catch (final IOException ex) {}
            }
            if (sInJar != null) {
                try {
                    sInJar.close();
                }
                catch (final IOException ex2) {}
            }
            if (cOutJar != null) {
                try {
                    cOutJar.close();
                }
                catch (final IOException ex3) {}
            }
            if (sOutJar != null) {
                try {
                    sOutJar.close();
                }
                catch (final IOException ex4) {}
            }
        }
    }
    
    private static void copyClass(final ZipFile inJar, final ZipEntry entry, final ZipOutputStream outJar, final ZipOutputStream outJar2, final boolean isClientOnly) throws IOException {
        final ClassReader reader = new ClassReader(readEntry(inJar, entry));
        final ClassNode classNode = new ClassNode();
        reader.accept((ClassVisitor)classNode, 0);
        if (!MCPMerger.dontAnnotate.contains(classNode.name)) {
            if (classNode.visibleAnnotations == null) {
                classNode.visibleAnnotations = new ArrayList();
            }
            classNode.visibleAnnotations.add(getSideAnn(isClientOnly));
        }
        final ClassWriter writer = new ClassWriter(1);
        classNode.accept((ClassVisitor)writer);
        final byte[] data = writer.toByteArray();
        final ZipEntry newEntry = new ZipEntry(entry.getName());
        if (outJar != null) {
            outJar.putNextEntry(newEntry);
            outJar.write(data);
        }
        if (outJar2 != null) {
            outJar2.putNextEntry(newEntry);
            outJar2.write(data);
        }
    }
    
    private static AnnotationNode getSideAnn(final boolean isClientOnly) {
        final AnnotationNode ann = new AnnotationNode(Type.getDescriptor((Class)SideOnly.class));
        (ann.values = new ArrayList()).add("value");
        ann.values.add(new String[] { Type.getDescriptor((Class)Side.class), isClientOnly ? "CLIENT" : "SERVER" });
        return ann;
    }
    
    private static Hashtable<String, ZipEntry> getClassEntries(final ZipFile inFile, final ZipOutputStream outFile) throws IOException {
        final Hashtable<String, ZipEntry> ret = new Hashtable<String, ZipEntry>();
        for (final ZipEntry entry : Collections.list(inFile.entries())) {
            if (entry.isDirectory()) {
                outFile.putNextEntry(entry);
            }
            else {
                final String entryName = entry.getName();
                boolean filtered = false;
                for (final String filter : MCPMerger.dontProcess) {
                    if (entryName.startsWith(filter)) {
                        filtered = true;
                        break;
                    }
                }
                if (filtered || !entryName.endsWith(".class") || entryName.startsWith(".")) {
                    final ZipEntry newEntry = new ZipEntry(entry.getName());
                    outFile.putNextEntry(newEntry);
                    outFile.write(readEntry(inFile, entry));
                }
                else {
                    ret.put(entryName.replace(".class", ""), entry);
                }
            }
        }
        return ret;
    }
    
    private static byte[] readEntry(final ZipFile inFile, final ZipEntry entry) throws IOException {
        return readFully(inFile.getInputStream(entry));
    }
    
    private static byte[] readFully(final InputStream stream) throws IOException {
        final byte[] data = new byte[4096];
        final ByteArrayOutputStream entryBuffer = new ByteArrayOutputStream();
        int len;
        do {
            len = stream.read(data);
            if (len > 0) {
                entryBuffer.write(data, 0, len);
            }
        } while (len != -1);
        return entryBuffer.toByteArray();
    }
    
    public static byte[] processClass(final byte[] cIn, final byte[] sIn, final ClassInfo info) {
        final ClassNode cClassNode = getClassNode(cIn);
        final ClassNode sClassNode = getClassNode(sIn);
        processFields(cClassNode, sClassNode, info);
        processMethods(cClassNode, sClassNode, info);
        final ClassWriter writer = new ClassWriter(1);
        cClassNode.accept((ClassVisitor)writer);
        return writer.toByteArray();
    }
    
    private static ClassNode getClassNode(final byte[] data) {
        final ClassReader reader = new ClassReader(data);
        final ClassNode classNode = new ClassNode();
        reader.accept((ClassVisitor)classNode, 0);
        return classNode;
    }
    
    private static void processFields(final ClassNode cClass, final ClassNode sClass, final ClassInfo info) {
        final List<FieldNode> cFields = cClass.fields;
        final List<FieldNode> sFields = sClass.fields;
        int sI = 0;
        for (int x = 0; x < cFields.size(); ++x) {
            final FieldNode cF = cFields.get(x);
            if (sI < sFields.size()) {
                if (!cF.name.equals(sFields.get(sI).name)) {
                    boolean serverHas = false;
                    for (int y = sI + 1; y < sFields.size(); ++y) {
                        if (cF.name.equals(sFields.get(y).name)) {
                            serverHas = true;
                            break;
                        }
                    }
                    if (serverHas) {
                        boolean clientHas = false;
                        final FieldNode sF = sFields.get(sI);
                        for (int y2 = x + 1; y2 < cFields.size(); ++y2) {
                            if (sF.name.equals(cFields.get(y2).name)) {
                                clientHas = true;
                                break;
                            }
                        }
                        if (!clientHas) {
                            if (sF.visibleAnnotations == null) {
                                sF.visibleAnnotations = new ArrayList();
                            }
                            sF.visibleAnnotations.add(getSideAnn(false));
                            cFields.add(x++, sF);
                            info.sField.add(sF);
                        }
                    }
                    else {
                        if (cF.visibleAnnotations == null) {
                            cF.visibleAnnotations = new ArrayList();
                        }
                        cF.visibleAnnotations.add(getSideAnn(true));
                        sFields.add(sI, cF);
                        info.cField.add(cF);
                    }
                }
            }
            else {
                if (cF.visibleAnnotations == null) {
                    cF.visibleAnnotations = new ArrayList();
                }
                cF.visibleAnnotations.add(getSideAnn(true));
                sFields.add(sI, cF);
                info.cField.add(cF);
            }
            ++sI;
        }
        if (sFields.size() != cFields.size()) {
            for (int x = cFields.size(); x < sFields.size(); ++x) {
                final FieldNode sF2 = sFields.get(x);
                if (sF2.visibleAnnotations == null) {
                    sF2.visibleAnnotations = new ArrayList();
                }
                sF2.visibleAnnotations.add(getSideAnn(true));
                cFields.add(x++, sF2);
                info.sField.add(sF2);
            }
        }
    }
    
    private static void processMethods(final ClassNode cClass, final ClassNode sClass, final ClassInfo info) {
        final List<MethodNode> cMethods = cClass.methods;
        final List<MethodNode> sMethods = sClass.methods;
        final LinkedHashSet<MethodWrapper> allMethods = Sets.newLinkedHashSet();
        int cPos = 0;
        int sPos = 0;
        final int cLen = cMethods.size();
        final int sLen = sMethods.size();
        String lastName;
        String clientName = lastName = "";
        String serverName = "";
    Label_0153_Outer:
        while (cPos < cLen || sPos < sLen) {
            while (true) {
                while (sPos < sLen) {
                    final MethodNode sM = sMethods.get(sPos);
                    serverName = sM.name;
                    if (serverName.equals(lastName) || cPos == cLen) {
                        final MethodWrapper mw = new MethodWrapper(sM);
                        mw.server = true;
                        allMethods.add(mw);
                        if (++sPos < sLen) {
                            continue Label_0153_Outer;
                        }
                    }
                    while (cPos < cLen) {
                        final MethodNode cM = cMethods.get(cPos);
                        lastName = clientName;
                        clientName = cM.name;
                        if (!clientName.equals(lastName) && sPos != sLen) {
                            break;
                        }
                        final MethodWrapper mw = new MethodWrapper(cM);
                        mw.client = true;
                        allMethods.add(mw);
                        if (++cPos >= cLen) {
                            break;
                        }
                    }
                    continue Label_0153_Outer;
                }
                continue;
            }
        }
        cMethods.clear();
        sMethods.clear();
        final Iterator i$ = allMethods.iterator();
        while (i$.hasNext()) {
            final MethodWrapper mw = i$.next();
            cMethods.add(mw.node);
            sMethods.add(mw.node);
            if (mw.server && mw.client) {
                continue;
            }
            if (mw.node.visibleAnnotations == null) {
                mw.node.visibleAnnotations = Lists.newArrayListWithExpectedSize(1);
            }
            mw.node.visibleAnnotations.add(getSideAnn(mw.client));
            if (mw.client) {
                info.sMethods.add(mw.node);
            }
            else {
                info.cMethods.add(mw.node);
            }
        }
    }
    
    public static byte[] getClassBytes(final String name) throws IOException {
        InputStream classStream = null;
        try {
            classStream = MCPMerger.class.getResourceAsStream("/" + name.replace('.', '/').concat(".class"));
            return readFully(classStream);
        }
        finally {
            if (classStream != null) {
                try {
                    classStream.close();
                }
                catch (final IOException ex) {}
            }
        }
    }
    
    static {
        MCPMerger.clients = new Hashtable<String, ClassInfo>();
        MCPMerger.shared = new Hashtable<String, ClassInfo>();
        MCPMerger.servers = new Hashtable<String, ClassInfo>();
        MCPMerger.copyToServer = new HashSet<String>();
        MCPMerger.copyToClient = new HashSet<String>();
        MCPMerger.dontAnnotate = new HashSet<String>();
        MCPMerger.dontProcess = new HashSet<String>();
    }
    
    private static class ClassInfo
    {
        public String name;
        public ArrayList<FieldNode> cField;
        public ArrayList<FieldNode> sField;
        public ArrayList<MethodNode> cMethods;
        public ArrayList<MethodNode> sMethods;
        
        public ClassInfo(final String name) {
            this.cField = new ArrayList<FieldNode>();
            this.sField = new ArrayList<FieldNode>();
            this.cMethods = new ArrayList<MethodNode>();
            this.sMethods = new ArrayList<MethodNode>();
            this.name = name;
        }
        
        public boolean isSame() {
            return this.cField.size() == 0 && this.sField.size() == 0 && this.cMethods.size() == 0 && this.sMethods.size() == 0;
        }
    }
    
    private static class MethodWrapper
    {
        private MethodNode node;
        public boolean client;
        public boolean server;
        
        public MethodWrapper(final MethodNode node) {
            this.node = node;
        }
        
        @Override
        public boolean equals(final Object obj) {
            if (obj == null || !(obj instanceof MethodWrapper)) {
                return false;
            }
            final MethodWrapper mw = (MethodWrapper)obj;
            final boolean eq = Objects.equal((Object)this.node.name, (Object)mw.node.name) && Objects.equal((Object)this.node.desc, (Object)mw.node.desc);
            if (eq) {
                mw.client |= this.client;
                mw.server |= this.server;
                this.client |= mw.client;
                this.server |= mw.server;
            }
            return eq;
        }
        
        @Override
        public int hashCode() {
            return Objects.hashCode(new Object[] { this.node.name, this.node.desc });
        }
        
        @Override
        public String toString() {
            return Objects.toStringHelper((Object)this).add("name", (Object)this.node.name).add("desc", (Object)this.node.desc).add("server", this.server).add("client", this.client).toString();
        }
    }
}



================================================
FILE: cpw/mods/fml/common/asm/transformers/ModAPITransformer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.asm.transformers;

import java.util.Map;
import java.util.List;
import com.google.common.collect.Sets;
import java.util.Set;
import com.google.common.collect.ArrayListMultimap;
import java.util.ListIterator;
import org.objectweb.asm.tree.MethodNode;
import java.util.Iterator;
import org.objectweb.asm.ClassWriter;
import cpw.mods.fml.common.ModAPIManager;
import cpw.mods.fml.common.Loader;
import cpw.mods.fml.relauncher.FMLRelaunchLog;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;
import cpw.mods.fml.common.discovery.ASMDataTable;
import com.google.common.collect.ListMultimap;
import net.minecraft.launchwrapper.IClassTransformer;

public class ModAPITransformer implements IClassTransformer
{
    private static final boolean logDebugInfo;
    private ListMultimap<String, ASMDataTable.ASMData> optionals;
    
    public byte[] transform(final String name, final String transformedName, final byte[] basicClass) {
        if (this.optionals == null || !this.optionals.containsKey((Object)name)) {
            return basicClass;
        }
        final ClassNode classNode = new ClassNode();
        final ClassReader classReader = new ClassReader(basicClass);
        classReader.accept((ClassVisitor)classNode, 0);
        if (ModAPITransformer.logDebugInfo) {
            FMLRelaunchLog.finest("Optional removal - found optionals for class %s - processing", name);
        }
        for (final ASMDataTable.ASMData optional : this.optionals.get((Object)name)) {
            final String modId = optional.getAnnotationInfo().get("modid");
            if (Loader.isModLoaded(modId) || ModAPIManager.INSTANCE.hasAPI(modId)) {
                if (!ModAPITransformer.logDebugInfo) {
                    continue;
                }
                FMLRelaunchLog.finest("Optional removal skipped - mod present %s", modId);
            }
            else {
                if (ModAPITransformer.logDebugInfo) {
                    FMLRelaunchLog.finest("Optional on %s triggered - mod missing %s", name, modId);
                }
                if (optional.getAnnotationInfo().containsKey("iface")) {
                    Boolean stripRefs = optional.getAnnotationInfo().get("striprefs");
                    if (stripRefs == null) {
                        stripRefs = Boolean.FALSE;
                    }
                    this.stripInterface(classNode, optional.getAnnotationInfo().get("iface"), stripRefs);
                }
                else {
                    this.stripMethod(classNode, optional.getObjectName());
                }
            }
        }
        if (ModAPITransformer.logDebugInfo) {
            FMLRelaunchLog.finest("Optional removal - class %s processed", name);
        }
        final ClassWriter writer = new ClassWriter(1);
        classNode.accept((ClassVisitor)writer);
        return writer.toByteArray();
    }
    
    private void stripMethod(final ClassNode classNode, final String methodDescriptor) {
        final ListIterator<MethodNode> iterator = classNode.methods.listIterator();
        while (iterator.hasNext()) {
            final MethodNode method = iterator.next();
            if (methodDescriptor.equals(method.name + method.desc)) {
                iterator.remove();
                if (ModAPITransformer.logDebugInfo) {
                    FMLRelaunchLog.finest("Optional removal - method %s removed", methodDescriptor);
                }
                return;
            }
        }
        if (ModAPITransformer.logDebugInfo) {
            FMLRelaunchLog.finest("Optional removal - method %s NOT removed - not found", methodDescriptor);
        }
    }
    
    private void stripInterface(final ClassNode classNode, final String interfaceName, final boolean stripRefs) {
        final String ifaceName = interfaceName.replace('.', '/');
        final boolean found = classNode.interfaces.remove(ifaceName);
        if (found && ModAPITransformer.logDebugInfo) {
            FMLRelaunchLog.finest("Optional removal - interface %s removed", interfaceName);
        }
        if (!found && ModAPITransformer.logDebugInfo) {
            FMLRelaunchLog.finest("Optional removal - interface %s NOT removed - not found", interfaceName);
        }
        if (found && stripRefs) {
            if (ModAPITransformer.logDebugInfo) {
                FMLRelaunchLog.finest("Optional removal - interface %s - stripping method signature references", interfaceName);
            }
            final Iterator<MethodNode> iterator = classNode.methods.iterator();
            while (iterator.hasNext()) {
                final MethodNode node = iterator.next();
                if (node.desc.contains(ifaceName)) {
                    if (ModAPITransformer.logDebugInfo) {
                        FMLRelaunchLog.finest("Optional removal - interface %s - stripping method containing reference %s", interfaceName, node.name);
                    }
                    iterator.remove();
                }
            }
            if (ModAPITransformer.logDebugInfo) {
                FMLRelaunchLog.finest("Optional removal - interface %s - all method signature references stripped", interfaceName);
            }
        }
        else if (found && ModAPITransformer.logDebugInfo) {
            FMLRelaunchLog.finest("Optional removal - interface %s - NOT stripping method signature references", interfaceName);
        }
    }
    
    public void initTable(final ASMDataTable dataTable) {
        this.optionals = (ListMultimap<String, ASMDataTable.ASMData>)ArrayListMultimap.create();
        final Set<ASMDataTable.ASMData> interfaceLists = dataTable.getAll("cpw.mods.fml.common.Optional$InterfaceList");
        this.addData(this.unpackInterfaces(interfaceLists));
        final Set<ASMDataTable.ASMData> interfaces = dataTable.getAll("cpw.mods.fml.common.Optional$Interface");
        this.addData(interfaces);
        final Set<ASMDataTable.ASMData> methods = dataTable.getAll("cpw.mods.fml.common.Optional$Method");
        this.addData(methods);
    }
    
    private Set<ASMDataTable.ASMData> unpackInterfaces(final Set<ASMDataTable.ASMData> packedInterfaces) {
        final Set<ASMDataTable.ASMData> result = Sets.newHashSet();
        for (final ASMDataTable.ASMData data : packedInterfaces) {
            final List<Map<String, Object>> packedList = data.getAnnotationInfo().get("value");
            for (final Map<String, Object> packed : packedList) {
                final ASMDataTable.ASMData newData = data.copy(packed);
                result.add(newData);
            }
        }
        return result;
    }
    
    private void addData(final Set<ASMDataTable.ASMData> interfaces) {
        for (final ASMDataTable.ASMData data : interfaces) {
            this.optionals.put((Object)data.getClassName(), (Object)data);
        }
    }
    
    static {
        logDebugInfo = Boolean.valueOf(System.getProperty("fml.debugAPITransformer", "true"));
    }
}



================================================
FILE: cpw/mods/fml/common/asm/transformers/PatchingTransformer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.asm.transformers;

import cpw.mods.fml.common.patcher.ClassPatchManager;
import net.minecraft.launchwrapper.IClassTransformer;

public class PatchingTransformer implements IClassTransformer
{
    public byte[] transform(final String name, final String transformedName, final byte[] bytes) {
        return ClassPatchManager.INSTANCE.applyPatch(name, transformedName, bytes);
    }
}



================================================
FILE: cpw/mods/fml/common/asm/transformers/SideTransformer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.asm.transformers;

import cpw.mods.fml.relauncher.FMLLaunchHandler;
import org.objectweb.asm.Type;
import cpw.mods.fml.relauncher.SideOnly;
import java.util.Iterator;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.AnnotationNode;
import java.util.List;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;
import net.minecraft.launchwrapper.IClassTransformer;

public class SideTransformer implements IClassTransformer
{
    private static String SIDE;
    private static final boolean DEBUG = false;
    
    public byte[] transform(final String name, final String transformedName, final byte[] bytes) {
        if (bytes == null) {
            return null;
        }
        final ClassNode classNode = new ClassNode();
        final ClassReader classReader = new ClassReader(bytes);
        classReader.accept((ClassVisitor)classNode, 0);
        if (this.remove(classNode.visibleAnnotations, SideTransformer.SIDE)) {
            throw new RuntimeException(String.format("Attempted to load class %s for invalid side %s", classNode.name, SideTransformer.SIDE));
        }
        final Iterator<FieldNode> fields = classNode.fields.iterator();
        while (fields.hasNext()) {
            final FieldNode field = fields.next();
            if (this.remove(field.visibleAnnotations, SideTransformer.SIDE)) {
                fields.remove();
            }
        }
        final Iterator<MethodNode> methods = classNode.methods.iterator();
        while (methods.hasNext()) {
            final MethodNode method = methods.next();
            if (this.remove(method.visibleAnnotations, SideTransformer.SIDE)) {
                methods.remove();
            }
        }
        final ClassWriter writer = new ClassWriter(1);
        classNode.accept((ClassVisitor)writer);
        return writer.toByteArray();
    }
    
    private boolean remove(final List<AnnotationNode> anns, final String side) {
        if (anns == null) {
            return false;
        }
        for (final AnnotationNode ann : anns) {
            if (ann.desc.equals(Type.getDescriptor((Class)SideOnly.class)) && ann.values != null) {
                for (int x = 0; x < ann.values.size() - 1; x += 2) {
                    final Object key = ann.values.get(x);
                    final Object value = ann.values.get(x + 1);
                    if (key instanceof String && key.equals("value") && value instanceof String[] && !((String[])value)[1].equals(side)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    
    static {
        SideTransformer.SIDE = FMLLaunchHandler.side().name();
    }
}



================================================
FILE: cpw/mods/fml/common/asm/transformers/deobf/FMLDeobfuscatingRemapper.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.asm.transformers.deobf;

import java.util.Collection;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableMap;
import java.util.Arrays;
import com.google.common.collect.ImmutableList;
import com.google.common.base.Strings;
import cpw.mods.fml.common.FMLLog;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.ClassReader;
import cpw.mods.fml.common.patcher.ClassPatchManager;
import cpw.mods.fml.relauncher.FMLRelaunchLog;
import java.util.Iterator;
import java.util.List;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import com.google.common.collect.Iterables;
import com.google.common.base.Splitter;
import com.google.common.base.CharMatcher;
import com.google.common.io.InputSupplier;
import com.google.common.io.CharStreams;
import com.google.common.base.Charsets;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.File;
import com.google.common.collect.ImmutableBiMap;
import com.google.common.collect.Sets;
import com.google.common.collect.Maps;
import java.util.Set;
import net.minecraft.launchwrapper.LaunchClassLoader;
import java.util.Map;
import com.google.common.collect.BiMap;
import org.objectweb.asm.commons.Remapper;

public class FMLDeobfuscatingRemapper extends Remapper
{
    public static final FMLDeobfuscatingRemapper INSTANCE;
    private BiMap<String, String> classNameBiMap;
    private BiMap<String, String> mcpNameBiMap;
    private Map<String, Map<String, String>> rawFieldMaps;
    private Map<String, Map<String, String>> rawMethodMaps;
    private Map<String, Map<String, String>> fieldNameMaps;
    private Map<String, Map<String, String>> methodNameMaps;
    private LaunchClassLoader classLoader;
    private static final boolean DEBUG_REMAPPING;
    private static final boolean DUMP_FIELD_MAPS;
    private static final boolean DUMP_METHOD_MAPS;
    private Map<String, Map<String, String>> fieldDescriptions;
    private Set<String> negativeCacheMethods;
    private Set<String> negativeCacheFields;
    
    private FMLDeobfuscatingRemapper() {
        this.fieldDescriptions = Maps.newHashMap();
        this.negativeCacheMethods = Sets.newHashSet();
        this.negativeCacheFields = Sets.newHashSet();
        this.classNameBiMap = (BiMap<String, String>)ImmutableBiMap.of();
        this.mcpNameBiMap = (BiMap<String, String>)ImmutableBiMap.of();
    }
    
    public void setupLoadOnly(final String deobfFileName, final boolean loadAll) {
        try {
            final File mapData = new File(deobfFileName);
            final LZMAInputSupplier zis = new LZMAInputSupplier(new FileInputStream(mapData));
            final InputSupplier<InputStreamReader> srgSupplier = (InputSupplier<InputStreamReader>)CharStreams.newReaderSupplier((InputSupplier)zis, Charsets.UTF_8);
            final List<String> srgList = CharStreams.readLines((InputSupplier)srgSupplier);
            this.rawMethodMaps = Maps.newHashMap();
            this.rawFieldMaps = Maps.newHashMap();
            final ImmutableBiMap.Builder<String, String> builder = (ImmutableBiMap.Builder<String, String>)ImmutableBiMap.builder();
            final ImmutableBiMap.Builder<String, String> mcpBuilder = (ImmutableBiMap.Builder<String, String>)ImmutableBiMap.builder();
            final Splitter splitter = Splitter.on(CharMatcher.anyOf((CharSequence)": ")).omitEmptyStrings().trimResults();
            for (final String line : srgList) {
                final String[] parts = (String[])Iterables.toArray(splitter.split((CharSequence)line), (Class)String.class);
                final String typ = parts[0];
                if ("CL".equals(typ)) {
                    this.parseClass(builder, parts);
                    this.parseMCPClass(mcpBuilder, parts);
                }
                else if ("MD".equals(typ) && loadAll) {
                    this.parseMethod(parts);
                }
                else {
                    if (!"FD".equals(typ) || !loadAll) {
                        continue;
                    }
                    this.parseField(parts);
                }
            }
            this.classNameBiMap = (BiMap<String, String>)builder.build();
            mcpBuilder.put((Object)"BaseMod", (Object)"net/minecraft/src/BaseMod");
            mcpBuilder.put((Object)"ModLoader", (Object)"net/minecraft/src/ModLoader");
            mcpBuilder.put((Object)"EntityRendererProxy", (Object)"net/minecraft/src/EntityRendererProxy");
            mcpBuilder.put((Object)"MLProp", (Object)"net/minecraft/src/MLProp");
            mcpBuilder.put((Object)"TradeEntry", (Object)"net/minecraft/src/TradeEntry");
            this.mcpNameBiMap = (BiMap<String, String>)mcpBuilder.build();
        }
        catch (final IOException ioe) {
            Logger.getLogger("FML").log(Level.SEVERE, "An error occurred loading the deobfuscation map data", ioe);
        }
        this.methodNameMaps = Maps.newHashMapWithExpectedSize(this.rawMethodMaps.size());
        this.fieldNameMaps = Maps.newHashMapWithExpectedSize(this.rawFieldMaps.size());
    }
    
    public void setup(final File mcDir, final LaunchClassLoader classLoader, final String deobfFileName) {
        this.classLoader = classLoader;
        try {
            final InputStream classData = this.getClass().getResourceAsStream(deobfFileName);
            final LZMAInputSupplier zis = new LZMAInputSupplier(classData);
            final InputSupplier<InputStreamReader> srgSupplier = (InputSupplier<InputStreamReader>)CharStreams.newReaderSupplier((InputSupplier)zis, Charsets.UTF_8);
            final List<String> srgList = CharStreams.readLines((InputSupplier)srgSupplier);
            this.rawMethodMaps = Maps.newHashMap();
            this.rawFieldMaps = Maps.newHashMap();
            final ImmutableBiMap.Builder<String, String> builder = (ImmutableBiMap.Builder<String, String>)ImmutableBiMap.builder();
            final ImmutableBiMap.Builder<String, String> mcpBuilder = (ImmutableBiMap.Builder<String, String>)ImmutableBiMap.builder();
            final Splitter splitter = Splitter.on(CharMatcher.anyOf((CharSequence)": ")).omitEmptyStrings().trimResults();
            for (final String line : srgList) {
                final String[] parts = (String[])Iterables.toArray(splitter.split((CharSequence)line), (Class)String.class);
                final String typ = parts[0];
                if ("CL".equals(typ)) {
                    this.parseClass(builder, parts);
                    this.parseMCPClass(mcpBuilder, parts);
                }
                else if ("MD".equals(typ)) {
                    this.parseMethod(parts);
                }
                else {
                    if (!"FD".equals(typ)) {
                        continue;
                    }
                    this.parseField(parts);
                }
            }
            this.classNameBiMap = (BiMap<String, String>)builder.build();
            mcpBuilder.put((Object)"BaseMod", (Object)"net/minecraft/src/BaseMod");
            mcpBuilder.put((Object)"ModLoader", (Object)"net/minecraft/src/ModLoader");
            mcpBuilder.put((Object)"EntityRendererProxy", (Object)"net/minecraft/src/EntityRendererProxy");
            mcpBuilder.put((Object)"MLProp", (Object)"net/minecraft/src/MLProp");
            mcpBuilder.put((Object)"TradeEntry", (Object)"net/minecraft/src/TradeEntry");
            this.mcpNameBiMap = (BiMap<String, String>)mcpBuilder.build();
        }
        catch (final IOException ioe) {
            FMLRelaunchLog.log(Level.SEVERE, ioe, "An error occurred loading the deobfuscation map data", new Object[0]);
        }
        this.methodNameMaps = Maps.newHashMapWithExpectedSize(this.rawMethodMaps.size());
        this.fieldNameMaps = Maps.newHashMapWithExpectedSize(this.rawFieldMaps.size());
    }
    
    public boolean isRemappedClass(String className) {
        className = className.replace('.', '/');
        return this.classNameBiMap.containsKey((Object)className) || this.mcpNameBiMap.containsKey((Object)className) || (!this.classNameBiMap.isEmpty() && className.indexOf(47) == -1);
    }
    
    private void parseField(final String[] parts) {
        final String oldSrg = parts[1];
        final int lastOld = oldSrg.lastIndexOf(47);
        final String cl = oldSrg.substring(0, lastOld);
        final String oldName = oldSrg.substring(lastOld + 1);
        final String newSrg = parts[2];
        final int lastNew = newSrg.lastIndexOf(47);
        final String newName = newSrg.substring(lastNew + 1);
        if (!this.rawFieldMaps.containsKey(cl)) {
            this.rawFieldMaps.put(cl, Maps.newHashMap());
        }
        this.rawFieldMaps.get(cl).put(oldName + ":" + this.getFieldType(cl, oldName), newName);
        this.rawFieldMaps.get(cl).put(oldName + ":null", newName);
    }
    
    private String getFieldType(final String owner, final String name) {
        if (this.fieldDescriptions.containsKey(owner)) {
            return (String)this.fieldDescriptions.get(owner).get(name);
        }
        synchronized (this.fieldDescriptions) {
            try {
                final byte[] classBytes = ClassPatchManager.INSTANCE.getPatchedResource(owner, this.map(owner).replace('/', '.'), this.classLoader);
                if (classBytes == null) {
                    return null;
                }
                final ClassReader cr = new ClassReader(classBytes);
                final ClassNode classNode = new ClassNode();
                cr.accept((ClassVisitor)classNode, 7);
                final Map<String, String> resMap = Maps.newHashMap();
                for (final FieldNode fieldNode : classNode.fields) {
                    resMap.put(fieldNode.name, fieldNode.desc);
                }
                this.fieldDescriptions.put(owner, resMap);
                return resMap.get(name);
            }
            catch (final IOException e) {
                FMLLog.log(Level.SEVERE, e, "A critical exception occured reading a class file %s", owner);
                return null;
            }
        }
    }
    
    private void parseClass(final ImmutableBiMap.Builder<String, String> builder, final String[] parts) {
        builder.put((Object)parts[1], (Object)parts[2]);
    }
    
    private void parseMCPClass(final ImmutableBiMap.Builder<String, String> builder, final String[] parts) {
        final int clIdx = parts[2].lastIndexOf(47);
        builder.put((Object)("net/minecraft/src/" + parts[2].substring(clIdx + 1)), (Object)parts[2]);
    }
    
    private void parseMethod(final String[] parts) {
        final String oldSrg = parts[1];
        final int lastOld = oldSrg.lastIndexOf(47);
        final String cl = oldSrg.substring(0, lastOld);
        final String oldName = oldSrg.substring(lastOld + 1);
        final String sig = parts[2];
        final String newSrg = parts[3];
        final int lastNew = newSrg.lastIndexOf(47);
        final String newName = newSrg.substring(lastNew + 1);
        if (!this.rawMethodMaps.containsKey(cl)) {
            this.rawMethodMaps.put(cl, Maps.newHashMap());
        }
        this.rawMethodMaps.get(cl).put(oldName + sig, newName);
    }
    
    public String mapFieldName(final String owner, final String name, final String desc) {
        if (this.classNameBiMap == null || this.classNameBiMap.isEmpty()) {
            return name;
        }
        final Map<String, String> fieldMap = this.getFieldMap(owner);
        return (fieldMap != null && fieldMap.containsKey(name + ":" + desc)) ? fieldMap.get(name + ":" + desc) : name;
    }
    
    public String map(final String typeName) {
        if (this.classNameBiMap == null || this.classNameBiMap.isEmpty()) {
            return typeName;
        }
        final int dollarIdx = typeName.indexOf(36);
        final String realType = (dollarIdx > -1) ? typeName.substring(0, dollarIdx) : typeName;
        final String subType = (dollarIdx > -1) ? typeName.substring(dollarIdx + 1) : "";
        String result = (String)(this.classNameBiMap.containsKey((Object)realType) ? this.classNameBiMap.get((Object)realType) : (this.mcpNameBiMap.containsKey((Object)realType) ? this.mcpNameBiMap.get((Object)realType) : realType));
        result = ((dollarIdx > -1) ? (result + "$" + subType) : result);
        return result;
    }
    
    public String unmap(final String typeName) {
        if (this.classNameBiMap == null || this.classNameBiMap.isEmpty()) {
            return typeName;
        }
        final int dollarIdx = typeName.indexOf(36);
        final String realType = (dollarIdx > -1) ? typeName.substring(0, dollarIdx) : typeName;
        final String subType = (dollarIdx > -1) ? typeName.substring(dollarIdx + 1) : "";
        String result = (String)(this.classNameBiMap.containsValue((Object)realType) ? this.classNameBiMap.inverse().get((Object)realType) : (this.mcpNameBiMap.containsValue((Object)realType) ? this.mcpNameBiMap.inverse().get((Object)realType) : realType));
        result = ((dollarIdx > -1) ? (result + "$" + subType) : result);
        return result;
    }
    
    public String mapMethodName(final String owner, final String name, final String desc) {
        if (this.classNameBiMap == null || this.classNameBiMap.isEmpty()) {
            return name;
        }
        final Map<String, String> methodMap = this.getMethodMap(owner);
        final String methodDescriptor = name + desc;
        return (methodMap != null && methodMap.containsKey(methodDescriptor)) ? methodMap.get(methodDescriptor) : name;
    }
    
    private Map<String, String> getFieldMap(final String className) {
        if (!this.fieldNameMaps.containsKey(className) && !this.negativeCacheFields.contains(className)) {
            this.findAndMergeSuperMaps(className);
            if (!this.fieldNameMaps.containsKey(className)) {
                this.negativeCacheFields.add(className);
            }
            if (FMLDeobfuscatingRemapper.DUMP_FIELD_MAPS) {
                FMLRelaunchLog.finest("Field map for %s : %s", className, this.fieldNameMaps.get(className));
            }
        }
        return this.fieldNameMaps.get(className);
    }
    
    private Map<String, String> getMethodMap(final String className) {
        if (!this.methodNameMaps.containsKey(className) && !this.negativeCacheMethods.contains(className)) {
            this.findAndMergeSuperMaps(className);
            if (!this.methodNameMaps.containsKey(className)) {
                this.negativeCacheMethods.add(className);
            }
            if (FMLDeobfuscatingRemapper.DUMP_METHOD_MAPS) {
                FMLRelaunchLog.finest("Method map for %s : %s", className, this.methodNameMaps.get(className));
            }
        }
        return this.methodNameMaps.get(className);
    }
    
    private void findAndMergeSuperMaps(final String name) {
        try {
            String superName = null;
            String[] interfaces = new String[0];
            final byte[] classBytes = ClassPatchManager.INSTANCE.getPatchedResource(name, this.map(name), this.classLoader);
            if (classBytes != null) {
                final ClassReader cr = new ClassReader(classBytes);
                superName = cr.getSuperName();
                interfaces = cr.getInterfaces();
            }
            this.mergeSuperMaps(name, superName, interfaces);
        }
        catch (final IOException e) {
            e.printStackTrace();
        }
    }
    
    public void mergeSuperMaps(final String name, final String superName, final String[] interfaces) {
        if (this.classNameBiMap == null || this.classNameBiMap.isEmpty()) {
            return;
        }
        if (Strings.isNullOrEmpty(superName)) {
            return;
        }
        final List<String> allParents = (List<String>)ImmutableList.builder().add((Object)superName).addAll((Iterable)Arrays.asList(interfaces)).build();
        for (final String parentThing : allParents) {
            if (!this.methodNameMaps.containsKey(parentThing)) {
                this.findAndMergeSuperMaps(parentThing);
            }
        }
        final Map<String, String> methodMap = Maps.newHashMap();
        final Map<String, String> fieldMap = Maps.newHashMap();
        for (final String parentThing2 : allParents) {
            if (this.methodNameMaps.containsKey(parentThing2)) {
                methodMap.putAll(this.methodNameMaps.get(parentThing2));
            }
            if (this.fieldNameMaps.containsKey(parentThing2)) {
                fieldMap.putAll(this.fieldNameMaps.get(parentThing2));
            }
        }
        if (this.rawMethodMaps.containsKey(name)) {
            methodMap.putAll(this.rawMethodMaps.get(name));
        }
        if (this.rawFieldMaps.containsKey(name)) {
            fieldMap.putAll(this.rawFieldMaps.get(name));
        }
        this.methodNameMaps.put(name, (Map<String, String>)ImmutableMap.copyOf((Map)methodMap));
        this.fieldNameMaps.put(name, (Map<String, String>)ImmutableMap.copyOf((Map)fieldMap));
    }
    
    public Set<String> getObfedClasses() {
        return (Set<String>)ImmutableSet.copyOf((Collection)this.classNameBiMap.keySet());
    }
    
    static {
        INSTANCE = new FMLDeobfuscatingRemapper();
        DEBUG_REMAPPING = Boolean.parseBoolean(System.getProperty("fml.remappingDebug", "false"));
        DUMP_FIELD_MAPS = (Boolean.parseBoolean(System.getProperty("fml.remappingDebug.dumpFieldMaps", "false")) && FMLDeobfuscatingRemapper.DEBUG_REMAPPING);
        DUMP_METHOD_MAPS = (Boolean.parseBoolean(System.getProperty("fml.remappingDebug.dumpMethodMaps", "false")) && FMLDeobfuscatingRemapper.DEBUG_REMAPPING);
    }
}



================================================
FILE: cpw/mods/fml/common/asm/transformers/deobf/FMLRemappingAdapter.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.asm.transformers.deobf;

import org.objectweb.asm.commons.Remapper;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.commons.RemappingClassAdapter;

public class FMLRemappingAdapter extends RemappingClassAdapter
{
    public FMLRemappingAdapter(final ClassVisitor cv) {
        super(cv, (Remapper)FMLDeobfuscatingRemapper.INSTANCE);
    }
    
    public void visit(final int version, final int access, final String name, final String signature, final String superName, String[] interfaces) {
        if (interfaces == null) {
            interfaces = new String[0];
        }
        FMLDeobfuscatingRemapper.INSTANCE.mergeSuperMaps(name, superName, interfaces);
        super.visit(version, access, name, signature, superName, interfaces);
    }
}



================================================
FILE: cpw/mods/fml/common/asm/transformers/deobf/LZMAInputSupplier.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.asm.transformers.deobf;

import java.io.IOException;
import LZMA.LzmaInputStream;
import java.io.InputStream;
import com.google.common.io.InputSupplier;

public class LZMAInputSupplier implements InputSupplier<InputStream>
{
    private InputStream compressedData;
    
    public LZMAInputSupplier(final InputStream compressedData) {
        this.compressedData = compressedData;
    }
    
    public InputStream getInput() throws IOException {
        return (InputStream)new LzmaInputStream(this.compressedData);
    }
}



================================================
FILE: cpw/mods/fml/common/discovery/ASMDataTable.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.discovery;

import java.util.Set;
import java.util.Iterator;
import com.google.common.collect.ImmutableSetMultimap;
import com.google.common.base.Predicate;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import com.google.common.collect.HashMultimap;
import java.util.List;
import cpw.mods.fml.common.ModContainer;
import java.util.Map;
import com.google.common.collect.SetMultimap;

public class ASMDataTable
{
    private SetMultimap<String, ASMData> globalAnnotationData;
    private Map<ModContainer, SetMultimap<String, ASMData>> containerAnnotationData;
    private List<ModContainer> containers;
    private SetMultimap<String, ModCandidate> packageMap;
    
    public ASMDataTable() {
        this.globalAnnotationData = (SetMultimap<String, ASMData>)HashMultimap.create();
        this.containers = Lists.newArrayList();
        this.packageMap = (SetMultimap<String, ModCandidate>)HashMultimap.create();
    }
    
    public SetMultimap<String, ASMData> getAnnotationsFor(final ModContainer container) {
        if (this.containerAnnotationData == null) {
            final ImmutableMap.Builder<ModContainer, SetMultimap<String, ASMData>> mapBuilder = (ImmutableMap.Builder<ModContainer, SetMultimap<String, ASMData>>)ImmutableMap.builder();
            for (final ModContainer cont : this.containers) {
                final Multimap<String, ASMData> values = (Multimap<String, ASMData>)Multimaps.filterValues((Multimap)this.globalAnnotationData, (Predicate)new ModContainerPredicate(cont));
                mapBuilder.put((Object)cont, (Object)ImmutableSetMultimap.copyOf((Multimap)values));
            }
            this.containerAnnotationData = (Map<ModContainer, SetMultimap<String, ASMData>>)mapBuilder.build();
        }
        return this.containerAnnotationData.get(container);
    }
    
    public Set<ASMData> getAll(final String annotation) {
        return this.globalAnnotationData.get((Object)annotation);
    }
    
    public void addASMData(final ModCandidate candidate, final String annotation, final String className, final String objectName, final Map<String, Object> annotationInfo) {
        this.globalAnnotationData.put((Object)annotation, (Object)new ASMData(candidate, annotation, className, objectName, annotationInfo));
    }
    
    public void addContainer(final ModContainer container) {
        this.containers.add(container);
    }
    
    public void registerPackage(final ModCandidate modCandidate, final String pkg) {
        this.packageMap.put((Object)pkg, (Object)modCandidate);
    }
    
    public Set<ModCandidate> getCandidatesFor(final String pkg) {
        return this.packageMap.get((Object)pkg);
    }
    
    public static final class ASMData implements Cloneable
    {
        private ModCandidate candidate;
        private String annotationName;
        private String className;
        private String objectName;
        private Map<String, Object> annotationInfo;
        
        public ASMData(final ModCandidate candidate, final String annotationName, final String className, final String objectName, final Map<String, Object> info) {
            this.candidate = candidate;
            this.annotationName = annotationName;
            this.className = className;
            this.objectName = objectName;
            this.annotationInfo = info;
        }
        
        public ModCandidate getCandidate() {
            return this.candidate;
        }
        
        public String getAnnotationName() {
            return this.annotationName;
        }
        
        public String getClassName() {
            return this.className;
        }
        
        public String getObjectName() {
            return this.objectName;
        }
        
        public Map<String, Object> getAnnotationInfo() {
            return this.annotationInfo;
        }
        
        public ASMData copy(final Map<String, Object> newAnnotationInfo) {
            try {
                final ASMData clone = (ASMData)this.clone();
                clone.annotationInfo = newAnnotationInfo;
                return clone;
            }
            catch (final CloneNotSupportedException e) {
                throw new RuntimeException("Unpossible", e);
            }
        }
    }
    
    private static class ModContainerPredicate implements Predicate<ASMData>
    {
        private ModContainer container;
        
        public ModContainerPredicate(final ModContainer container) {
            this.container = container;
        }
        
        public boolean apply(final ASMData data) {
            return this.container.getSource().equals(data.candidate.getModContainer());
        }
    }
}



================================================
FILE: cpw/mods/fml/common/discovery/ContainerType.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.discovery;

import cpw.mods.fml.common.ModContainer;
import java.util.List;
import com.google.common.base.Throwables;

public enum ContainerType
{
    JAR((Class<? extends ITypeDiscoverer>)JarDiscoverer.class), 
    DIR((Class<? extends ITypeDiscoverer>)DirectoryDiscoverer.class);
    
    private ITypeDiscoverer discoverer;
    
    private ContainerType(final Class<? extends ITypeDiscoverer> discovererClass) {
        try {
            this.discoverer = (ITypeDiscoverer)discovererClass.newInstance();
        }
        catch (final Exception e) {
            throw Throwables.propagate((Throwable)e);
        }
    }
    
    public List<ModContainer> findMods(final ModCandidate candidate, final ASMDataTable table) {
        return this.discoverer.discover(candidate, table);
    }
}



================================================
FILE: cpw/mods/fml/common/discovery/DirectoryDiscoverer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.discovery;

import java.util.regex.Matcher;
import cpw.mods.fml.common.ModContainerFactory;
import com.google.common.base.Throwables;
import cpw.mods.fml.common.LoaderException;
import java.util.logging.Level;
import cpw.mods.fml.common.discovery.asm.ASMModParser;
import java.util.Arrays;
import java.io.FileFilter;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.File;
import java.util.Iterator;
import cpw.mods.fml.common.MetadataCollection;
import cpw.mods.fml.common.FMLLog;
import com.google.common.collect.Lists;
import cpw.mods.fml.common.ModContainer;
import java.util.List;

public class DirectoryDiscoverer implements ITypeDiscoverer
{
    private ASMDataTable table;
    
    @Override
    public List<ModContainer> discover(final ModCandidate candidate, final ASMDataTable table) {
        this.table = table;
        final List<ModContainer> found = Lists.newArrayList();
        FMLLog.fine("Examining directory %s for potential mods", candidate.getModContainer().getName());
        this.exploreFileSystem("", candidate.getModContainer(), found, candidate, null);
        for (final ModContainer mc : found) {
            table.addContainer(mc);
        }
        return found;
    }
    
    public void exploreFileSystem(final String path, final File modDir, final List<ModContainer> harvestedMods, final ModCandidate candidate, MetadataCollection mc) {
        if (path.length() == 0) {
            final File metadata = new File(modDir, "mcmod.info");
            try {
                final FileInputStream fis = new FileInputStream(metadata);
                mc = MetadataCollection.from(fis, modDir.getName());
                fis.close();
                FMLLog.fine("Found an mcmod.info file in directory %s", modDir.getName());
            }
            catch (final Exception e) {
                mc = MetadataCollection.from(null, "");
                FMLLog.fine("No mcmod.info file found in directory %s", modDir.getName());
            }
        }
        final File[] content = modDir.listFiles(new ClassFilter());
        Arrays.sort(content);
        for (final File file : content) {
            if (file.isDirectory()) {
                FMLLog.finest("Recursing into package %s", path + file.getName());
                this.exploreFileSystem(path + file.getName() + ".", file, harvestedMods, candidate, mc);
            }
            else {
                final Matcher match = DirectoryDiscoverer.classFile.matcher(file.getName());
                if (match.matches()) {
                    ASMModParser modParser = null;
                    try {
                        final FileInputStream fis2 = new FileInputStream(file);
                        modParser = new ASMModParser(fis2);
                        fis2.close();
                        candidate.addClassEntry(path + file.getName());
                    }
                    catch (final LoaderException e2) {
                        FMLLog.log(Level.SEVERE, e2, "There was a problem reading the file %s - probably this is a corrupt file", file.getPath());
                        throw e2;
                    }
                    catch (final Exception e3) {
                        Throwables.propagate((Throwable)e3);
                    }
                    modParser.validate();
                    modParser.sendToTable(this.table, candidate);
                    final ModContainer container = ModContainerFactory.instance().build(modParser, candidate.getModContainer(), candidate);
                    if (container != null) {
                        harvestedMods.add(container);
                        container.bindMetadata(mc);
                    }
                }
            }
        }
    }
    
    private class ClassFilter implements FileFilter
    {
        @Override
        public boolean accept(final File file) {
            return (file.isFile() && ITypeDiscoverer.classFile.matcher(file.getName()).find()) || file.isDirectory();
        }
    }
}



================================================
FILE: cpw/mods/fml/common/discovery/ITypeDiscoverer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.discovery;

import cpw.mods.fml.common.ModContainer;
import java.util.List;
import java.util.regex.Pattern;

public interface ITypeDiscoverer
{
    public static final Pattern classFile = Pattern.compile("([^\\s$]+).class$");
    
    List<ModContainer> discover(final ModCandidate p0, final ASMDataTable p1);
}



================================================
FILE: cpw/mods/fml/common/discovery/JarDiscoverer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.discovery;

import java.util.regex.Matcher;
import java.util.Iterator;
import cpw.mods.fml.common.ModContainerFactory;
import cpw.mods.fml.common.LoaderException;
import java.util.logging.Level;
import cpw.mods.fml.common.discovery.asm.ASMModParser;
import java.util.zip.ZipEntry;
import java.util.Collections;
import java.io.InputStream;
import cpw.mods.fml.common.MetadataCollection;
import java.util.jar.JarFile;
import cpw.mods.fml.common.FMLLog;
import com.google.common.collect.Lists;
import cpw.mods.fml.common.ModContainer;
import java.util.List;

public class JarDiscoverer implements ITypeDiscoverer
{
    @Override
    public List<ModContainer> discover(final ModCandidate candidate, final ASMDataTable table) {
        final List<ModContainer> foundMods = Lists.newArrayList();
        FMLLog.fine("Examining file %s for potential mods", candidate.getModContainer().getName());
        JarFile jar = null;
        try {
            jar = new JarFile(candidate.getModContainer());
            if (jar.getManifest() != null && (jar.getManifest().getMainAttributes().get("FMLCorePlugin") != null || jar.getManifest().getMainAttributes().get("TweakClass") != null)) {
                FMLLog.finest("Ignoring coremod or tweak system %s", candidate.getModContainer());
                return foundMods;
            }
            final ZipEntry modInfo = jar.getEntry("mcmod.info");
            MetadataCollection mc = null;
            if (modInfo != null) {
                FMLLog.finer("Located mcmod.info file in file %s", candidate.getModContainer().getName());
                mc = MetadataCollection.from(jar.getInputStream(modInfo), candidate.getModContainer().getName());
            }
            else {
                FMLLog.fine("The mod container %s appears to be missing an mcmod.info file", candidate.getModContainer().getName());
                mc = MetadataCollection.from(null, "");
            }
            for (final ZipEntry ze : Collections.list(jar.entries())) {
                if (ze.getName() != null && ze.getName().startsWith("__MACOSX")) {
                    continue;
                }
                final Matcher match = JarDiscoverer.classFile.matcher(ze.getName());
                if (!match.matches()) {
                    continue;
                }
                ASMModParser modParser;
                try {
                    modParser = new ASMModParser(jar.getInputStream(ze));
                    candidate.addClassEntry(ze.getName());
                }
                catch (final LoaderException e) {
                    FMLLog.log(Level.SEVERE, e, "There was a problem reading the entry %s in the jar %s - probably a corrupt zip", ze.getName(), candidate.getModContainer().getPath());
                    jar.close();
                    throw e;
                }
                modParser.validate();
                modParser.sendToTable(table, candidate);
                final ModContainer container = ModContainerFactory.instance().build(modParser, candidate.getModContainer(), candidate);
                if (container == null) {
                    continue;
                }
                table.addContainer(container);
                foundMods.add(container);
                container.bindMetadata(mc);
            }
        }
        catch (final Exception e2) {
            FMLLog.log(Level.WARNING, e2, "Zip file %s failed to read properly, it will be ignored", candidate.getModContainer().getName());
        }
        finally {
            if (jar != null) {
                try {
                    jar.close();
                }
                catch (final Exception ex) {}
            }
        }
        return foundMods;
    }
}



================================================
FILE: cpw/mods/fml/common/discovery/ModCandidate.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.discovery;

import cpw.mods.fml.common.FMLLog;
import com.google.common.collect.Sets;
import com.google.common.collect.Lists;
import cpw.mods.fml.common.ModContainer;
import java.util.Set;
import cpw.mods.fml.common.discovery.asm.ASMModParser;
import java.util.List;
import java.io.File;

public class ModCandidate
{
    private File classPathRoot;
    private File modContainer;
    private ContainerType sourceType;
    private boolean classpath;
    private List<String> baseModTypes;
    private boolean isMinecraft;
    private List<ASMModParser> baseModCandidateTypes;
    private Set<String> foundClasses;
    private List<ModContainer> mods;
    private List<String> packages;
    private ASMDataTable table;
    
    public ModCandidate(final File classPathRoot, final File modContainer, final ContainerType sourceType) {
        this(classPathRoot, modContainer, sourceType, false, false);
    }
    
    public ModCandidate(final File classPathRoot, final File modContainer, final ContainerType sourceType, final boolean isMinecraft, final boolean classpath) {
        this.baseModTypes = Lists.newArrayList();
        this.baseModCandidateTypes = Lists.newArrayListWithCapacity(1);
        this.foundClasses = Sets.newHashSet();
        this.packages = Lists.newArrayList();
        this.classPathRoot = classPathRoot;
        this.modContainer = modContainer;
        this.sourceType = sourceType;
        this.isMinecraft = isMinecraft;
        this.classpath = classpath;
    }
    
    public File getClassPathRoot() {
        return this.classPathRoot;
    }
    
    public File getModContainer() {
        return this.modContainer;
    }
    
    public ContainerType getSourceType() {
        return this.sourceType;
    }
    
    public List<ModContainer> explore(final ASMDataTable table) {
        this.table = table;
        this.mods = this.sourceType.findMods(this, table);
        if (!this.baseModCandidateTypes.isEmpty()) {
            FMLLog.info("Attempting to reparse the mod container %s", this.getModContainer().getName());
            this.mods = this.sourceType.findMods(this, table);
        }
        return this.mods;
    }
    
    public void addClassEntry(final String name) {
        String className = name.substring(0, name.lastIndexOf(46));
        this.foundClasses.add(className.replace('.', '/'));
        className = className.replace('/', '.');
        final int pkgIdx = className.lastIndexOf(46);
        if (pkgIdx > -1) {
            final String pkg = className.substring(0, pkgIdx);
            this.packages.add(pkg);
            this.table.registerPackage(this, pkg);
        }
    }
    
    public boolean isClasspath() {
        return this.classpath;
    }
    
    public void rememberBaseModType(final String className) {
        this.baseModTypes.add(className);
    }
    
    public List<String> getRememberedBaseMods() {
        return this.baseModTypes;
    }
    
    public boolean isMinecraftJar() {
        return this.isMinecraft;
    }
    
    public void rememberModCandidateType(final ASMModParser modParser) {
        this.baseModCandidateTypes.add(modParser);
    }
    
    public Set<String> getClassList() {
        return this.foundClasses;
    }
    
    public List<ModContainer> getContainedMods() {
        return this.mods;
    }
    
    public List<String> getContainedPackages() {
        return this.packages;
    }
}



================================================
FILE: cpw/mods/fml/common/discovery/ModDiscoverer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.discovery;

import java.util.Iterator;
import com.google.common.base.Throwables;
import cpw.mods.fml.common.LoaderException;
import java.util.logging.Level;
import java.util.Collection;
import cpw.mods.fml.common.ModContainer;
import java.util.regex.Matcher;
import java.util.Arrays;
import java.util.Comparator;
import cpw.mods.fml.common.FMLLog;
import cpw.mods.fml.relauncher.CoreModManager;
import com.google.common.collect.ImmutableList;
import cpw.mods.fml.common.ModClassLoader;
import com.google.common.collect.Lists;
import java.io.File;
import java.util.List;
import java.util.regex.Pattern;

public class ModDiscoverer
{
    private static Pattern zipJar;
    private List<ModCandidate> candidates;
    private ASMDataTable dataTable;
    private List<File> nonModLibs;
    
    public ModDiscoverer() {
        this.candidates = Lists.newArrayList();
        this.dataTable = new ASMDataTable();
        this.nonModLibs = Lists.newArrayList();
    }
    
    public void findClasspathMods(final ModClassLoader modClassLoader) {
        final List<String> knownLibraries = (List<String>)ImmutableList.builder().addAll((Iterable)modClassLoader.getDefaultLibraries()).addAll((Iterable)CoreModManager.getLoadedCoremods()).addAll((Iterable)CoreModManager.getReparseableCoremods()).build();
        final File[] minecraftSources = modClassLoader.getParentSources();
        if (minecraftSources.length == 1 && minecraftSources[0].isFile()) {
            FMLLog.fine("Minecraft is a file at %s, loading", minecraftSources[0].getAbsolutePath());
            this.candidates.add(new ModCandidate(minecraftSources[0], minecraftSources[0], ContainerType.JAR, true, true));
        }
        else {
            for (int i = 0; i < minecraftSources.length; ++i) {
                if (minecraftSources[i].isFile()) {
                    if (knownLibraries.contains(minecraftSources[i].getName())) {
                        FMLLog.finer("Skipping known library file %s", minecraftSources[i].getAbsolutePath());
                    }
                    else {
                        FMLLog.fine("Found a minecraft related file at %s, examining for mod candidates", minecraftSources[i].getAbsolutePath());
                        this.candidates.add(new ModCandidate(minecraftSources[i], minecraftSources[i], ContainerType.JAR, i == 0, true));
                    }
                }
                else if (minecraftSources[i].isDirectory()) {
                    FMLLog.fine("Found a minecraft related directory at %s, examining for mod candidates", minecraftSources[i].getAbsolutePath());
                    this.candidates.add(new ModCandidate(minecraftSources[i], minecraftSources[i], ContainerType.DIR, i == 0, true));
                }
            }
        }
    }
    
    public void findModDirMods(final File modsDir) {
        final File[] modList = modsDir.listFiles();
        Arrays.sort(modList, new Comparator<File>() {
            @Override
            public int compare(final File o1, final File o2) {
                return o1.getName().compareToIgnoreCase(o2.getName());
            }
        });
        for (final File modFile : modList) {
            if (CoreModManager.getLoadedCoremods().contains(modFile.getName())) {
                FMLLog.finer("Skipping already parsed coremod or tweaker %s", modFile.getName());
            }
            else if (modFile.isDirectory()) {
                FMLLog.fine("Found a candidate mod directory %s", modFile.getName());
                this.candidates.add(new ModCandidate(modFile, modFile, ContainerType.DIR));
            }
            else {
                final Matcher matcher = ModDiscoverer.zipJar.matcher(modFile.getName());
                if (matcher.matches()) {
                    FMLLog.fine("Found a candidate zip or jar file %s", matcher.group(0));
                    this.candidates.add(new ModCandidate(modFile, modFile, ContainerType.JAR));
                }
                else {
                    FMLLog.fine("Ignoring unknown file %s in mods directory", modFile.getName());
                }
            }
        }
    }
    
    public List<ModContainer> identifyMods() {
        final List<ModContainer> modList = Lists.newArrayList();
        for (final ModCandidate candidate : this.candidates) {
            try {
                final List<ModContainer> mods = candidate.explore(this.dataTable);
                if (mods.isEmpty() && !candidate.isClasspath()) {
                    this.nonModLibs.add(candidate.getModContainer());
                }
                else {
                    modList.addAll(mods);
                }
            }
            catch (final LoaderException le) {
                FMLLog.log(Level.WARNING, le, "Identified a problem with the mod candidate %s, ignoring this source", candidate.getModContainer());
            }
            catch (final Throwable t) {
                Throwables.propagate(t);
            }
        }
        return modList;
    }
    
    public ASMDataTable getASMTable() {
        return this.dataTable;
    }
    
    public List<File> getNonModLibs() {
        return this.nonModLibs;
    }
    
    static {
        ModDiscoverer.zipJar = Pattern.compile("(.+).(zip|jar)$");
    }
}



================================================
FILE: cpw/mods/fml/common/discovery/asm/ASMModParser.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.discovery.asm;

import java.util.Iterator;
import cpw.mods.fml.common.discovery.ModCandidate;
import cpw.mods.fml.common.discovery.ASMDataTable;
import java.util.List;
import java.util.Collections;
import com.google.common.base.Objects;
import com.google.common.base.Strings;
import java.io.IOException;
import cpw.mods.fml.common.LoaderException;
import cpw.mods.fml.common.FMLLog;
import java.util.logging.Level;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassReader;
import com.google.common.collect.Lists;
import java.io.InputStream;
import java.util.LinkedList;
import org.objectweb.asm.Type;

public class ASMModParser
{
    private Type asmType;
    private int classVersion;
    private Type asmSuperType;
    private LinkedList<ModAnnotation> annotations;
    private String baseModProperties;
    
    public ASMModParser(final InputStream stream) throws IOException {
        this.annotations = Lists.newLinkedList();
        try {
            final ClassReader reader = new ClassReader(stream);
            reader.accept((ClassVisitor)new ModClassVisitor(this), 0);
        }
        catch (final Exception ex) {
            FMLLog.log(Level.SEVERE, ex, "Unable to read a class file correctly", new Object[0]);
            throw new LoaderException(ex);
        }
    }
    
    public void beginNewTypeName(final String typeQName, final int classVersion, final String superClassQName) {
        this.asmType = Type.getObjectType(typeQName);
        this.classVersion = classVersion;
        this.asmSuperType = (Strings.isNullOrEmpty(superClassQName) ? null : Type.getObjectType(superClassQName));
    }
    
    public void startClassAnnotation(final String annotationName) {
        final ModAnnotation ann = new ModAnnotation(AnnotationType.CLASS, Type.getType(annotationName), this.asmType.getClassName());
        this.annotations.addFirst(ann);
    }
    
    public void addAnnotationProperty(final String key, final Object value) {
        this.annotations.getFirst().addProperty(key, value);
    }
    
    public void startFieldAnnotation(final String fieldName, final String annotationName) {
        final ModAnnotation ann = new ModAnnotation(AnnotationType.FIELD, Type.getType(annotationName), fieldName);
        this.annotations.addFirst(ann);
    }
    
    @Override
    public String toString() {
        return Objects.toStringHelper("ASMAnnotationDiscoverer").add("className", (Object)this.asmType.getClassName()).add("classVersion", this.classVersion).add("superName", (Object)this.asmSuperType.getClassName()).add("annotations", (Object)this.annotations).add("isBaseMod", this.isBaseMod(Collections.emptyList())).add("baseModProperties", (Object)this.baseModProperties).toString();
    }
    
    public Type getASMType() {
        return this.asmType;
    }
    
    public int getClassVersion() {
        return this.classVersion;
    }
    
    public Type getASMSuperType() {
        return this.asmSuperType;
    }
    
    public LinkedList<ModAnnotation> getAnnotations() {
        return this.annotations;
    }
    
    public void validate() {
    }
    
    public boolean isBaseMod(final List<String> rememberedTypes) {
        return this.getASMSuperType().equals((Object)Type.getType("LBaseMod;")) || this.getASMSuperType().equals((Object)Type.getType("Lnet/minecraft/src/BaseMod;")) || rememberedTypes.contains(this.getASMSuperType().getClassName());
    }
    
    public void setBaseModProperties(final String foundProperties) {
        this.baseModProperties = foundProperties;
    }
    
    public String getBaseModProperties() {
        return this.baseModProperties;
    }
    
    public void sendToTable(final ASMDataTable table, final ModCandidate candidate) {
        for (final ModAnnotation ma : this.annotations) {
            table.addASMData(candidate, ma.asmType.getClassName(), this.asmType.getClassName(), ma.member, ma.values);
        }
    }
    
    public void addAnnotationArray(final String name) {
        this.annotations.getFirst().addArray(name);
    }
    
    public void addAnnotationEnumProperty(final String name, final String desc, final String value) {
        this.annotations.getFirst().addEnumProperty(name, desc, value);
    }
    
    public void endArray() {
        this.annotations.getFirst().endArray();
    }
    
    public void addSubAnnotation(final String name, final String desc) {
        final ModAnnotation ma = this.annotations.getFirst();
        this.annotations.addFirst(ma.addChildAnnotation(name, desc));
    }
    
    public void endSubAnnotation() {
        final ModAnnotation child = this.annotations.removeFirst();
        this.annotations.addLast(child);
    }
    
    public void startMethodAnnotation(final String methodName, final String methodDescriptor, final String annotationName) {
        final ModAnnotation ann = new ModAnnotation(AnnotationType.METHOD, Type.getType(annotationName), methodName + methodDescriptor);
        this.annotations.addFirst(ann);
    }
    
    enum AnnotationType
    {
        CLASS, 
        FIELD, 
        METHOD, 
        SUBTYPE;
    }
}



================================================
FILE: cpw/mods/fml/common/discovery/asm/ModAnnotation.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.discovery.asm;

import com.google.common.collect.Lists;
import com.google.common.base.Objects;
import com.google.common.collect.Maps;
import java.util.ArrayList;
import java.util.Map;
import org.objectweb.asm.Type;

public class ModAnnotation
{
    ASMModParser.AnnotationType type;
    Type asmType;
    String member;
    Map<String, Object> values;
    private ArrayList<Object> arrayList;
    private Object array;
    private String arrayName;
    private ModAnnotation parent;
    
    public ModAnnotation(final ASMModParser.AnnotationType type, final Type asmType, final String member) {
        this.values = Maps.newHashMap();
        this.type = type;
        this.asmType = asmType;
        this.member = member;
    }
    
    public ModAnnotation(final ASMModParser.AnnotationType type, final Type asmType, final ModAnnotation parent) {
        this.values = Maps.newHashMap();
        this.type = type;
        this.asmType = asmType;
        this.parent = parent;
    }
    
    @Override
    public String toString() {
        return Objects.toStringHelper("Annotation").add("type", (Object)this.type).add("name", (Object)this.asmType.getClassName()).add("member", (Object)this.member).add("values", (Object)this.values).toString();
    }
    
    public ASMModParser.AnnotationType getType() {
        return this.type;
    }
    
    public Type getASMType() {
        return this.asmType;
    }
    
    public String getMember() {
        return this.member;
    }
    
    public Map<String, Object> getValues() {
        return this.values;
    }
    
    public void addArray(final String name) {
        this.arrayList = Lists.newArrayList();
        this.arrayName = name;
    }
    
    public void addProperty(final String key, final Object value) {
        if (this.arrayList != null) {
            this.arrayList.add(value);
        }
        else {
            this.values.put(key, value);
        }
    }
    
    public void addEnumProperty(final String key, final String enumName, final String value) {
        this.values.put(key, new EnumHolder(enumName, value));
    }
    
    public void endArray() {
        this.values.put(this.arrayName, this.arrayList);
        this.arrayList = null;
    }
    
    public ModAnnotation addChildAnnotation(final String name, final String desc) {
        final ModAnnotation child = new ModAnnotation(ASMModParser.AnnotationType.SUBTYPE, Type.getType(desc), this);
        if (this.arrayList != null) {
            this.arrayList.add(child.getValues());
        }
        return child;
    }
    
    public class EnumHolder
    {
        private String desc;
        private String value;
        
        public EnumHolder(final String desc, final String value) {
            this.desc = desc;
            this.value = value;
        }
    }
}



================================================
FILE: cpw/mods/fml/common/discovery/asm/ModAnnotationVisitor.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.discovery.asm;

import org.objectweb.asm.AnnotationVisitor;

public class ModAnnotationVisitor extends AnnotationVisitor
{
    private ASMModParser discoverer;
    private boolean array;
    private String name;
    private boolean isSubAnnotation;
    
    public ModAnnotationVisitor(final ASMModParser discoverer) {
        super(262144);
        this.discoverer = discoverer;
    }
    
    public ModAnnotationVisitor(final ASMModParser discoverer, final String name) {
        this(discoverer);
        this.array = true;
        discoverer.addAnnotationArray(this.name = name);
    }
    
    public ModAnnotationVisitor(final ASMModParser discoverer, final boolean isSubAnnotation) {
        this(discoverer);
        this.isSubAnnotation = true;
    }
    
    public void visit(final String key, final Object value) {
        this.discoverer.addAnnotationProperty(key, value);
    }
    
    public void visitEnum(final String name, final String desc, final String value) {
        this.discoverer.addAnnotationEnumProperty(name, desc, value);
    }
    
    public AnnotationVisitor visitArray(final String name) {
        return new ModAnnotationVisitor(this.discoverer, name);
    }
    
    public AnnotationVisitor visitAnnotation(final String name, final String desc) {
        this.discoverer.addSubAnnotation(name, desc);
        return new ModAnnotationVisitor(this.discoverer, true);
    }
    
    public void visitEnd() {
        if (this.array) {
            this.discoverer.endArray();
        }
        if (this.isSubAnnotation) {
            this.discoverer.endSubAnnotation();
        }
    }
}



================================================
FILE: cpw/mods/fml/common/discovery/asm/ModClassVisitor.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.discovery.asm;

import org.objectweb.asm.Type;
import java.util.Collections;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.FieldVisitor;
import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.ClassVisitor;

public class ModClassVisitor extends ClassVisitor
{
    private ASMModParser discoverer;
    
    public ModClassVisitor(final ASMModParser discoverer) {
        super(262144);
        this.discoverer = discoverer;
    }
    
    public void visit(final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces) {
        this.discoverer.beginNewTypeName(name, version, superName);
    }
    
    public AnnotationVisitor visitAnnotation(final String annotationName, final boolean runtimeVisible) {
        this.discoverer.startClassAnnotation(annotationName);
        return new ModAnnotationVisitor(this.discoverer);
    }
    
    public FieldVisitor visitField(final int access, final String name, final String desc, final String signature, final Object value) {
        return new ModFieldVisitor(name, this.discoverer);
    }
    
    public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) {
        if (this.discoverer.isBaseMod(Collections.emptyList()) && name.equals("getPriorities") && desc.equals(Type.getMethodDescriptor(Type.getType((Class)String.class), new Type[0]))) {
            return new ModLoaderPropertiesMethodVisitor(name, this.discoverer);
        }
        return new ModMethodVisitor(name, desc, this.discoverer);
    }
}



================================================
FILE: cpw/mods/fml/common/discovery/asm/ModFieldVisitor.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.discovery.asm;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.FieldVisitor;

public class ModFieldVisitor extends FieldVisitor
{
    private String fieldName;
    private ASMModParser discoverer;
    
    public ModFieldVisitor(final String name, final ASMModParser discoverer) {
        super(262144);
        this.fieldName = name;
        this.discoverer = discoverer;
    }
    
    public AnnotationVisitor visitAnnotation(final String annotationName, final boolean runtimeVisible) {
        this.discoverer.startFieldAnnotation(this.fieldName, annotationName);
        return new ModAnnotationVisitor(this.discoverer);
    }
}



================================================
FILE: cpw/mods/fml/common/discovery/asm/ModLoaderPropertiesMethodVisitor.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.discovery.asm;

import com.google.common.collect.Lists;
import org.objectweb.asm.Label;
import java.util.LinkedList;
import org.objectweb.asm.MethodVisitor;

public class ModLoaderPropertiesMethodVisitor extends MethodVisitor
{
    private ASMModParser discoverer;
    private boolean inCode;
    private LinkedList<Label> labels;
    private String foundProperties;
    private boolean validProperties;
    
    public ModLoaderPropertiesMethodVisitor(final String name, final ASMModParser discoverer) {
        super(262144);
        this.labels = Lists.newLinkedList();
        this.discoverer = discoverer;
    }
    
    public void visitCode() {
        this.labels.clear();
    }
    
    public void visitLdcInsn(final Object cst) {
        if (cst instanceof String && this.labels.size() == 1) {
            this.foundProperties = (String)cst;
        }
    }
    
    public void visitInsn(final int opcode) {
        if (176 == opcode && this.labels.size() == 1 && this.foundProperties != null) {
            this.validProperties = true;
        }
    }
    
    public void visitLabel(final Label label) {
        this.labels.push(label);
    }
    
    public void visitEnd() {
        if (this.validProperties) {
            this.discoverer.setBaseModProperties(this.foundProperties);
        }
    }
}



================================================
FILE: cpw/mods/fml/common/discovery/asm/ModMethodVisitor.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.discovery.asm;

import org.objectweb.asm.AnnotationVisitor;
import org.objectweb.asm.MethodVisitor;

public class ModMethodVisitor extends MethodVisitor
{
    private String methodName;
    private String methodDescriptor;
    private ASMModParser discoverer;
    
    public ModMethodVisitor(final String name, final String desc, final ASMModParser discoverer) {
        super(262144);
        this.methodName = name;
        this.methodDescriptor = desc;
        this.discoverer = discoverer;
    }
    
    public AnnotationVisitor visitAnnotation(final String annotationName, final boolean runtimeVisible) {
        this.discoverer.startMethodAnnotation(this.methodName, this.methodDescriptor, annotationName);
        return new ModAnnotationVisitor(this.discoverer);
    }
}



================================================
FILE: cpw/mods/fml/common/event/FMLConstructionEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.event;

import cpw.mods.fml.common.LoaderState;
import cpw.mods.fml.common.discovery.ASMDataTable;
import cpw.mods.fml.common.ModClassLoader;

public class FMLConstructionEvent extends FMLStateEvent
{
    private ModClassLoader modClassLoader;
    private ASMDataTable asmData;
    
    public FMLConstructionEvent(final Object... eventData) {
        super(new Object[0]);
        this.modClassLoader = (ModClassLoader)eventData[0];
        this.asmData = (ASMDataTable)eventData[1];
    }
    
    public ModClassLoader getModClassLoader() {
        return this.modClassLoader;
    }
    
    @Override
    public LoaderState.ModState getModState() {
        return LoaderState.ModState.CONSTRUCTED;
    }
    
    public ASMDataTable getASMHarvestedData() {
        return this.asmData;
    }
}



================================================
FILE: cpw/mods/fml/common/event/FMLEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.event;

import cpw.mods.fml.common.ModContainer;

public class FMLEvent
{
    public final String getEventType() {
        return this.getClass().getSimpleName();
    }
    
    public void applyModContainer(final ModContainer activeContainer) {
    }
}



================================================
FILE: cpw/mods/fml/common/event/FMLFingerprintViolationEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.event;

import com.google.common.collect.ImmutableSet;
import java.io.File;
import java.util.Set;

public class FMLFingerprintViolationEvent extends FMLEvent
{
    public final boolean isDirectory;
    public final Set<String> fingerprints;
    public final File source;
    public final String expectedFingerprint;
    
    public FMLFingerprintViolationEvent(final boolean isDirectory, final File source, final ImmutableSet<String> fingerprints, final String expectedFingerprint) {
        this.isDirectory = isDirectory;
        this.source = source;
        this.fingerprints = (Set<String>)fingerprints;
        this.expectedFingerprint = expectedFingerprint;
    }
}



================================================
FILE: cpw/mods/fml/common/event/FMLInitializationEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.event;

import cpw.mods.fml.common.LoaderState;

public class FMLInitializationEvent extends FMLStateEvent
{
    public FMLInitializationEvent(final Object... data) {
        super(data);
    }
    
    @Override
    public LoaderState.ModState getModState() {
        return LoaderState.ModState.INITIALIZED;
    }
}



================================================
FILE: cpw/mods/fml/common/event/FMLInterModComms.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.event;

import cpw.mods.fml.common.FMLLog;
import java.util.Collection;
import cpw.mods.fml.common.FMLCommonHandler;
import cpw.mods.fml.common.ModContainer;
import cpw.mods.fml.common.LoaderState;
import cpw.mods.fml.common.Loader;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ImmutableList;

public class FMLInterModComms
{
    private static final ImmutableList<IMCMessage> emptyIMCList;
    private static ArrayListMultimap<String, IMCMessage> modMessages;
    
    public static boolean sendMessage(final String modId, final String key, final by value) {
        return enqueueStartupMessage(modId, new IMCMessage(key, (Object)value));
    }
    
    public static boolean sendMessage(final String modId, final String key, final ye value) {
        return enqueueStartupMessage(modId, new IMCMessage(key, (Object)value));
    }
    
    public static boolean sendMessage(final String modId, final String key, final String value) {
        return enqueueStartupMessage(modId, new IMCMessage(key, (Object)value));
    }
    
    public static void sendRuntimeMessage(final Object sourceMod, final String modId, final String key, final by value) {
        enqueueMessage(sourceMod, modId, new IMCMessage(key, (Object)value));
    }
    
    public static void sendRuntimeMessage(final Object sourceMod, final String modId, final String key, final ye value) {
        enqueueMessage(sourceMod, modId, new IMCMessage(key, (Object)value));
    }
    
    public static void sendRuntimeMessage(final Object sourceMod, final String modId, final String key, final String value) {
        enqueueMessage(sourceMod, modId, new IMCMessage(key, (Object)value));
    }
    
    private static boolean enqueueStartupMessage(final String modTarget, final IMCMessage message) {
        if (Loader.instance().activeModContainer() == null) {
            return false;
        }
        enqueueMessage(Loader.instance().activeModContainer(), modTarget, message);
        return Loader.isModLoaded(modTarget) && !Loader.instance().hasReachedState(LoaderState.POSTINITIALIZATION);
    }
    
    private static void enqueueMessage(final Object sourceMod, final String modTarget, final IMCMessage message) {
        ModContainer mc;
        if (sourceMod instanceof ModContainer) {
            mc = (ModContainer)sourceMod;
        }
        else {
            mc = FMLCommonHandler.instance().findContainerFor(sourceMod);
        }
        if (mc != null && Loader.isModLoaded(modTarget)) {
            message.setSender(mc);
            FMLInterModComms.modMessages.put((Object)modTarget, (Object)message);
        }
    }
    
    public static ImmutableList<IMCMessage> fetchRuntimeMessages(final Object forMod) {
        final ModContainer mc = FMLCommonHandler.instance().findContainerFor(forMod);
        if (mc != null) {
            return (ImmutableList<IMCMessage>)ImmutableList.copyOf((Collection)FMLInterModComms.modMessages.removeAll((Object)mc.getModId()));
        }
        return FMLInterModComms.emptyIMCList;
    }
    
    static {
        emptyIMCList = ImmutableList.of();
        FMLInterModComms.modMessages = (ArrayListMultimap<String, IMCMessage>)ArrayListMultimap.create();
    }
    
    public static class IMCEvent extends FMLEvent
    {
        private ModContainer activeContainer;
        private ImmutableList<IMCMessage> currentList;
        
        @Override
        public void applyModContainer(final ModContainer activeContainer) {
            this.activeContainer = activeContainer;
            this.currentList = null;
            FMLLog.finest("Attempting to deliver %d IMC messages to mod %s", FMLInterModComms.modMessages.get((Object)activeContainer.getModId()).size(), activeContainer.getModId());
        }
        
        public ImmutableList<IMCMessage> getMessages() {
            if (this.currentList == null) {
                this.currentList = (ImmutableList<IMCMessage>)ImmutableList.copyOf((Collection)FMLInterModComms.modMessages.removeAll((Object)this.activeContainer.getModId()));
            }
            return this.currentList;
        }
    }
    
    public static final class IMCMessage
    {
        private String sender;
        public final String key;
        private Object value;
        
        private IMCMessage(final String key, final Object value) {
            this.key = key;
            this.value = value;
        }
        
        @Override
        public String toString() {
            return this.sender;
        }
        
        public String getSender() {
            return this.sender;
        }
        
        void setSender(final ModContainer activeModContainer) {
            this.sender = activeModContainer.getModId();
        }
        
        public String getStringValue() {
            return (String)this.value;
        }
        
        public by getNBTValue() {
            return (by)this.value;
        }
        
        public ye getItemStackValue() {
            return (ye)this.value;
        }
        
        public Class<?> getMessageType() {
            return this.value.getClass();
        }
        
        public boolean isStringMessage() {
            return String.class.isAssignableFrom(this.getMessageType());
        }
        
        public boolean isItemStackMessage() {
            return ye.class.isAssignableFrom(this.getMessageType());
        }
        
        public boolean isNBTMessage() {
            return by.class.isAssignableFrom(this.getMessageType());
        }
    }
}



================================================
FILE: cpw/mods/fml/common/event/FMLLoadCompleteEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.event;

import cpw.mods.fml.common.LoaderState;

public class FMLLoadCompleteEvent extends FMLStateEvent
{
    public FMLLoadCompleteEvent(final Object... data) {
        super(data);
    }
    
    @Override
    public LoaderState.ModState getModState() {
        return LoaderState.ModState.AVAILABLE;
    }
}



================================================
FILE: cpw/mods/fml/common/event/FMLLoadEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.event;

public class FMLLoadEvent
{
}



================================================
FILE: cpw/mods/fml/common/event/FMLPostInitializationEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.event;

import com.google.common.base.Throwables;
import cpw.mods.fml.common.Loader;
import cpw.mods.fml.common.LoaderState;

public class FMLPostInitializationEvent extends FMLStateEvent
{
    public FMLPostInitializationEvent(final Object... data) {
        super(data);
    }
    
    @Override
    public LoaderState.ModState getModState() {
        return LoaderState.ModState.POSTINITIALIZED;
    }
    
    public Object buildSoftDependProxy(final String modId, final String className) {
        if (Loader.isModLoaded(modId)) {
            try {
                final Class<?> clz = Class.forName(className, true, Loader.instance().getModClassLoader());
                return clz.newInstance();
            }
            catch (final Exception e) {
                Throwables.propagateIfPossible((Throwable)e);
                return null;
            }
        }
        return null;
    }
}



================================================
FILE: cpw/mods/fml/common/event/FMLPreInitializationEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.event;

import java.security.CodeSource;
import java.security.cert.Certificate;
import cpw.mods.fml.common.FMLLog;
import java.util.logging.Logger;
import cpw.mods.fml.common.FMLModContainer;
import java.util.Properties;
import cpw.mods.fml.common.LoaderState;
import cpw.mods.fml.common.ModContainer;
import cpw.mods.fml.common.discovery.ASMDataTable;
import java.io.File;
import cpw.mods.fml.common.ModMetadata;

public class FMLPreInitializationEvent extends FMLStateEvent
{
    private ModMetadata modMetadata;
    private File sourceFile;
    private File configurationDir;
    private File suggestedConfigFile;
    private ASMDataTable asmData;
    private ModContainer modContainer;
    
    public FMLPreInitializationEvent(final Object... data) {
        super(data);
        this.asmData = (ASMDataTable)data[0];
        this.configurationDir = (File)data[1];
    }
    
    @Override
    public LoaderState.ModState getModState() {
        return LoaderState.ModState.PREINITIALIZED;
    }
    
    @Override
    public void applyModContainer(final ModContainer activeContainer) {
        this.modContainer = activeContainer;
        this.modMetadata = activeContainer.getMetadata();
        this.sourceFile = activeContainer.getSource();
        this.suggestedConfigFile = new File(this.configurationDir, activeContainer.getModId() + ".cfg");
    }
    
    public File getSourceFile() {
        return this.sourceFile;
    }
    
    public ModMetadata getModMetadata() {
        return this.modMetadata;
    }
    
    public File getModConfigurationDirectory() {
        return this.configurationDir;
    }
    
    public File getSuggestedConfigurationFile() {
        return this.suggestedConfigFile;
    }
    
    public ASMDataTable getAsmData() {
        return this.asmData;
    }
    
    public Properties getVersionProperties() {
        if (this.modContainer instanceof FMLModContainer) {
            return ((FMLModContainer)this.modContainer).searchForVersionProperties();
        }
        return null;
    }
    
    public Logger getModLog() {
        final Logger log = Logger.getLogger(this.modContainer.getModId());
        log.setParent(FMLLog.getLogger());
        return log;
    }
    
    @Deprecated
    public Certificate[] getFMLSigningCertificates() {
        final CodeSource codeSource = this.getClass().getClassLoader().getParent().getClass().getProtectionDomain().getCodeSource();
        final Certificate[] certs = codeSource.getCertificates();
        if (certs == null) {
            return new Certificate[0];
        }
        return certs;
    }
}



================================================
FILE: cpw/mods/fml/common/event/FMLServerAboutToStartEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.event;

import cpw.mods.fml.common.LoaderState;
import net.minecraft.server.MinecraftServer;

public class FMLServerAboutToStartEvent extends FMLStateEvent
{
    private MinecraftServer server;
    
    public FMLServerAboutToStartEvent(final Object... data) {
        super(data);
        this.server = (MinecraftServer)data[0];
    }
    
    @Override
    public LoaderState.ModState getModState() {
        return LoaderState.ModState.AVAILABLE;
    }
    
    public MinecraftServer getServer() {
        return this.server;
    }
}



================================================
FILE: cpw/mods/fml/common/event/FMLServerStartedEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.event;

import cpw.mods.fml.common.LoaderState;

public class FMLServerStartedEvent extends FMLStateEvent
{
    public FMLServerStartedEvent(final Object... data) {
        super(data);
    }
    
    @Override
    public LoaderState.ModState getModState() {
        return LoaderState.ModState.AVAILABLE;
    }
}



================================================
FILE: cpw/mods/fml/common/event/FMLServerStartingEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.event;

import cpw.mods.fml.common.LoaderState;
import net.minecraft.server.MinecraftServer;

public class FMLServerStartingEvent extends FMLStateEvent
{
    private MinecraftServer server;
    
    public FMLServerStartingEvent(final Object... data) {
        super(data);
        this.server = (MinecraftServer)data[0];
    }
    
    @Override
    public LoaderState.ModState getModState() {
        return LoaderState.ModState.AVAILABLE;
    }
    
    public MinecraftServer getServer() {
        return this.server;
    }
    
    public void registerServerCommand(final ab command) {
        final aa ch = (aa)this.getServer().G();
        ch.a(command);
    }
}



================================================
FILE: cpw/mods/fml/common/event/FMLServerStoppedEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.event;

import cpw.mods.fml.common.LoaderState;

public class FMLServerStoppedEvent extends FMLStateEvent
{
    public FMLServerStoppedEvent(final Object... data) {
        super(data);
    }
    
    @Override
    public LoaderState.ModState getModState() {
        return LoaderState.ModState.AVAILABLE;
    }
}



================================================
FILE: cpw/mods/fml/common/event/FMLServerStoppingEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.event;

import cpw.mods.fml.common.LoaderState;

public class FMLServerStoppingEvent extends FMLStateEvent
{
    public FMLServerStoppingEvent(final Object... data) {
        super(data);
    }
    
    @Override
    public LoaderState.ModState getModState() {
        return LoaderState.ModState.AVAILABLE;
    }
}



================================================
FILE: cpw/mods/fml/common/event/FMLStateEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.event;

import cpw.mods.fml.common.FMLCommonHandler;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.common.LoaderState;

public abstract class FMLStateEvent extends FMLEvent
{
    public FMLStateEvent(final Object... data) {
    }
    
    public abstract LoaderState.ModState getModState();
    
    public Side getSide() {
        return FMLCommonHandler.instance().getSide();
    }
}



================================================
FILE: cpw/mods/fml/common/functions/ArtifactVersionNameFunction.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.functions;

import cpw.mods.fml.common.versioning.ArtifactVersion;
import com.google.common.base.Function;

public class ArtifactVersionNameFunction implements Function<ArtifactVersion, String>
{
    public String apply(final ArtifactVersion v) {
        return v.getLabel();
    }
}



================================================
FILE: cpw/mods/fml/common/functions/ModIdFunction.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.functions;

import cpw.mods.fml.common.ModContainer;
import com.google.common.base.Function;

public final class ModIdFunction implements Function<ModContainer, String>
{
    public String apply(final ModContainer container) {
        return container.getModId();
    }
}



================================================
FILE: cpw/mods/fml/common/functions/ModNameFunction.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.functions;

import cpw.mods.fml.common.ModContainer;
import com.google.common.base.Function;

public class ModNameFunction implements Function<ModContainer, String>
{
    public String apply(final ModContainer input) {
        return input.getName();
    }
}



================================================
FILE: cpw/mods/fml/common/launcher/FMLDeobfTweaker.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.launcher;

import java.lang.reflect.Method;
import cpw.mods.fml.relauncher.FMLInjectionData;
import cpw.mods.fml.relauncher.FMLRelaunchLog;
import net.minecraft.launchwrapper.Launch;
import net.minecraft.launchwrapper.LaunchClassLoader;
import java.io.File;
import java.util.List;
import net.minecraft.launchwrapper.ITweaker;

public class FMLDeobfTweaker implements ITweaker
{
    public void acceptOptions(final List<String> args, final File gameDir, final File assetsDir, final String profile) {
    }
    
    public void injectIntoClassLoader(final LaunchClassLoader classLoader) {
        if (!Launch.blackboard.get("fml.deobfuscatedEnvironment")) {
            classLoader.registerTransformer("cpw.mods.fml.common.asm.transformers.DeobfuscationTransformer");
        }
        try {
            FMLRelaunchLog.fine("Validating minecraft", new Object[0]);
            final Class<?> loaderClazz = Class.forName("cpw.mods.fml.common.Loader", true, (ClassLoader)classLoader);
            Method m = loaderClazz.getMethod("injectData", Object[].class);
            m.invoke(null, FMLInjectionData.data());
            m = loaderClazz.getMethod("instance", (Class<?>[])new Class[0]);
            m.invoke(null, new Object[0]);
            FMLRelaunchLog.fine("Minecraft validated, launching...", new Object[0]);
        }
        catch (final Exception e) {
            System.out.println("A CRITICAL PROBLEM OCCURED INITIALIZING MINECRAFT - LIKELY YOU HAVE AN INCORRECT VERSION FOR THIS FML");
            throw new RuntimeException(e);
        }
    }
    
    public String getLaunchTarget() {
        throw new RuntimeException("Invalid for use as a primary tweaker");
    }
    
    public String[] getLaunchArguments() {
        return new String[0];
    }
}



================================================
FILE: cpw/mods/fml/common/launcher/FMLInjectionAndSortingTweaker.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.launcher;

import net.minecraft.launchwrapper.LaunchClassLoader;
import java.io.File;
import java.util.List;
import cpw.mods.fml.relauncher.CoreModManager;
import net.minecraft.launchwrapper.ITweaker;

public class FMLInjectionAndSortingTweaker implements ITweaker
{
    private boolean run;
    
    public FMLInjectionAndSortingTweaker() {
        CoreModManager.injectCoreModTweaks(this);
        this.run = false;
    }
    
    public void acceptOptions(final List<String> args, final File gameDir, final File assetsDir, final String profile) {
        if (!this.run) {
            CoreModManager.sortTweakList();
        }
        this.run = true;
    }
    
    public void injectIntoClassLoader(final LaunchClassLoader classLoader) {
    }
    
    public String getLaunchTarget() {
        return "";
    }
    
    public String[] getLaunchArguments() {
        return new String[0];
    }
}



================================================
FILE: cpw/mods/fml/common/launcher/FMLServerTweaker.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.launcher;

import cpw.mods.fml.relauncher.FMLLaunchHandler;
import net.minecraft.launchwrapper.LaunchClassLoader;

public class FMLServerTweaker extends FMLTweaker
{
    @Override
    public String getLaunchTarget() {
        return "net.minecraft.server.MinecraftServer";
    }
    
    @Override
    public void injectIntoClassLoader(final LaunchClassLoader classLoader) {
        classLoader.addTransformerExclusion("cpw.mods.fml.repackage.");
        classLoader.addTransformerExclusion("cpw.mods.fml.relauncher.");
        classLoader.addTransformerExclusion("cpw.mods.fml.common.asm.transformers.");
        classLoader.addClassLoaderExclusion("LZMA.");
        FMLLaunchHandler.configureForServerLaunch(classLoader, this);
        FMLLaunchHandler.appendCoreMods();
    }
}



================================================
FILE: cpw/mods/fml/common/launcher/FMLTweaker.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.launcher;

import java.util.Collection;
import cpw.mods.fml.relauncher.FMLLaunchHandler;
import net.minecraft.launchwrapper.LaunchClassLoader;
import java.util.Iterator;
import java.net.URISyntaxException;
import com.google.common.base.Throwables;
import java.util.logging.Level;
import java.util.logging.Logger;
import com.google.common.collect.Maps;
import com.google.common.collect.Lists;
import net.minecraft.launchwrapper.Launch;
import java.net.URI;
import java.util.Map;
import java.io.File;
import java.util.List;
import net.minecraft.launchwrapper.ITweaker;

public class FMLTweaker implements ITweaker
{
    private List<String> args;
    private File gameDir;
    private File assetsDir;
    private String profile;
    private Map<String, String> launchArgs;
    private List<String> standaloneArgs;
    private static URI jarLocation;
    
    public void acceptOptions(final List<String> args, final File gameDir, final File assetsDir, final String profile) {
        this.gameDir = ((gameDir == null) ? new File(".") : gameDir);
        this.assetsDir = assetsDir;
        this.profile = profile;
        this.args = args;
        this.launchArgs = Launch.blackboard.get("launchArgs");
        this.standaloneArgs = Lists.newArrayList();
        if (this.launchArgs == null) {
            this.launchArgs = Maps.newHashMap();
            Launch.blackboard.put("launchArgs", this.launchArgs);
        }
        String classifier = null;
        for (final String arg : args) {
            if (arg.startsWith("-")) {
                if (classifier != null) {
                    classifier = this.launchArgs.put(classifier, "");
                }
                else if (arg.contains("=")) {
                    classifier = this.launchArgs.put(arg.substring(0, arg.indexOf(61)), arg.substring(arg.indexOf(61) + 1));
                }
                else {
                    classifier = arg;
                }
            }
            else if (classifier != null) {
                classifier = this.launchArgs.put(classifier, arg);
            }
            else {
                this.standaloneArgs.add(arg);
            }
        }
        if (!this.launchArgs.containsKey("--version")) {
            this.launchArgs.put("--version", (profile != null) ? profile : "UnknownFMLProfile");
        }
        if (!this.launchArgs.containsKey("--gameDir") && gameDir != null) {
            this.launchArgs.put("--gameDir", gameDir.getAbsolutePath());
        }
        if (!this.launchArgs.containsKey("--assetsDir") && assetsDir != null) {
            this.launchArgs.put("--assetsDir", assetsDir.getAbsolutePath());
        }
        try {
            FMLTweaker.jarLocation = this.getClass().getProtectionDomain().getCodeSource().getLocation().toURI();
        }
        catch (final URISyntaxException e) {
            Logger.getLogger("FMLTWEAK").log(Level.SEVERE, "Missing URI information for FML tweak");
            throw Throwables.propagate((Throwable)e);
        }
    }
    
    public void injectIntoClassLoader(final LaunchClassLoader classLoader) {
        classLoader.addTransformerExclusion("cpw.mods.fml.repackage.");
        classLoader.addTransformerExclusion("cpw.mods.fml.relauncher.");
        classLoader.addTransformerExclusion("cpw.mods.fml.common.asm.transformers.");
        classLoader.addClassLoaderExclusion("LZMA.");
        FMLLaunchHandler.configureForClientLaunch(classLoader, this);
        FMLLaunchHandler.appendCoreMods();
    }
    
    public String getLaunchTarget() {
        return "net.minecraft.client.main.Main";
    }
    
    public String[] getLaunchArguments() {
        final List<String> args = Lists.newArrayList();
        args.addAll(this.standaloneArgs);
        for (final Map.Entry<String, String> arg : this.launchArgs.entrySet()) {
            args.add(arg.getKey());
            args.add(arg.getValue());
        }
        this.launchArgs.clear();
        return args.toArray(new String[args.size()]);
    }
    
    public File getGameDir() {
        return this.gameDir;
    }
    
    public static URI getJarLocation() {
        return FMLTweaker.jarLocation;
    }
    
    public void injectCascadingTweak(final String tweakClassName) {
        final List<String> tweakClasses = Launch.blackboard.get("TweakClasses");
        tweakClasses.add(tweakClassName);
    }
}



================================================
FILE: cpw/mods/fml/common/modloader/BaseModProxy.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.modloader;

import java.util.Random;
import cpw.mods.fml.common.TickType;

public interface BaseModProxy
{
    void modsLoaded();
    
    void load();
    
    String getName();
    
    String getPriorities();
    
    String getVersion();
    
    boolean doTickInGUI(final TickType p0, final boolean p1, final Object... p2);
    
    boolean doTickInGame(final TickType p0, final boolean p1, final Object... p2);
    
    void generateSurface(final abw p0, final Random p1, final int p2, final int p3);
    
    void generateNether(final abw p0, final Random p1, final int p2, final int p3);
    
    int addFuel(final int p0, final int p1);
    
    void takenFromCrafting(final uf p0, final ye p1, final mo p2);
    
    void takenFromFurnace(final uf p0, final ye p1);
    
    void onClientLogout(final cm p0);
    
    void onClientLogin(final uf p0);
    
    void serverDisconnect();
    
    void serverConnect(final ez p0);
    
    void receiveCustomPacket(final ea p0);
    
    void clientChat(final String p0);
    
    void onItemPickup(final uf p0, final ye p1);
    
    void serverCustomPayload(final ka p0, final ea p1);
    
    void serverChat(final ka p0, final String p1);
}



================================================
FILE: cpw/mods/fml/common/modloader/BaseModTicker.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.modloader;

import java.util.Iterator;
import java.util.Collection;
import cpw.mods.fml.common.FMLCommonHandler;
import cpw.mods.fml.common.TickType;
import java.util.EnumSet;
import cpw.mods.fml.common.ITickHandler;

public class BaseModTicker implements ITickHandler
{
    private BaseModProxy mod;
    private EnumSet<TickType> ticks;
    private boolean clockTickTrigger;
    private boolean sendGuiTicks;
    
    BaseModTicker(final BaseModProxy mod, final boolean guiTicker) {
        this.mod = mod;
        this.ticks = EnumSet.of(TickType.WORLDLOAD);
        this.sendGuiTicks = guiTicker;
    }
    
    BaseModTicker(final EnumSet<TickType> ticks, final boolean guiTicker) {
        this.ticks = ticks;
        this.sendGuiTicks = guiTicker;
    }
    
    @Override
    public void tickStart(final EnumSet<TickType> types, final Object... tickData) {
        this.tickBaseMod(types, false, tickData);
    }
    
    @Override
    public void tickEnd(final EnumSet<TickType> types, final Object... tickData) {
        this.tickBaseMod(types, true, tickData);
    }
    
    private void tickBaseMod(final EnumSet<TickType> types, final boolean end, final Object... tickData) {
        if (FMLCommonHandler.instance().getSide().isClient() && (this.ticks.contains(TickType.CLIENT) || this.ticks.contains(TickType.WORLDLOAD))) {
            final EnumSet cTypes = EnumSet.copyOf(types);
            if ((end && types.contains(TickType.CLIENT)) || types.contains(TickType.WORLDLOAD)) {
                this.clockTickTrigger = true;
                cTypes.remove(TickType.CLIENT);
                cTypes.remove(TickType.WORLDLOAD);
            }
            if (end && this.clockTickTrigger && types.contains(TickType.RENDER)) {
                this.clockTickTrigger = false;
                cTypes.remove(TickType.RENDER);
                cTypes.add(TickType.CLIENT);
            }
            this.sendTick(cTypes, end, tickData);
        }
        else {
            this.sendTick(types, end, tickData);
        }
    }
    
    private void sendTick(final EnumSet<TickType> types, final boolean end, final Object... tickData) {
        for (final TickType type : types) {
            if (!this.ticks.contains(type)) {
                continue;
            }
            boolean keepTicking = true;
            if (this.sendGuiTicks) {
                keepTicking = this.mod.doTickInGUI(type, end, tickData);
            }
            else {
                keepTicking = this.mod.doTickInGame(type, end, tickData);
            }
            if (keepTicking) {
                continue;
            }
            this.ticks.remove(type);
            this.ticks.removeAll(type.partnerTicks());
        }
    }
    
    @Override
    public EnumSet<TickType> ticks() {
        return this.clockTickTrigger ? EnumSet.of(TickType.RENDER) : this.ticks;
    }
    
    @Override
    public String getLabel() {
        return this.mod.getClass().getSimpleName();
    }
    
    public void setMod(final BaseModProxy mod) {
        this.mod = mod;
    }
}



================================================
FILE: cpw/mods/fml/common/modloader/IModLoaderSidedHelper.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.modloader;

import cpw.mods.fml.common.registry.EntityRegistry;
import cpw.mods.fml.common.network.EntitySpawnPacket;

public interface IModLoaderSidedHelper
{
    void finishModLoading(final ModLoaderModContainer p0);
    
    Object getClientGui(final BaseModProxy p0, final uf p1, final int p2, final int p3, final int p4, final int p5);
    
    nn spawnEntity(final BaseModProxy p0, final EntitySpawnPacket p1, final EntityRegistry.EntityRegistration p2);
    
    void sendClientPacket(final BaseModProxy p0, final ea p1);
    
    void clientConnectionOpened(final ez p0, final cm p1, final BaseModProxy p2);
    
    boolean clientConnectionClosed(final cm p0, final BaseModProxy p1);
}



================================================
FILE: cpw/mods/fml/common/modloader/ModLoaderChatListener.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.modloader;

import cpw.mods.fml.common.network.IChatListener;

public class ModLoaderChatListener implements IChatListener
{
    private BaseModProxy mod;
    
    public ModLoaderChatListener(final BaseModProxy mod) {
        this.mod = mod;
    }
    
    @Override
    public dm serverChat(final ez handler, final dm message) {
        this.mod.serverChat((ka)handler, message.a);
        return message;
    }
    
    @Override
    public dm clientChat(final ez handler, final dm message) {
        this.mod.clientChat(message.a);
        return message;
    }
}



================================================
FILE: cpw/mods/fml/common/modloader/ModLoaderConnectionHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.modloader;

import net.minecraft.server.MinecraftServer;
import cpw.mods.fml.common.network.Player;
import cpw.mods.fml.common.network.IConnectionHandler;

public class ModLoaderConnectionHandler implements IConnectionHandler
{
    private BaseModProxy mod;
    
    public ModLoaderConnectionHandler(final BaseModProxy mod) {
        this.mod = mod;
    }
    
    @Override
    public void playerLoggedIn(final Player player, final ez netHandler, final cm manager) {
        this.mod.onClientLogin((uf)player);
    }
    
    @Override
    public String connectionReceived(final jy netHandler, final cm manager) {
        return null;
    }
    
    @Override
    public void connectionOpened(final ez netClientHandler, final String server, final int port, final cm manager) {
        ModLoaderHelper.sidedHelper.clientConnectionOpened(netClientHandler, manager, this.mod);
    }
    
    @Override
    public void connectionClosed(final cm manager) {
        if (ModLoaderHelper.sidedHelper == null || !ModLoaderHelper.sidedHelper.clientConnectionClosed(manager, this.mod)) {
            this.mod.serverDisconnect();
            this.mod.onClientLogout(manager);
        }
    }
    
    @Override
    public void clientLoggedIn(final ez nh, final cm manager, final ep login) {
        this.mod.serverConnect(nh);
    }
    
    @Override
    public void connectionOpened(final ez netClientHandler, final MinecraftServer server, final cm manager) {
        ModLoaderHelper.sidedHelper.clientConnectionOpened(netClientHandler, manager, this.mod);
    }
}



================================================
FILE: cpw/mods/fml/common/modloader/ModLoaderCraftingHelper.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.modloader;

import cpw.mods.fml.common.ICraftingHandler;

public class ModLoaderCraftingHelper implements ICraftingHandler
{
    private BaseModProxy mod;
    
    public ModLoaderCraftingHelper(final BaseModProxy mod) {
        this.mod = mod;
    }
    
    @Override
    public void onCrafting(final uf player, final ye item, final mo craftMatrix) {
        this.mod.takenFromCrafting(player, item, craftMatrix);
    }
    
    @Override
    public void onSmelting(final uf player, final ye item) {
        this.mod.takenFromFurnace(player, item);
    }
}



================================================
FILE: cpw/mods/fml/common/modloader/ModLoaderEntitySpawnCallback.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.modloader;

import cpw.mods.fml.common.registry.EntityRegistry;
import cpw.mods.fml.common.network.EntitySpawnPacket;
import com.google.common.base.Function;

public class ModLoaderEntitySpawnCallback implements Function<EntitySpawnPacket, nn>
{
    private BaseModProxy mod;
    private EntityRegistry.EntityRegistration registration;
    private boolean isAnimal;
    
    public ModLoaderEntitySpawnCallback(final BaseModProxy mod, final EntityRegistry.EntityRegistration er) {
        this.mod = mod;
        this.registration = er;
    }
    
    public nn apply(final EntitySpawnPacket input) {
        return ModLoaderHelper.sidedHelper.spawnEntity(this.mod, input, this.registration);
    }
}



================================================
FILE: cpw/mods/fml/common/modloader/ModLoaderFuelHelper.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.modloader;

import cpw.mods.fml.common.IFuelHandler;

public class ModLoaderFuelHelper implements IFuelHandler
{
    private BaseModProxy mod;
    
    public ModLoaderFuelHelper(final BaseModProxy mod) {
        this.mod = mod;
    }
    
    @Override
    public int getBurnTime(final ye fuel) {
        return this.mod.addFuel(fuel.d, fuel.k());
    }
}



================================================
FILE: cpw/mods/fml/common/modloader/ModLoaderGuiHelper.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.modloader;

import com.google.common.collect.Sets;
import java.util.Set;
import cpw.mods.fml.common.network.IGuiHandler;

public class ModLoaderGuiHelper implements IGuiHandler
{
    private BaseModProxy mod;
    private Set<Integer> ids;
    private uy container;
    private int currentID;
    
    ModLoaderGuiHelper(final BaseModProxy mod) {
        this.mod = mod;
        this.ids = Sets.newHashSet();
    }
    
    @Override
    public Object getServerGuiElement(final int ID, final uf player, final abw world, final int x, final int y, final int z) {
        return this.container;
    }
    
    @Override
    public Object getClientGuiElement(final int ID, final uf player, final abw world, final int x, final int y, final int z) {
        return ModLoaderHelper.getClientSideGui(this.mod, player, ID, x, y, z);
    }
    
    public void injectContainerAndID(final uy container, final int ID) {
        this.container = container;
        this.currentID = ID;
    }
    
    public Object getMod() {
        return this.mod;
    }
    
    public void associateId(final int additionalID) {
        this.ids.add(additionalID);
    }
}



================================================
FILE: cpw/mods/fml/common/modloader/ModLoaderHelper.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.modloader;

import com.google.common.collect.Maps;
import cpw.mods.fml.common.network.IChatListener;
import cpw.mods.fml.common.registry.VillagerRegistry;
import cpw.mods.fml.common.network.EntitySpawnPacket;
import com.google.common.base.Function;
import cpw.mods.fml.common.registry.EntityRegistry;
import cpw.mods.fml.common.network.IGuiHandler;
import cpw.mods.fml.common.network.NetworkRegistry;
import cpw.mods.fml.common.IPickupNotifier;
import cpw.mods.fml.common.network.IConnectionHandler;
import cpw.mods.fml.common.ICraftingHandler;
import cpw.mods.fml.common.IFuelHandler;
import cpw.mods.fml.common.IWorldGenerator;
import cpw.mods.fml.common.network.IPacketHandler;
import java.util.EnumSet;
import cpw.mods.fml.common.FMLCommonHandler;
import cpw.mods.fml.common.TickType;
import cpw.mods.fml.common.FMLLog;
import cpw.mods.fml.common.Loader;
import java.util.Map;

public class ModLoaderHelper
{
    public static IModLoaderSidedHelper sidedHelper;
    private static Map<BaseModProxy, ModLoaderGuiHelper> guiHelpers;
    private static Map<Integer, ModLoaderGuiHelper> guiIDs;
    private static ModLoaderVillageTradeHandler[] tradeHelpers;
    
    public static void updateStandardTicks(final BaseModProxy mod, final boolean enable, final boolean useClock) {
        ModLoaderModContainer mlmc = (ModLoaderModContainer)Loader.instance().getReversedModObjectList().get((Object)mod);
        if (mlmc == null) {
            mlmc = (ModLoaderModContainer)Loader.instance().activeModContainer();
        }
        if (mlmc == null) {
            FMLLog.severe("Attempted to register ModLoader ticking for invalid BaseMod %s", mod);
            return;
        }
        final BaseModTicker ticker = mlmc.getGameTickHandler();
        final EnumSet<TickType> ticks = ticker.ticks();
        if (enable && !useClock) {
            ticks.add(TickType.RENDER);
        }
        else {
            ticks.remove(TickType.RENDER);
        }
        if (enable && (useClock || FMLCommonHandler.instance().getSide().isServer())) {
            ticks.add(TickType.CLIENT);
            ticks.add(TickType.WORLDLOAD);
        }
        else {
            ticks.remove(TickType.CLIENT);
            ticks.remove(TickType.WORLDLOAD);
        }
    }
    
    public static void updateGUITicks(final BaseModProxy mod, final boolean enable, final boolean useClock) {
        ModLoaderModContainer mlmc = (ModLoaderModContainer)Loader.instance().getReversedModObjectList().get((Object)mod);
        if (mlmc == null) {
            mlmc = (ModLoaderModContainer)Loader.instance().activeModContainer();
        }
        if (mlmc == null) {
            FMLLog.severe("Attempted to register ModLoader ticking for invalid BaseMod %s", mod);
            return;
        }
        final EnumSet<TickType> ticks = mlmc.getGUITickHandler().ticks();
        if (enable && !useClock) {
            ticks.add(TickType.RENDER);
        }
        else {
            ticks.remove(TickType.RENDER);
        }
        if (enable && useClock) {
            ticks.add(TickType.CLIENT);
            ticks.add(TickType.WORLDLOAD);
        }
        else {
            ticks.remove(TickType.CLIENT);
            ticks.remove(TickType.WORLDLOAD);
        }
    }
    
    public static IPacketHandler buildPacketHandlerFor(final BaseModProxy mod) {
        return new ModLoaderPacketHandler(mod);
    }
    
    public static IWorldGenerator buildWorldGenHelper(final BaseModProxy mod) {
        return new ModLoaderWorldGenerator(mod);
    }
    
    public static IFuelHandler buildFuelHelper(final BaseModProxy mod) {
        return new ModLoaderFuelHelper(mod);
    }
    
    public static ICraftingHandler buildCraftingHelper(final BaseModProxy mod) {
        return new ModLoaderCraftingHelper(mod);
    }
    
    public static void finishModLoading(final ModLoaderModContainer mc) {
        if (ModLoaderHelper.sidedHelper != null) {
            ModLoaderHelper.sidedHelper.finishModLoading(mc);
        }
    }
    
    public static IConnectionHandler buildConnectionHelper(final BaseModProxy mod) {
        return new ModLoaderConnectionHandler(mod);
    }
    
    public static IPickupNotifier buildPickupHelper(final BaseModProxy mod) {
        return new ModLoaderPickupNotifier(mod);
    }
    
    public static void buildGuiHelper(final BaseModProxy mod, final int id) {
        ModLoaderGuiHelper handler = ModLoaderHelper.guiHelpers.get(mod);
        if (handler == null) {
            handler = new ModLoaderGuiHelper(mod);
            ModLoaderHelper.guiHelpers.put(mod, handler);
            NetworkRegistry.instance().registerGuiHandler(mod, handler);
        }
        handler.associateId(id);
        ModLoaderHelper.guiIDs.put(id, handler);
    }
    
    public static void openGui(final int id, final uf player, final uy container, final int x, final int y, final int z) {
        final ModLoaderGuiHelper helper = ModLoaderHelper.guiIDs.get(id);
        helper.injectContainerAndID(container, id);
        player.openGui(helper.getMod(), id, player.q, x, y, z);
    }
    
    public static Object getClientSideGui(final BaseModProxy mod, final uf player, final int ID, final int x, final int y, final int z) {
        if (ModLoaderHelper.sidedHelper != null) {
            return ModLoaderHelper.sidedHelper.getClientGui(mod, player, ID, x, y, z);
        }
        return null;
    }
    
    public static void buildEntityTracker(final BaseModProxy mod, final Class<? extends nn> entityClass, final int entityTypeId, final int updateRange, final int updateInterval, final boolean sendVelocityInfo) {
        final EntityRegistry.EntityRegistration er = EntityRegistry.registerModLoaderEntity(mod, entityClass, entityTypeId, updateRange, updateInterval, sendVelocityInfo);
        er.setCustomSpawning((Function<EntitySpawnPacket, nn>)new ModLoaderEntitySpawnCallback(mod, er), sk.class.isAssignableFrom(entityClass) || nl.class.isAssignableFrom(entityClass));
    }
    
    public static void registerTrade(final int profession, final TradeEntry entry) {
        assert profession < ModLoaderHelper.tradeHelpers.length : "The profession is out of bounds";
        if (ModLoaderHelper.tradeHelpers[profession] == null) {
            ModLoaderHelper.tradeHelpers[profession] = new ModLoaderVillageTradeHandler();
            VillagerRegistry.instance().registerVillageTradeHandler(profession, ModLoaderHelper.tradeHelpers[profession]);
        }
        ModLoaderHelper.tradeHelpers[profession].addTrade(entry);
    }
    
    public static void addCommand(final ab command) {
        final ModLoaderModContainer mlmc = (ModLoaderModContainer)Loader.instance().activeModContainer();
        if (mlmc != null) {
            mlmc.addServerCommand(command);
        }
    }
    
    public static IChatListener buildChatListener(final BaseModProxy mod) {
        return new ModLoaderChatListener(mod);
    }
    
    static {
        ModLoaderHelper.guiHelpers = Maps.newHashMap();
        ModLoaderHelper.guiIDs = Maps.newHashMap();
        ModLoaderHelper.tradeHelpers = new ModLoaderVillageTradeHandler[6];
    }
}



================================================
FILE: cpw/mods/fml/common/modloader/ModLoaderModContainer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.modloader;

import com.google.common.collect.Maps;
import java.security.cert.Certificate;
import cpw.mods.fml.common.versioning.VersionRange;
import cpw.mods.fml.common.versioning.DefaultArtifactVersion;
import cpw.mods.fml.common.event.FMLServerStartingEvent;
import cpw.mods.fml.common.event.FMLLoadCompleteEvent;
import cpw.mods.fml.common.event.FMLPostInitializationEvent;
import cpw.mods.fml.common.event.FMLInitializationEvent;
import cpw.mods.fml.common.network.NetworkRegistry;
import cpw.mods.fml.common.registry.GameRegistry;
import cpw.mods.fml.common.ITickHandler;
import cpw.mods.fml.common.registry.TickRegistry;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.common.event.FMLPreInitializationEvent;
import com.google.common.eventbus.Subscribe;
import java.lang.reflect.Constructor;
import cpw.mods.fml.common.ModClassLoader;
import com.google.common.base.Throwables;
import cpw.mods.fml.common.ILanguageAdapter;
import cpw.mods.fml.common.FMLCommonHandler;
import cpw.mods.fml.common.network.NetworkModHandler;
import cpw.mods.fml.common.network.FMLNetworkHandler;
import java.util.EnumSet;
import cpw.mods.fml.common.TickType;
import cpw.mods.fml.common.event.FMLConstructionEvent;
import java.util.Map;
import com.google.common.collect.ImmutableMap;
import cpw.mods.fml.common.MetadataCollection;
import java.lang.reflect.Field;
import java.util.Iterator;
import java.io.IOException;
import java.io.Writer;
import java.io.FileWriter;
import java.lang.reflect.Modifier;
import cpw.mods.fml.common.LoaderException;
import java.util.logging.Level;
import java.io.Reader;
import java.io.FileReader;
import cpw.mods.fml.common.FMLLog;
import java.util.Properties;
import cpw.mods.fml.common.Loader;
import cpw.mods.fml.common.discovery.ASMDataTable;
import com.google.common.base.Strings;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import java.util.List;
import cpw.mods.fml.common.LoadController;
import com.google.common.eventbus.EventBus;
import cpw.mods.fml.common.ProxyInjector;
import cpw.mods.fml.common.ModMetadata;
import cpw.mods.fml.common.discovery.ContainerType;
import java.util.ArrayList;
import cpw.mods.fml.common.versioning.ArtifactVersion;
import java.util.Set;
import java.io.File;
import cpw.mods.fml.common.ModContainer;

public class ModLoaderModContainer implements ModContainer
{
    public BaseModProxy mod;
    private File modSource;
    public Set<ArtifactVersion> requirements;
    public ArrayList<ArtifactVersion> dependencies;
    public ArrayList<ArtifactVersion> dependants;
    private ContainerType sourceType;
    private ModMetadata metadata;
    private ProxyInjector sidedProxy;
    private BaseModTicker gameTickHandler;
    private BaseModTicker guiTickHandler;
    private String modClazzName;
    private String modId;
    private EventBus bus;
    private LoadController controller;
    private boolean enabled;
    private String sortingProperties;
    private ArtifactVersion processedVersion;
    private boolean isNetworkMod;
    private List<ab> serverCommands;
    
    public ModLoaderModContainer(final String className, final File modSource, final String sortingProperties) {
        this.requirements = Sets.newHashSet();
        this.dependencies = Lists.newArrayList();
        this.dependants = Lists.newArrayList();
        this.enabled = true;
        this.serverCommands = Lists.newArrayList();
        this.modClazzName = className;
        this.modSource = modSource;
        this.modId = (className.contains(".") ? className.substring(className.lastIndexOf(46) + 1) : className);
        this.sortingProperties = (Strings.isNullOrEmpty(sortingProperties) ? "" : sortingProperties);
    }
    
    ModLoaderModContainer(final BaseModProxy instance) {
        this.requirements = Sets.newHashSet();
        this.dependencies = Lists.newArrayList();
        this.dependants = Lists.newArrayList();
        this.enabled = true;
        this.serverCommands = Lists.newArrayList();
        this.mod = instance;
        this.gameTickHandler = new BaseModTicker(instance, false);
        this.guiTickHandler = new BaseModTicker(instance, true);
    }
    
    private void configureMod(final Class<? extends BaseModProxy> modClazz, final ASMDataTable asmData) {
        final File configDir = Loader.instance().getConfigDir();
        final File modConfig = new File(configDir, String.format("%s.cfg", this.getModId()));
        final Properties props = new Properties();
        boolean existingConfigFound = false;
        boolean mlPropFound = false;
        if (modConfig.exists()) {
            try {
                FMLLog.fine("Reading existing configuration file for %s : %s", this.getModId(), modConfig.getName());
                final FileReader configReader = new FileReader(modConfig);
                props.load(configReader);
                configReader.close();
            }
            catch (final Exception e) {
                FMLLog.log(Level.SEVERE, e, "Error occured reading mod configuration file %s", modConfig.getName());
                throw new LoaderException(e);
            }
            existingConfigFound = true;
        }
        final StringBuffer comments = new StringBuffer();
        comments.append("MLProperties: name (type:default) min:max -- information\n");
        final List<ModProperty> mlPropFields = Lists.newArrayList();
        try {
            for (final ASMDataTable.ASMData dat : Sets.union(asmData.getAnnotationsFor(this).get((Object)"net.minecraft.src.MLProp"), asmData.getAnnotationsFor(this).get((Object)"MLProp"))) {
                if (dat.getClassName().equals(this.modClazzName)) {
                    try {
                        mlPropFields.add(new ModProperty(modClazz.getDeclaredField(dat.getObjectName()), dat.getAnnotationInfo()));
                        FMLLog.finest("Found an MLProp field %s in %s", dat.getObjectName(), this.getModId());
                    }
                    catch (final Exception e2) {
                        FMLLog.log(Level.WARNING, e2, "An error occured trying to access field %s in mod %s", dat.getObjectName(), this.getModId());
                    }
                }
            }
            for (final ModProperty property : mlPropFields) {
                if (!Modifier.isStatic(property.field().getModifiers())) {
                    FMLLog.info("The MLProp field %s in mod %s appears not to be static", property.field().getName(), this.getModId());
                }
                else {
                    FMLLog.finest("Considering MLProp field %s", property.field().getName());
                    final Field f = property.field();
                    final String propertyName = Strings.nullToEmpty(property.name()).isEmpty() ? f.getName() : property.name();
                    String propertyValue = null;
                    Object defaultValue = null;
                    try {
                        defaultValue = f.get(null);
                        propertyValue = props.getProperty(propertyName, this.extractValue(defaultValue));
                        final Object currentValue = this.parseValue(propertyValue, property, f.getType(), propertyName);
                        FMLLog.finest("Configuration for %s.%s found values default: %s, configured: %s, interpreted: %s", this.modClazzName, propertyName, defaultValue, propertyValue, currentValue);
                        if (currentValue != null && !currentValue.equals(defaultValue)) {
                            FMLLog.finest("Configuration for %s.%s value set to: %s", this.modClazzName, propertyName, currentValue);
                            f.set(null, currentValue);
                        }
                    }
                    catch (final Exception e3) {
                        FMLLog.log(Level.SEVERE, e3, "Invalid configuration found for %s in %s", propertyName, modConfig.getName());
                        throw new LoaderException(e3);
                    }
                    finally {
                        comments.append(String.format("MLProp : %s (%s:%s", propertyName, f.getType().getName(), defaultValue));
                        if (property.min() != Double.MIN_VALUE) {
                            comments.append(",>=").append(String.format("%.1f", property.min()));
                        }
                        if (property.max() != Double.MAX_VALUE) {
                            comments.append(",<=").append(String.format("%.1f", property.max()));
                        }
                        comments.append(")");
                        if (!Strings.nullToEmpty(property.info()).isEmpty()) {
                            comments.append(" -- ").append(property.info());
                        }
                        if (propertyValue != null) {
                            props.setProperty(propertyName, this.extractValue(propertyValue));
                        }
                        comments.append("\n");
                    }
                    mlPropFound = true;
                }
            }
        }
        finally {
            if (!mlPropFound && !existingConfigFound) {
                FMLLog.fine("No MLProp configuration for %s found or required. No file written", this.getModId());
                return;
            }
            if (!mlPropFound && existingConfigFound) {
                final File mlPropBackup = new File(modConfig.getParent(), modConfig.getName() + ".bak");
                FMLLog.fine("MLProp configuration file for %s found but not required. Attempting to rename file to %s", this.getModId(), mlPropBackup.getName());
                final boolean renamed = modConfig.renameTo(mlPropBackup);
                if (renamed) {
                    FMLLog.fine("Unused MLProp configuration file for %s renamed successfully to %s", this.getModId(), mlPropBackup.getName());
                }
                else {
                    FMLLog.fine("Unused MLProp configuration file for %s renamed UNSUCCESSFULLY to %s", this.getModId(), mlPropBackup.getName());
                }
                return;
            }
            try {
                final FileWriter configWriter = new FileWriter(modConfig);
                props.store(configWriter, comments.toString());
                configWriter.close();
                FMLLog.fine("Configuration for %s written to %s", this.getModId(), modConfig.getName());
            }
            catch (final IOException e4) {
                FMLLog.log(Level.SEVERE, e4, "Error trying to write the config file %s", modConfig.getName());
                throw new LoaderException(e4);
            }
        }
    }
    
    private Object parseValue(final String val, final ModProperty property, final Class<?> type, final String propertyName) {
        if (type.isAssignableFrom(String.class)) {
            return val;
        }
        if (type.isAssignableFrom(Boolean.TYPE) || type.isAssignableFrom(Boolean.class)) {
            return Boolean.parseBoolean(val);
        }
        if (!Number.class.isAssignableFrom(type) && !type.isPrimitive()) {
            throw new IllegalArgumentException(String.format("MLProp declared on %s of type %s, an unsupported type", propertyName, type.getName()));
        }
        Number n = null;
        if (type.isAssignableFrom(Double.TYPE) || Double.class.isAssignableFrom(type)) {
            n = Double.parseDouble(val);
        }
        else if (type.isAssignableFrom(Float.TYPE) || Float.class.isAssignableFrom(type)) {
            n = Float.parseFloat(val);
        }
        else if (type.isAssignableFrom(Long.TYPE) || Long.class.isAssignableFrom(type)) {
            n = Long.parseLong(val);
        }
        else if (type.isAssignableFrom(Integer.TYPE) || Integer.class.isAssignableFrom(type)) {
            n = Integer.parseInt(val);
        }
        else if (type.isAssignableFrom(Short.TYPE) || Short.class.isAssignableFrom(type)) {
            n = Short.parseShort(val);
        }
        else {
            if (!type.isAssignableFrom(Byte.TYPE) && !Byte.class.isAssignableFrom(type)) {
                throw new IllegalArgumentException(String.format("MLProp declared on %s of type %s, an unsupported type", propertyName, type.getName()));
            }
            n = Byte.parseByte(val);
        }
        final double dVal = n.doubleValue();
        if ((property.min() != Double.MIN_VALUE && dVal < property.min()) || (property.max() != Double.MAX_VALUE && dVal > property.max())) {
            FMLLog.warning("Configuration for %s.%s found value %s outside acceptable range %s,%s", this.modClazzName, propertyName, n, property.min(), property.max());
            return null;
        }
        return n;
    }
    
    private String extractValue(final Object value) {
        if (String.class.isInstance(value)) {
            return (String)value;
        }
        if (Number.class.isInstance(value) || Boolean.class.isInstance(value)) {
            return String.valueOf(value);
        }
        throw new IllegalArgumentException("MLProp declared on non-standard type");
    }
    
    @Override
    public String getName() {
        return (this.mod != null) ? this.mod.getName() : this.modId;
    }
    
    @Override
    public String getSortingRules() {
        return this.sortingProperties;
    }
    
    @Override
    public boolean matches(final Object mod) {
        return this.mod == mod;
    }
    
    public static <A extends BaseModProxy> List<A> findAll(final Class<A> clazz) {
        final ArrayList<A> modList = new ArrayList<A>();
        for (final ModContainer mc : Loader.instance().getActiveModList()) {
            if (mc instanceof ModLoaderModContainer && mc.getMod() != null) {
                modList.add((A)((ModLoaderModContainer)mc).mod);
            }
        }
        return modList;
    }
    
    @Override
    public File getSource() {
        return this.modSource;
    }
    
    @Override
    public Object getMod() {
        return this.mod;
    }
    
    @Override
    public Set<ArtifactVersion> getRequirements() {
        return this.requirements;
    }
    
    @Override
    public List<ArtifactVersion> getDependants() {
        return this.dependants;
    }
    
    @Override
    public List<ArtifactVersion> getDependencies() {
        return this.dependencies;
    }
    
    @Override
    public String toString() {
        return this.modId;
    }
    
    @Override
    public ModMetadata getMetadata() {
        return this.metadata;
    }
    
    @Override
    public String getVersion() {
        if (this.mod == null || this.mod.getVersion() == null) {
            return "Not available";
        }
        return this.mod.getVersion();
    }
    
    public BaseModTicker getGameTickHandler() {
        return this.gameTickHandler;
    }
    
    public BaseModTicker getGUITickHandler() {
        return this.guiTickHandler;
    }
    
    @Override
    public String getModId() {
        return this.modId;
    }
    
    @Override
    public void bindMetadata(final MetadataCollection mc) {
        final Map<String, Object> dummyMetadata = (Map<String, Object>)ImmutableMap.builder().put((Object)"name", (Object)this.modId).put((Object)"version", (Object)"1.0").build();
        this.metadata = mc.getMetadataForId(this.modId, dummyMetadata);
        Loader.instance().computeDependencies(this.sortingProperties, this.getRequirements(), this.getDependencies(), this.getDependants());
    }
    
    @Override
    public void setEnabledState(final boolean enabled) {
        this.enabled = enabled;
    }
    
    @Override
    public boolean registerBus(final EventBus bus, final LoadController controller) {
        if (this.enabled) {
            FMLLog.fine("Enabling mod %s", this.getModId());
            this.bus = bus;
            this.controller = controller;
            bus.register((Object)this);
            return true;
        }
        return false;
    }
    
    @Subscribe
    public void constructMod(final FMLConstructionEvent event) {
        try {
            final ModClassLoader modClassLoader = event.getModClassLoader();
            modClassLoader.addFile(this.modSource);
            final EnumSet<TickType> ticks = EnumSet.noneOf(TickType.class);
            this.gameTickHandler = new BaseModTicker(ticks, false);
            this.guiTickHandler = new BaseModTicker(ticks.clone(), true);
            final Class<? extends BaseModProxy> modClazz = modClassLoader.loadBaseModClass(this.modClazzName);
            this.configureMod(modClazz, event.getASMHarvestedData());
            this.isNetworkMod = FMLNetworkHandler.instance().registerNetworkMod(this, modClazz, event.getASMHarvestedData());
            ModLoaderNetworkHandler dummyHandler = null;
            if (!this.isNetworkMod) {
                FMLLog.fine("Injecting dummy network mod handler for BaseMod %s", this.getModId());
                dummyHandler = new ModLoaderNetworkHandler(this);
                FMLNetworkHandler.instance().registerNetworkMod(dummyHandler);
            }
            final Constructor<? extends BaseModProxy> ctor = modClazz.getConstructor((Class<?>[])new Class[0]);
            ctor.setAccessible(true);
            this.mod = (BaseModProxy)modClazz.newInstance();
            if (dummyHandler != null) {
                dummyHandler.setBaseMod(this.mod);
            }
            ProxyInjector.inject(this, event.getASMHarvestedData(), FMLCommonHandler.instance().getSide(), new ILanguageAdapter.JavaAdapter());
        }
        catch (final Exception e) {
            this.controller.errorOccurred(this, e);
            Throwables.propagateIfPossible((Throwable)e);
        }
    }
    
    @Subscribe
    public void preInit(final FMLPreInitializationEvent event) {
        try {
            this.gameTickHandler.setMod(this.mod);
            this.guiTickHandler.setMod(this.mod);
            TickRegistry.registerTickHandler(this.gameTickHandler, Side.CLIENT);
            TickRegistry.registerTickHandler(this.guiTickHandler, Side.CLIENT);
            GameRegistry.registerWorldGenerator(ModLoaderHelper.buildWorldGenHelper(this.mod));
            GameRegistry.registerFuelHandler(ModLoaderHelper.buildFuelHelper(this.mod));
            GameRegistry.registerCraftingHandler(ModLoaderHelper.buildCraftingHelper(this.mod));
            GameRegistry.registerPickupHandler(ModLoaderHelper.buildPickupHelper(this.mod));
            NetworkRegistry.instance().registerChatListener(ModLoaderHelper.buildChatListener(this.mod));
            NetworkRegistry.instance().registerConnectionHandler(ModLoaderHelper.buildConnectionHelper(this.mod));
        }
        catch (final Exception e) {
            this.controller.errorOccurred(this, e);
            Throwables.propagateIfPossible((Throwable)e);
        }
    }
    
    @Subscribe
    public void init(final FMLInitializationEvent event) {
        try {
            this.mod.load();
        }
        catch (final Throwable t) {
            this.controller.errorOccurred(this, t);
            Throwables.propagateIfPossible(t);
        }
    }
    
    @Subscribe
    public void postInit(final FMLPostInitializationEvent event) {
        try {
            this.mod.modsLoaded();
        }
        catch (final Throwable t) {
            this.controller.errorOccurred(this, t);
            Throwables.propagateIfPossible(t);
        }
    }
    
    @Subscribe
    public void loadComplete(final FMLLoadCompleteEvent complete) {
        ModLoaderHelper.finishModLoading(this);
    }
    
    @Subscribe
    public void serverStarting(final FMLServerStartingEvent evt) {
        for (final ab cmd : this.serverCommands) {
            evt.registerServerCommand(cmd);
        }
    }
    
    @Override
    public ArtifactVersion getProcessedVersion() {
        if (this.processedVersion == null) {
            this.processedVersion = new DefaultArtifactVersion(this.modId, this.getVersion());
        }
        return this.processedVersion;
    }
    
    @Override
    public boolean isImmutable() {
        return false;
    }
    
    @Override
    public boolean isNetworkMod() {
        return this.isNetworkMod;
    }
    
    @Override
    public String getDisplayVersion() {
        return (this.metadata != null) ? this.metadata.version : this.getVersion();
    }
    
    public void addServerCommand(final ab command) {
        this.serverCommands.add(command);
    }
    
    @Override
    public VersionRange acceptableMinecraftVersionRange() {
        return Loader.instance().getMinecraftModContainer().getStaticVersionRange();
    }
    
    @Override
    public Certificate getSigningCertificate() {
        return null;
    }
    
    @Override
    public Map<String, String> getCustomModProperties() {
        return ModLoaderModContainer.EMPTY_PROPERTIES;
    }
    
    @Override
    public Class<?> getCustomResourcePackClass() {
        return null;
    }
    
    @Override
    public Map<String, String> getSharedModDescriptor() {
        final Map<String, String> descriptor = Maps.newHashMap();
        descriptor.put("modsystem", "ModLoader");
        descriptor.put("id", this.getModId());
        descriptor.put("version", this.getDisplayVersion());
        descriptor.put("name", this.getName());
        descriptor.put("url", this.metadata.url);
        descriptor.put("authors", this.metadata.getAuthorList());
        descriptor.put("description", this.metadata.description);
        return descriptor;
    }
}



================================================
FILE: cpw/mods/fml/common/modloader/ModLoaderNetworkHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.modloader;

import cpw.mods.fml.common.network.NetworkMod;
import cpw.mods.fml.common.ModContainer;
import cpw.mods.fml.common.network.NetworkModHandler;

public class ModLoaderNetworkHandler extends NetworkModHandler
{
    private BaseModProxy baseMod;
    
    public ModLoaderNetworkHandler(final ModLoaderModContainer mlmc) {
        super(mlmc, null);
    }
    
    public void setBaseMod(final BaseModProxy baseMod) {
        this.baseMod = baseMod;
    }
    
    @Override
    public boolean requiresClientSide() {
        return false;
    }
    
    @Override
    public boolean requiresServerSide() {
        return false;
    }
    
    @Override
    public boolean acceptVersion(final String version) {
        return this.baseMod.getVersion().equals(version);
    }
    
    @Override
    public boolean isNetworkMod() {
        return true;
    }
}



================================================
FILE: cpw/mods/fml/common/modloader/ModLoaderPacketHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.modloader;

import cpw.mods.fml.common.network.Player;
import cpw.mods.fml.common.network.IPacketHandler;

public class ModLoaderPacketHandler implements IPacketHandler
{
    private BaseModProxy mod;
    
    public ModLoaderPacketHandler(final BaseModProxy mod) {
        this.mod = mod;
    }
    
    @Override
    public void onPacketData(final cm manager, final ea packet, final Player player) {
        if (player instanceof jv) {
            this.mod.serverCustomPayload(((jv)player).a, packet);
        }
        else {
            ModLoaderHelper.sidedHelper.sendClientPacket(this.mod, packet);
        }
    }
}



================================================
FILE: cpw/mods/fml/common/modloader/ModLoaderPickupNotifier.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.modloader;

import cpw.mods.fml.common.IPickupNotifier;

public class ModLoaderPickupNotifier implements IPickupNotifier
{
    private BaseModProxy mod;
    
    public ModLoaderPickupNotifier(final BaseModProxy mod) {
        this.mod = mod;
    }
    
    @Override
    public void notifyPickup(final ss item, final uf player) {
        this.mod.onItemPickup(player, item.d());
    }
}



================================================
FILE: cpw/mods/fml/common/modloader/ModLoaderVillageTradeHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.modloader;

import java.util.Iterator;
import java.util.Random;
import com.google.common.collect.Lists;
import java.util.List;
import cpw.mods.fml.common.registry.VillagerRegistry;

public class ModLoaderVillageTradeHandler implements VillagerRegistry.IVillageTradeHandler
{
    private List<TradeEntry> trades;
    
    public ModLoaderVillageTradeHandler() {
        this.trades = Lists.newArrayList();
    }
    
    @Override
    public void manipulateTradesForVillager(final ub villager, final abm recipeList, final Random random) {
        for (final TradeEntry ent : this.trades) {
            if (ent.buying) {
                VillagerRegistry.addEmeraldBuyRecipe(villager, recipeList, random, yc.g[ent.id], ent.chance, ent.min, ent.max);
            }
            else {
                VillagerRegistry.addEmeraldSellRecipe(villager, recipeList, random, yc.g[ent.id], ent.chance, ent.min, ent.max);
            }
        }
    }
    
    public void addTrade(final TradeEntry entry) {
        this.trades.add(entry);
    }
}



================================================
FILE: cpw/mods/fml/common/modloader/ModLoaderWorldGenerator.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.modloader;

import java.util.Random;
import cpw.mods.fml.common.IWorldGenerator;

public class ModLoaderWorldGenerator implements IWorldGenerator
{
    private BaseModProxy mod;
    
    public ModLoaderWorldGenerator(final BaseModProxy mod) {
        this.mod = mod;
    }
    
    @Override
    public void generate(final Random random, final int chunkX, final int chunkZ, final abw world, final ado chunkGenerator, final ado chunkProvider) {
        if (chunkGenerator instanceof aet) {
            this.mod.generateSurface(world, random, chunkX << 4, chunkZ << 4);
        }
        else if (chunkGenerator instanceof aep) {
            this.mod.generateNether(world, random, chunkX << 4, chunkZ << 4);
        }
    }
}



================================================
FILE: cpw/mods/fml/common/modloader/ModProperty.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.modloader;

import java.util.Map;
import java.lang.reflect.Field;

public class ModProperty
{
    private String info;
    private double min;
    private double max;
    private String name;
    private Field field;
    
    public ModProperty(final Field f, final String info, final Double min, final Double max, final String name) {
        this.field = f;
        this.info = info;
        this.min = ((min != null) ? min : Double.MIN_VALUE);
        this.max = ((max != null) ? max : Double.MAX_VALUE);
        this.name = name;
    }
    
    public ModProperty(final Field field, final Map<String, Object> annotationInfo) {
        this(field, annotationInfo.get("info"), annotationInfo.get("min"), annotationInfo.get("max"), annotationInfo.get("name"));
    }
    
    public String name() {
        return this.name;
    }
    
    public double min() {
        return this.min;
    }
    
    public double max() {
        return this.max;
    }
    
    public String info() {
        return this.info;
    }
    
    public Field field() {
        return this.field;
    }
}



================================================
FILE: cpw/mods/fml/common/network/EntitySpawnAdjustmentPacket.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

import cpw.mods.fml.common.FMLCommonHandler;
import com.google.common.io.ByteArrayDataInput;
import com.google.common.io.ByteArrayDataOutput;
import com.google.common.io.ByteStreams;

public class EntitySpawnAdjustmentPacket extends FMLPacket
{
    public int entityId;
    public int serverX;
    public int serverY;
    public int serverZ;
    
    public EntitySpawnAdjustmentPacket() {
        super(Type.ENTITYSPAWNADJUSTMENT);
    }
    
    @Override
    public byte[] generatePacket(final Object... data) {
        final ByteArrayDataOutput dat = ByteStreams.newDataOutput();
        dat.writeInt((int)data[0]);
        dat.writeInt((int)data[1]);
        dat.writeInt((int)data[2]);
        dat.writeInt((int)data[3]);
        return dat.toByteArray();
    }
    
    @Override
    public FMLPacket consumePacket(final byte[] data) {
        final ByteArrayDataInput dat = ByteStreams.newDataInput(data);
        this.entityId = dat.readInt();
        this.serverX = dat.readInt();
        this.serverY = dat.readInt();
        this.serverZ = dat.readInt();
        return this;
    }
    
    @Override
    public void execute(final cm network, final FMLNetworkHandler handler, final ez netHandler, final String userName) {
        FMLCommonHandler.instance().adjustEntityLocationOnClient(this);
    }
}



================================================
FILE: cpw/mods/fml/common/network/EntitySpawnPacket.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

import cpw.mods.fml.common.ModContainer;
import cpw.mods.fml.common.FMLCommonHandler;
import cpw.mods.fml.common.FMLLog;
import java.util.logging.Level;
import java.io.DataInput;
import java.io.InputStream;
import java.io.DataInputStream;
import java.io.ByteArrayInputStream;
import com.google.common.io.ByteArrayDataOutput;
import cpw.mods.fml.common.registry.IEntityAdditionalSpawnData;
import cpw.mods.fml.common.registry.IThrowableEntity;
import java.io.IOException;
import java.io.DataOutput;
import java.io.OutputStream;
import java.io.DataOutputStream;
import java.io.ByteArrayOutputStream;
import com.google.common.io.ByteStreams;
import cpw.mods.fml.common.registry.EntityRegistry;
import com.google.common.io.ByteArrayDataInput;
import java.util.List;

public class EntitySpawnPacket extends FMLPacket
{
    public int networkId;
    public int modEntityId;
    public int entityId;
    public double scaledX;
    public double scaledY;
    public double scaledZ;
    public float scaledYaw;
    public float scaledPitch;
    public float scaledHeadYaw;
    public List metadata;
    public int throwerId;
    public double speedScaledX;
    public double speedScaledY;
    public double speedScaledZ;
    public ByteArrayDataInput dataStream;
    public int rawX;
    public int rawY;
    public int rawZ;
    
    public EntitySpawnPacket() {
        super(Type.ENTITYSPAWN);
    }
    
    @Override
    public byte[] generatePacket(final Object... data) {
        final EntityRegistry.EntityRegistration er = (EntityRegistry.EntityRegistration)data[0];
        final nn ent = (nn)data[1];
        final NetworkModHandler handler = (NetworkModHandler)data[2];
        final ByteArrayDataOutput dat = ByteStreams.newDataOutput();
        dat.writeInt(handler.getNetworkId());
        dat.writeInt(er.getModEntityId());
        dat.writeInt(ent.k);
        dat.writeInt(ls.c(ent.u * 32.0));
        dat.writeInt(ls.c(ent.v * 32.0));
        dat.writeInt(ls.c(ent.w * 32.0));
        dat.writeByte((int)(byte)(ent.A * 256.0f / 360.0f));
        dat.writeByte((int)(byte)(ent.B * 256.0f / 360.0f));
        if (ent instanceof og) {
            dat.writeByte((int)(byte)(((og)ent).aP * 256.0f / 360.0f));
        }
        else {
            dat.writeByte(0);
        }
        final ByteArrayOutputStream bos = new ByteArrayOutputStream();
        final DataOutputStream dos = new DataOutputStream(bos);
        try {
            ent.v().a((DataOutput)dos);
        }
        catch (final IOException ex) {}
        dat.write(bos.toByteArray());
        if (ent instanceof IThrowableEntity) {
            final nn owner = ((IThrowableEntity)ent).getThrower();
            dat.writeInt((owner == null) ? ent.k : owner.k);
            final double maxVel = 3.9;
            double mX = ent.x;
            double mY = ent.y;
            double mZ = ent.z;
            if (mX < -maxVel) {
                mX = -maxVel;
            }
            if (mY < -maxVel) {
                mY = -maxVel;
            }
            if (mZ < -maxVel) {
                mZ = -maxVel;
            }
            if (mX > maxVel) {
                mX = maxVel;
            }
            if (mY > maxVel) {
                mY = maxVel;
            }
            if (mZ > maxVel) {
                mZ = maxVel;
            }
            dat.writeInt((int)(mX * 8000.0));
            dat.writeInt((int)(mY * 8000.0));
            dat.writeInt((int)(mZ * 8000.0));
        }
        else {
            dat.writeInt(0);
        }
        if (ent instanceof IEntityAdditionalSpawnData) {
            ((IEntityAdditionalSpawnData)ent).writeSpawnData(dat);
        }
        return dat.toByteArray();
    }
    
    @Override
    public FMLPacket consumePacket(final byte[] data) {
        final ByteArrayDataInput dat = ByteStreams.newDataInput(data);
        this.networkId = dat.readInt();
        this.modEntityId = dat.readInt();
        this.entityId = dat.readInt();
        this.rawX = dat.readInt();
        this.rawY = dat.readInt();
        this.rawZ = dat.readInt();
        this.scaledX = this.rawX / 32.0;
        this.scaledY = this.rawY / 32.0;
        this.scaledZ = this.rawZ / 32.0;
        this.scaledYaw = dat.readByte() * 360.0f / 256.0f;
        this.scaledPitch = dat.readByte() * 360.0f / 256.0f;
        this.scaledHeadYaw = dat.readByte() * 360.0f / 256.0f;
        final ByteArrayInputStream bis = new ByteArrayInputStream(data, 27, data.length - 27);
        final DataInputStream dis = new DataInputStream(bis);
        try {
            this.metadata = oo.a((DataInput)dis);
        }
        catch (final IOException ex) {}
        dat.skipBytes(data.length - bis.available() - 27);
        this.throwerId = dat.readInt();
        if (this.throwerId != 0) {
            this.speedScaledX = dat.readInt() / 8000.0;
            this.speedScaledY = dat.readInt() / 8000.0;
            this.speedScaledZ = dat.readInt() / 8000.0;
        }
        this.dataStream = dat;
        return this;
    }
    
    @Override
    public void execute(final cm network, final FMLNetworkHandler handler, final ez netHandler, final String userName) {
        final NetworkModHandler nmh = handler.findNetworkModHandler(this.networkId);
        final ModContainer mc = nmh.getContainer();
        final EntityRegistry.EntityRegistration registration = EntityRegistry.instance().lookupModSpawn(mc, this.modEntityId);
        if (registration == null || registration.getEntityClass() == null) {
            FMLLog.log(Level.WARNING, "Missing mod entity information for %s : %d", mc.getModId(), this.modEntityId);
            return;
        }
        final nn entity = FMLCommonHandler.instance().spawnEntityIntoClientWorld(registration, this);
    }
}



================================================
FILE: cpw/mods/fml/common/network/FMLNetworkException.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

public class FMLNetworkException extends RuntimeException
{
    public FMLNetworkException(final Exception e) {
        super(e);
    }
    
    public FMLNetworkException() {
    }
}



================================================
FILE: cpw/mods/fml/common/network/FMLNetworkHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

import com.google.common.hash.Hashing;
import java.io.IOException;
import java.util.Iterator;
import java.util.List;
import java.util.Collection;
import java.util.Collections;
import java.net.NetworkInterface;
import com.google.common.collect.Lists;
import java.net.InetAddress;
import cpw.mods.fml.common.registry.EntityRegistry;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.common.Loader;
import cpw.mods.fml.common.registry.GameRegistry;
import java.util.Set;
import cpw.mods.fml.common.InjectedModContainer;
import cpw.mods.fml.common.discovery.ASMDataTable;
import cpw.mods.fml.common.FMLCommonHandler;
import cpw.mods.fml.common.FMLLog;
import java.net.SocketAddress;
import net.minecraft.server.MinecraftServer;
import com.google.common.collect.Maps;
import cpw.mods.fml.common.ModContainer;
import java.util.Map;

public class FMLNetworkHandler
{
    private static final int FML_HASH;
    private static final int PROTOCOL_VERSION = 2;
    private static final FMLNetworkHandler INSTANCE;
    static final int LOGIN_RECEIVED = 1;
    static final int CONNECTION_VALID = 2;
    static final int FML_OUT_OF_DATE = -1;
    static final int MISSING_MODS_OR_VERSIONS = -2;
    private Map<jy, Integer> loginStates;
    private Map<ModContainer, NetworkModHandler> networkModHandlers;
    private Map<Integer, NetworkModHandler> networkIdLookup;
    
    public FMLNetworkHandler() {
        this.loginStates = Maps.newHashMap();
        this.networkModHandlers = Maps.newHashMap();
        this.networkIdLookup = Maps.newHashMap();
    }
    
    public static void handlePacket250Packet(final ea packet, final cm network, final ez handler) {
        final String target = packet.a;
        if (target.startsWith("MC|")) {
            handler.handleVanilla250Packet(packet);
        }
        if (target.equals("FML")) {
            instance().handleFMLPacket(packet, network, handler);
        }
        else {
            NetworkRegistry.instance().handleCustomPacket(packet, network, handler);
        }
    }
    
    public static void onConnectionEstablishedToServer(final ez clientHandler, final cm manager, final ep login) {
        NetworkRegistry.instance().clientLoggedIn(clientHandler, manager, login);
    }
    
    private void handleFMLPacket(final ea packet, final cm network, final ez netHandler) {
        final FMLPacket pkt = FMLPacket.readPacket(network, packet.c);
        if (pkt == null) {
            return;
        }
        String userName = "";
        if (netHandler instanceof jy) {
            userName = ((jy)netHandler).g;
        }
        else {
            final uf pl = netHandler.getPlayer();
            if (pl != null) {
                userName = pl.c_();
            }
        }
        pkt.execute(network, this, netHandler, userName);
    }
    
    public static void onConnectionReceivedFromClient(final jy netLoginHandler, final MinecraftServer server, final SocketAddress address, final String userName) {
        instance().handleClientConnection(netLoginHandler, server, address, userName);
    }
    
    private void handleClientConnection(final jy netLoginHandler, final MinecraftServer server, final SocketAddress address, final String userName) {
        if (this.loginStates.containsKey(netLoginHandler)) {
            switch (this.loginStates.get(netLoginHandler)) {
                case 1: {
                    final String modKick = NetworkRegistry.instance().connectionReceived(netLoginHandler, (cm)netLoginHandler.a);
                    if (modKick != null) {
                        netLoginHandler.completeConnection(modKick);
                        this.loginStates.remove(netLoginHandler);
                        return;
                    }
                    if (!this.handleVanillaLoginKick(netLoginHandler, server, address, userName)) {
                        this.loginStates.remove(netLoginHandler);
                        return;
                    }
                    jy.a(netLoginHandler, false);
                    netLoginHandler.a.a((ey)this.getModListRequestPacket());
                    this.loginStates.put(netLoginHandler, 2);
                    break;
                }
                case 2: {
                    netLoginHandler.completeConnection((String)null);
                    this.loginStates.remove(netLoginHandler);
                    break;
                }
                case -2: {
                    netLoginHandler.completeConnection("The server requires mods that are absent or out of date on your client");
                    this.loginStates.remove(netLoginHandler);
                    break;
                }
                case -1: {
                    netLoginHandler.completeConnection("Your client is not running a new enough version of FML to connect to this server");
                    this.loginStates.remove(netLoginHandler);
                    break;
                }
                default: {
                    netLoginHandler.completeConnection("There was a problem during FML negotiation");
                    this.loginStates.remove(netLoginHandler);
                    break;
                }
            }
            return;
        }
        if (this.handleVanillaLoginKick(netLoginHandler, server, address, userName)) {
            FMLLog.fine("Connection from %s rejected - no FML packet received from client", userName);
            netLoginHandler.completeConnection("You don't have FML installed, you cannot connect to this server");
            return;
        }
        FMLLog.fine("Connection from %s was closed by vanilla minecraft", userName);
    }
    
    private boolean handleVanillaLoginKick(final jy netLoginHandler, final MinecraftServer server, final SocketAddress address, final String userName) {
        final hn playerList = server.af();
        final String kickReason = playerList.a(address, userName);
        if (kickReason != null) {
            netLoginHandler.completeConnection(kickReason);
        }
        return kickReason == null;
    }
    
    public static void handleLoginPacketOnServer(final jy handler, final ep login) {
        if (login.a == FMLNetworkHandler.FML_HASH) {
            if (login.e == 2) {
                FMLLog.finest("Received valid FML login packet from %s", handler.a.c());
                instance().loginStates.put(handler, 1);
            }
            else if (login.e != 2) {
                FMLLog.finest("Received incorrect FML (%x) login packet from %s", login.e, handler.a.c());
                instance().loginStates.put(handler, -1);
            }
        }
        else {
            FMLLog.fine("Received invalid login packet (%x, %x) from %s", login.a, login.e, handler.a.c());
        }
    }
    
    static void setHandlerState(final jy handler, final int state) {
        instance().loginStates.put(handler, state);
    }
    
    public static FMLNetworkHandler instance() {
        return FMLNetworkHandler.INSTANCE;
    }
    
    public static ep getFMLFakeLoginPacket() {
        FMLCommonHandler.instance().getSidedDelegate().setClientCompatibilityLevel((byte)0);
        final ep fake = new ep();
        fake.a = FMLNetworkHandler.FML_HASH;
        fake.e = 2;
        fake.d = ace.a;
        fake.b = acg.a[0];
        return fake;
    }
    
    public ea getModListRequestPacket() {
        return PacketDispatcher.getPacket("FML", FMLPacket.makePacket(FMLPacket.Type.MOD_LIST_REQUEST, new Object[0]));
    }
    
    public void registerNetworkMod(final NetworkModHandler handler) {
        this.networkModHandlers.put(handler.getContainer(), handler);
        this.networkIdLookup.put(handler.getNetworkId(), handler);
    }
    
    public boolean registerNetworkMod(final ModContainer container, final Class<?> networkModClass, final ASMDataTable asmData) {
        final NetworkModHandler handler = new NetworkModHandler(container, networkModClass, asmData);
        if (handler.isNetworkMod()) {
            this.registerNetworkMod(handler);
        }
        return handler.isNetworkMod();
    }
    
    public NetworkModHandler findNetworkModHandler(final Object mc) {
        if (mc instanceof InjectedModContainer) {
            return this.networkModHandlers.get(((InjectedModContainer)mc).wrappedContainer);
        }
        if (mc instanceof ModContainer) {
            return this.networkModHandlers.get(mc);
        }
        if (mc instanceof Integer) {
            return this.networkIdLookup.get(mc);
        }
        return this.networkModHandlers.get(FMLCommonHandler.instance().findContainerFor(mc));
    }
    
    public Set<ModContainer> getNetworkModList() {
        return this.networkModHandlers.keySet();
    }
    
    public static void handlePlayerLogin(final jv player, final ka netHandler, final cm manager) {
        NetworkRegistry.instance().playerLoggedIn(player, netHandler, manager);
        GameRegistry.onPlayerLogin((uf)player);
    }
    
    public Map<Integer, NetworkModHandler> getNetworkIdMap() {
        return this.networkIdLookup;
    }
    
    public void bindNetworkId(final String key, final Integer value) {
        final Map<String, ModContainer> mods = Loader.instance().getIndexedModList();
        final NetworkModHandler handler = this.findNetworkModHandler(mods.get(key));
        if (handler != null) {
            handler.setNetworkId(value);
            this.networkIdLookup.put(value, handler);
        }
    }
    
    public static void onClientConnectionToRemoteServer(final ez netClientHandler, final String server, final int port, final cm networkManager) {
        NetworkRegistry.instance().connectionOpened(netClientHandler, server, port, networkManager);
    }
    
    public static void onClientConnectionToIntegratedServer(final ez netClientHandler, final MinecraftServer server, final cm networkManager) {
        NetworkRegistry.instance().connectionOpened(netClientHandler, server, networkManager);
    }
    
    public static void onConnectionClosed(final cm manager, final uf player) {
        NetworkRegistry.instance().connectionClosed(manager, player);
    }
    
    public static void openGui(final uf player, final Object mod, final int modGuiId, final abw world, final int x, final int y, final int z) {
        ModContainer mc = FMLCommonHandler.instance().findContainerFor(mod);
        if (mc == null) {
            final NetworkModHandler nmh = instance().findNetworkModHandler(mod);
            if (nmh == null) {
                FMLLog.warning("A mod tried to open a gui on the server without being a NetworkMod", new Object[0]);
                return;
            }
            mc = nmh.getContainer();
        }
        if (player instanceof jv) {
            NetworkRegistry.instance().openRemoteGui(mc, (jv)player, modGuiId, world, x, y, z);
        }
        else if (FMLCommonHandler.instance().getSide().equals(Side.CLIENT)) {
            NetworkRegistry.instance().openLocalGui(mc, player, modGuiId, world, x, y, z);
        }
        else {
            FMLLog.fine("Invalid attempt to open a local GUI on a dedicated server. This is likely a bug. GUIID: %s,%d", mc.getModId(), modGuiId);
        }
    }
    
    public static ey getEntitySpawningPacket(final nn entity) {
        final EntityRegistry.EntityRegistration er = EntityRegistry.instance().lookupModSpawn(entity.getClass(), false);
        if (er == null) {
            return null;
        }
        if (er.usesVanillaSpawning()) {
            return null;
        }
        return (ey)PacketDispatcher.getPacket("FML", FMLPacket.makePacket(FMLPacket.Type.ENTITYSPAWN, er, entity, instance().findNetworkModHandler(er.getContainer())));
    }
    
    public static void makeEntitySpawnAdjustment(final int entityId, final jv player, final int serverX, final int serverY, final int serverZ) {
        final ea pkt = PacketDispatcher.getPacket("FML", FMLPacket.makePacket(FMLPacket.Type.ENTITYSPAWNADJUSTMENT, entityId, serverX, serverY, serverZ));
        player.a.b((ey)pkt);
    }
    
    public static InetAddress computeLocalHost() throws IOException {
        InetAddress add = null;
        final List<InetAddress> addresses = Lists.newArrayList();
        final InetAddress localHost = InetAddress.getLocalHost();
        for (final NetworkInterface ni : Collections.list(NetworkInterface.getNetworkInterfaces())) {
            if (!ni.isLoopback() && ni.isUp()) {
                addresses.addAll(Collections.list(ni.getInetAddresses()));
                if (addresses.contains(localHost)) {
                    add = localHost;
                    break;
                }
                continue;
            }
        }
        if (add == null && !addresses.isEmpty()) {
            for (final InetAddress addr : addresses) {
                if (addr.getAddress().length == 4) {
                    add = addr;
                    break;
                }
            }
        }
        if (add == null) {
            add = localHost;
        }
        return add;
    }
    
    public static dm handleChatMessage(final ez handler, final dm chat) {
        return NetworkRegistry.instance().handleChat(handler, chat);
    }
    
    public static void handlePacket131Packet(final ez handler, final dr mapData) {
        if (handler instanceof ka || mapData.a != yc.bf.cv) {
            NetworkRegistry.instance().handleTinyPacket(handler, mapData);
        }
        else {
            FMLCommonHandler.instance().handleTinyPacket(handler, mapData);
        }
    }
    
    public static int getCompatibilityLevel() {
        return 2;
    }
    
    public static boolean vanillaLoginPacketCompatibility() {
        return FMLCommonHandler.instance().getSidedDelegate().getClientCompatibilityLevel() == 0;
    }
    
    static {
        FML_HASH = Hashing.murmur3_32().hashString((CharSequence)"FML").asInt();
        INSTANCE = new FMLNetworkHandler();
    }
}



================================================
FILE: cpw/mods/fml/common/network/FMLPacket.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

import com.google.common.collect.MapMaker;
import cpw.mods.fml.common.FMLLog;
import java.util.logging.Level;
import com.google.common.base.Throwables;
import java.util.concurrent.ConcurrentMap;
import com.google.common.primitives.Bytes;
import java.util.Arrays;
import com.google.common.primitives.Ints;
import com.google.common.primitives.UnsignedBytes;

public abstract class FMLPacket
{
    private Type type;
    
    public static byte[][] makePacketSet(final Type type, final Object... data) {
        if (!type.isMultipart()) {
            return new byte[0][];
        }
        final byte[] packetData = type.make().generatePacket(data);
        final byte[][] chunks = new byte[packetData.length / 32000 + 1][];
        for (int i = 0; i < packetData.length / 32000 + 1; ++i) {
            final int len = Math.min(32000, packetData.length - i * 32000);
            chunks[i] = Bytes.concat(new byte[][] { { UnsignedBytes.checkedCast((long)type.ordinal()), UnsignedBytes.checkedCast((long)i), UnsignedBytes.checkedCast((long)chunks.length) }, Ints.toByteArray(len), Arrays.copyOfRange(packetData, i * 32000, len + i * 32000) });
        }
        return chunks;
    }
    
    public static byte[] makePacket(final Type type, final Object... data) {
        final byte[] packetData = type.make().generatePacket(data);
        return Bytes.concat(new byte[][] { { UnsignedBytes.checkedCast((long)type.ordinal()) }, packetData });
    }
    
    public static FMLPacket readPacket(final cm network, final byte[] payload) {
        final int type = UnsignedBytes.toInt(payload[0]);
        final Type eType = Type.values()[type];
        FMLPacket pkt;
        if (eType.isMultipart()) {
            pkt = eType.findCurrentPart(network);
        }
        else {
            pkt = eType.make();
        }
        return pkt.consumePacket(Arrays.copyOfRange(payload, 1, payload.length));
    }
    
    public FMLPacket(final Type type) {
        this.type = type;
    }
    
    public abstract byte[] generatePacket(final Object... p0);
    
    public abstract FMLPacket consumePacket(final byte[] p0);
    
    public abstract void execute(final cm p0, final FMLNetworkHandler p1, final ez p2, final String p3);
    
    enum Type
    {
        MOD_LIST_REQUEST((Class<? extends FMLPacket>)ModListRequestPacket.class, false), 
        MOD_LIST_RESPONSE((Class<? extends FMLPacket>)ModListResponsePacket.class, false), 
        MOD_IDENTIFIERS((Class<? extends FMLPacket>)ModIdentifiersPacket.class, false), 
        MOD_MISSING((Class<? extends FMLPacket>)ModMissingPacket.class, false), 
        GUIOPEN((Class<? extends FMLPacket>)OpenGuiPacket.class, false), 
        ENTITYSPAWN((Class<? extends FMLPacket>)EntitySpawnPacket.class, false), 
        ENTITYSPAWNADJUSTMENT((Class<? extends FMLPacket>)EntitySpawnAdjustmentPacket.class, false), 
        MOD_IDMAP((Class<? extends FMLPacket>)ModIdMapPacket.class, true);
        
        private Class<? extends FMLPacket> packetType;
        private boolean isMultipart;
        private ConcurrentMap<cm, FMLPacket> partTracker;
        
        private Type(final Class<? extends FMLPacket> clazz, final boolean isMultipart) {
            this.packetType = clazz;
            this.isMultipart = isMultipart;
        }
        
        FMLPacket make() {
            try {
                return (FMLPacket)this.packetType.newInstance();
            }
            catch (final Exception e) {
                Throwables.propagateIfPossible((Throwable)e);
                FMLLog.log(Level.SEVERE, e, "A bizarre critical error occured during packet encoding", new Object[0]);
                throw new FMLNetworkException(e);
            }
        }
        
        public boolean isMultipart() {
            return this.isMultipart;
        }
        
        private FMLPacket findCurrentPart(final cm network) {
            if (this.partTracker == null) {
                this.partTracker = new MapMaker().weakKeys().weakValues().makeMap();
            }
            if (!this.partTracker.containsKey(network)) {
                this.partTracker.put(network, this.make());
            }
            return this.partTracker.get(network);
        }
    }
}



================================================
FILE: cpw/mods/fml/common/network/IChatListener.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

public interface IChatListener
{
    dm serverChat(final ez p0, final dm p1);
    
    dm clientChat(final ez p0, final dm p1);
}



================================================
FILE: cpw/mods/fml/common/network/IConnectionHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

import net.minecraft.server.MinecraftServer;

public interface IConnectionHandler
{
    void playerLoggedIn(final Player p0, final ez p1, final cm p2);
    
    String connectionReceived(final jy p0, final cm p1);
    
    void connectionOpened(final ez p0, final String p1, final int p2, final cm p3);
    
    void connectionOpened(final ez p0, final MinecraftServer p1, final cm p2);
    
    void connectionClosed(final cm p0);
    
    void clientLoggedIn(final ez p0, final cm p1, final ep p2);
}



================================================
FILE: cpw/mods/fml/common/network/IGuiHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

public interface IGuiHandler
{
    Object getServerGuiElement(final int p0, final uf p1, final abw p2, final int p3, final int p4, final int p5);
    
    Object getClientGuiElement(final int p0, final uf p1, final abw p2, final int p3, final int p4, final int p5);
}



================================================
FILE: cpw/mods/fml/common/network/IPacketHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

public interface IPacketHandler
{
    void onPacketData(final cm p0, final ea p1, final Player p2);
}



================================================
FILE: cpw/mods/fml/common/network/ITinyPacketHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

public interface ITinyPacketHandler
{
    void handle(final ez p0, final dr p1);
}



================================================
FILE: cpw/mods/fml/common/network/ModIdentifiersPacket.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

import com.google.common.io.ByteArrayDataInput;
import java.util.Iterator;
import java.util.Collection;
import com.google.common.io.ByteArrayDataOutput;
import com.google.common.io.ByteStreams;
import com.google.common.collect.Maps;
import java.util.Map;

public class ModIdentifiersPacket extends FMLPacket
{
    private Map<String, Integer> modIds;
    
    public ModIdentifiersPacket() {
        super(Type.MOD_IDENTIFIERS);
        this.modIds = Maps.newHashMap();
    }
    
    @Override
    public byte[] generatePacket(final Object... data) {
        final ByteArrayDataOutput dat = ByteStreams.newDataOutput();
        final Collection<NetworkModHandler> networkMods = FMLNetworkHandler.instance().getNetworkIdMap().values();
        dat.writeInt(networkMods.size());
        for (final NetworkModHandler handler : networkMods) {
            dat.writeUTF(handler.getContainer().getModId());
            dat.writeInt(handler.getNetworkId());
        }
        return dat.toByteArray();
    }
    
    @Override
    public FMLPacket consumePacket(final byte[] data) {
        final ByteArrayDataInput dat = ByteStreams.newDataInput(data);
        for (int listSize = dat.readInt(), i = 0; i < listSize; ++i) {
            final String modId = dat.readUTF();
            final int networkId = dat.readInt();
            this.modIds.put(modId, networkId);
        }
        return this;
    }
    
    @Override
    public void execute(final cm network, final FMLNetworkHandler handler, final ez netHandler, final String userName) {
        for (final Map.Entry<String, Integer> idEntry : this.modIds.entrySet()) {
            handler.bindNetworkId(idEntry.getKey(), idEntry.getValue());
        }
    }
}



================================================
FILE: cpw/mods/fml/common/network/ModIdMapPacket.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

import com.google.common.collect.MapDifference;
import cpw.mods.fml.common.registry.ItemData;
import java.util.Set;
import java.io.IOException;
import cpw.mods.fml.common.FMLCommonHandler;
import cpw.mods.fml.common.registry.GameData;
import com.google.common.primitives.Bytes;
import com.google.common.io.ByteArrayDataInput;
import com.google.common.primitives.UnsignedBytes;
import com.google.common.io.ByteStreams;
import cpw.mods.fml.common.FMLLog;
import java.util.logging.Level;

public class ModIdMapPacket extends FMLPacket
{
    private byte[][] partials;
    
    public ModIdMapPacket() {
        super(Type.MOD_IDMAP);
    }
    
    @Override
    public byte[] generatePacket(final Object... data) {
        final cg completeList = (cg)data[0];
        final by wrap = new by();
        wrap.a("List", (cl)completeList);
        try {
            return ci.a(wrap);
        }
        catch (final Exception e) {
            FMLLog.log(Level.SEVERE, e, "A critical error writing the id map", new Object[0]);
            throw new FMLNetworkException(e);
        }
    }
    
    @Override
    public FMLPacket consumePacket(final byte[] data) {
        final ByteArrayDataInput bdi = ByteStreams.newDataInput(data);
        final int chunkIdx = UnsignedBytes.toInt(bdi.readByte());
        final int chunkTotal = UnsignedBytes.toInt(bdi.readByte());
        final int chunkLength = bdi.readInt();
        if (this.partials == null) {
            this.partials = new byte[chunkTotal][];
        }
        bdi.readFully(this.partials[chunkIdx] = new byte[chunkLength]);
        for (int i = 0; i < this.partials.length; ++i) {
            if (this.partials[i] == null) {
                return null;
            }
        }
        return this;
    }
    
    @Override
    public void execute(final cm network, final FMLNetworkHandler handler, final ez netHandler, final String userName) {
        final byte[] allData = Bytes.concat(this.partials);
        GameData.initializeServerGate(1);
        try {
            final by serverList = ci.a(allData);
            final cg list = serverList.m("List");
            final Set<ItemData> itemData = GameData.buildWorldItemData(list);
            GameData.validateWorldSave(itemData);
            final MapDifference<Integer, ItemData> serverDifference = GameData.gateWorldLoadingForValidation();
            if (serverDifference != null) {
                FMLCommonHandler.instance().disconnectIDMismatch(serverDifference, netHandler, network);
            }
        }
        catch (final IOException ex) {}
    }
}



================================================
FILE: cpw/mods/fml/common/network/ModListRequestPacket.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

import cpw.mods.fml.common.FMLCommonHandler;
import java.util.Map;
import cpw.mods.fml.common.Loader;
import com.google.common.collect.Maps;
import com.google.common.io.ByteArrayDataInput;
import cpw.mods.fml.common.FMLLog;
import com.google.common.collect.Lists;
import java.util.Iterator;
import java.util.Set;
import com.google.common.io.ByteArrayDataOutput;
import cpw.mods.fml.common.ModContainer;
import com.google.common.io.ByteStreams;
import java.util.List;

public class ModListRequestPacket extends FMLPacket
{
    private List<String> sentModList;
    private byte compatibilityLevel;
    
    public ModListRequestPacket() {
        super(Type.MOD_LIST_REQUEST);
    }
    
    @Override
    public byte[] generatePacket(final Object... data) {
        final ByteArrayDataOutput dat = ByteStreams.newDataOutput();
        final Set<ModContainer> activeMods = FMLNetworkHandler.instance().getNetworkModList();
        dat.writeInt(activeMods.size());
        for (final ModContainer mc : activeMods) {
            dat.writeUTF(mc.getModId());
        }
        dat.writeByte(FMLNetworkHandler.getCompatibilityLevel());
        return dat.toByteArray();
    }
    
    @Override
    public FMLPacket consumePacket(final byte[] data) {
        this.sentModList = Lists.newArrayList();
        final ByteArrayDataInput in = ByteStreams.newDataInput(data);
        for (int listSize = in.readInt(), i = 0; i < listSize; ++i) {
            this.sentModList.add(in.readUTF());
        }
        try {
            this.compatibilityLevel = in.readByte();
        }
        catch (final IllegalStateException e) {
            FMLLog.fine("No compatibility byte found - the server is too old", new Object[0]);
        }
        return this;
    }
    
    @Override
    public void execute(final cm mgr, final FMLNetworkHandler handler, final ez netHandler, final String userName) {
        final List<String> missingMods = Lists.newArrayList();
        final Map<String, String> modVersions = Maps.newHashMap();
        final Map<String, ModContainer> indexedModList = Maps.newHashMap((Map)Loader.instance().getIndexedModList());
        for (final String m : this.sentModList) {
            final ModContainer mc = indexedModList.get(m);
            if (mc == null) {
                missingMods.add(m);
            }
            else {
                indexedModList.remove(m);
                modVersions.put(m, mc.getVersion());
            }
        }
        if (indexedModList.size() > 0) {
            for (final Map.Entry<String, ModContainer> e : indexedModList.entrySet()) {
                if (e.getValue().isNetworkMod()) {
                    final NetworkModHandler missingHandler = FMLNetworkHandler.instance().findNetworkModHandler(e.getValue());
                    if (!missingHandler.requiresServerSide()) {
                        continue;
                    }
                    FMLLog.warning("The mod %s was not found on the server you connected to, but requested that the server side be present", e.getKey());
                }
            }
        }
        FMLLog.fine("The server has compatibility level %d", this.compatibilityLevel);
        FMLCommonHandler.instance().getSidedDelegate().setClientCompatibilityLevel(this.compatibilityLevel);
        mgr.a((ey)PacketDispatcher.getPacket("FML", FMLPacket.makePacket(Type.MOD_LIST_RESPONSE, modVersions, missingMods)));
    }
}



================================================
FILE: cpw/mods/fml/common/network/ModListResponsePacket.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

import cpw.mods.fml.common.registry.GameData;
import cpw.mods.fml.common.FMLLog;
import java.util.logging.Logger;
import cpw.mods.fml.common.ModContainer;
import cpw.mods.fml.common.Loader;
import com.google.common.io.ByteArrayDataInput;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import java.util.Iterator;
import com.google.common.io.ByteArrayDataOutput;
import com.google.common.io.ByteStreams;
import java.util.List;
import java.util.Map;

public class ModListResponsePacket extends FMLPacket
{
    private Map<String, String> modVersions;
    private List<String> missingMods;
    
    public ModListResponsePacket() {
        super(Type.MOD_LIST_RESPONSE);
    }
    
    @Override
    public byte[] generatePacket(final Object... data) {
        final Map<String, String> modVersions = (Map<String, String>)data[0];
        final List<String> missingMods = (List<String>)data[1];
        final ByteArrayDataOutput dat = ByteStreams.newDataOutput();
        dat.writeInt(modVersions.size());
        for (final Map.Entry<String, String> version : modVersions.entrySet()) {
            dat.writeUTF((String)version.getKey());
            dat.writeUTF((String)version.getValue());
        }
        dat.writeInt(missingMods.size());
        for (final String missing : missingMods) {
            dat.writeUTF(missing);
        }
        return dat.toByteArray();
    }
    
    @Override
    public FMLPacket consumePacket(final byte[] data) {
        final ByteArrayDataInput dat = ByteStreams.newDataInput(data);
        final int versionListSize = dat.readInt();
        this.modVersions = Maps.newHashMapWithExpectedSize(versionListSize);
        for (int i = 0; i < versionListSize; ++i) {
            final String modName = dat.readUTF();
            final String modVersion = dat.readUTF();
            this.modVersions.put(modName, modVersion);
        }
        final int missingModSize = dat.readInt();
        this.missingMods = Lists.newArrayListWithExpectedSize(missingModSize);
        for (int j = 0; j < missingModSize; ++j) {
            this.missingMods.add(dat.readUTF());
        }
        return this;
    }
    
    @Override
    public void execute(final cm network, final FMLNetworkHandler handler, final ez netHandler, final String userName) {
        final Map<String, ModContainer> indexedModList = Maps.newHashMap((Map)Loader.instance().getIndexedModList());
        final List<String> missingClientMods = Lists.newArrayList();
        final List<String> versionIncorrectMods = Lists.newArrayList();
        for (final String m : this.missingMods) {
            final ModContainer mc = indexedModList.get(m);
            final NetworkModHandler networkMod = handler.findNetworkModHandler(mc);
            if (networkMod.requiresClientSide()) {
                missingClientMods.add(m);
            }
        }
        for (final Map.Entry<String, String> modVersion : this.modVersions.entrySet()) {
            final ModContainer mc = indexedModList.get(modVersion.getKey());
            final NetworkModHandler networkMod = handler.findNetworkModHandler(mc);
            if (!networkMod.acceptVersion(modVersion.getValue())) {
                versionIncorrectMods.add(modVersion.getKey());
            }
        }
        final ea pkt = new ea();
        pkt.a = "FML";
        if (missingClientMods.size() > 0 || versionIncorrectMods.size() > 0) {
            pkt.c = FMLPacket.makePacket(Type.MOD_MISSING, missingClientMods, versionIncorrectMods);
            Logger.getLogger("Minecraft").info(String.format("User %s connection failed: missing %s, bad versions %s", userName, missingClientMods, versionIncorrectMods));
            FMLLog.info("User %s connection failed: missing %s, bad versions %s", userName, missingClientMods, versionIncorrectMods);
            FMLNetworkHandler.setHandlerState((jy)netHandler, -2);
            pkt.b = pkt.c.length;
            network.a((ey)pkt);
        }
        else {
            pkt.c = FMLPacket.makePacket(Type.MOD_IDENTIFIERS, netHandler);
            Logger.getLogger("Minecraft").info(String.format("User %s connecting with mods %s", userName, this.modVersions.keySet()));
            FMLLog.info("User %s connecting with mods %s", userName, this.modVersions.keySet());
            pkt.b = pkt.c.length;
            network.a((ey)pkt);
            final cg itemList = new cg();
            GameData.writeItemData(itemList);
            final byte[][] registryPackets = FMLPacket.makePacketSet(Type.MOD_IDMAP, itemList);
            for (int i = 0; i < registryPackets.length; ++i) {
                network.a((ey)PacketDispatcher.getPacket("FML", registryPackets[i]));
            }
        }
        jy.a((jy)netHandler, true);
    }
}



================================================
FILE: cpw/mods/fml/common/network/ModMissingPacket.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

import cpw.mods.fml.common.versioning.DefaultArtifactVersion;
import cpw.mods.fml.common.versioning.VersionRange;
import com.google.common.collect.ImmutableList;
import cpw.mods.fml.common.versioning.ArtifactVersion;
import cpw.mods.fml.common.FMLCommonHandler;
import com.google.common.io.ByteArrayDataInput;
import com.google.common.collect.Lists;
import java.util.Iterator;
import com.google.common.io.ByteArrayDataOutput;
import cpw.mods.fml.common.Loader;
import cpw.mods.fml.common.ModContainer;
import com.google.common.io.ByteStreams;
import java.util.List;

public class ModMissingPacket extends FMLPacket
{
    private List<ModData> missing;
    private List<ModData> badVersion;
    
    public ModMissingPacket() {
        super(Type.MOD_MISSING);
    }
    
    @Override
    public byte[] generatePacket(final Object... data) {
        final ByteArrayDataOutput dat = ByteStreams.newDataOutput();
        final List<String> missing = (List<String>)data[0];
        final List<String> badVersion = (List<String>)data[1];
        dat.writeInt(missing.size());
        for (final String missed : missing) {
            final ModContainer mc = Loader.instance().getIndexedModList().get(missed);
            dat.writeUTF(missed);
            dat.writeUTF(mc.getVersion());
        }
        dat.writeInt(badVersion.size());
        for (final String bad : badVersion) {
            final ModContainer mc = Loader.instance().getIndexedModList().get(bad);
            dat.writeUTF(bad);
            dat.writeUTF(mc.getVersion());
        }
        return dat.toByteArray();
    }
    
    @Override
    public FMLPacket consumePacket(final byte[] data) {
        final ByteArrayDataInput dat = ByteStreams.newDataInput(data);
        final int missingLen = dat.readInt();
        this.missing = Lists.newArrayListWithCapacity(missingLen);
        for (int i = 0; i < missingLen; ++i) {
            final ModData md = new ModData();
            md.modId = dat.readUTF();
            md.modVersion = dat.readUTF();
            this.missing.add(md);
        }
        final int badVerLength = dat.readInt();
        this.badVersion = Lists.newArrayListWithCapacity(badVerLength);
        for (int j = 0; j < badVerLength; ++j) {
            final ModData md2 = new ModData();
            md2.modId = dat.readUTF();
            md2.modVersion = dat.readUTF();
            this.badVersion.add(md2);
        }
        return this;
    }
    
    @Override
    public void execute(final cm network, final FMLNetworkHandler handler, final ez netHandler, final String userName) {
        FMLCommonHandler.instance().getSidedDelegate().displayMissingMods(this);
    }
    
    public List<ArtifactVersion> getModList() {
        final ImmutableList.Builder<ArtifactVersion> builder = (ImmutableList.Builder<ArtifactVersion>)ImmutableList.builder();
        for (final ModData md : this.missing) {
            builder.add((Object)new DefaultArtifactVersion(md.modId, VersionRange.createFromVersion(md.modVersion, null)));
        }
        for (final ModData md : this.badVersion) {
            builder.add((Object)new DefaultArtifactVersion(md.modId, VersionRange.createFromVersion(md.modVersion, null)));
        }
        return (List<ArtifactVersion>)builder.build();
    }
    
    private static class ModData
    {
        String modId;
        String modVersion;
    }
}



================================================
FILE: cpw/mods/fml/common/network/NetworkMod.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Retention;

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE })
public @interface NetworkMod {
    boolean clientSideRequired() default false;
    
    boolean serverSideRequired() default false;
    
    String[] channels() default {};
    
    String versionBounds() default "";
    
    Class<? extends IPacketHandler> packetHandler() default NULL.class;
    
    Class<? extends ITinyPacketHandler> tinyPacketHandler() default NULL.class;
    
    Class<? extends IConnectionHandler> connectionHandler() default NULL.class;
    
    SidedPacketHandler clientPacketHandlerSpec() default @SidedPacketHandler(channels = {}, packetHandler = NULL.class);
    
    SidedPacketHandler serverPacketHandlerSpec() default @SidedPacketHandler(channels = {}, packetHandler = NULL.class);
    
    public @interface SidedPacketHandler {
        String[] channels();
        
        Class<? extends IPacketHandler> packetHandler();
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.METHOD })
    public @interface VersionCheckHandler {
    }
    
    public interface NULL extends IPacketHandler, IConnectionHandler, ITinyPacketHandler
    {
    }
}



================================================
FILE: cpw/mods/fml/common/network/NetworkModHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

import cpw.mods.fml.common.versioning.ArtifactVersion;
import cpw.mods.fml.common.versioning.DefaultArtifactVersion;
import cpw.mods.fml.common.FMLCommonHandler;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.common.versioning.InvalidVersionSpecificationException;
import com.google.common.base.Strings;
import java.util.Iterator;
import java.util.Set;
import cpw.mods.fml.common.FMLLog;
import java.util.logging.Level;
import java.lang.annotation.Annotation;
import cpw.mods.fml.common.discovery.ASMDataTable;
import cpw.mods.fml.common.versioning.VersionRange;
import java.lang.reflect.Method;
import cpw.mods.fml.common.ModContainer;

public class NetworkModHandler
{
    private static Object connectionHandlerDefaultValue;
    private static Object packetHandlerDefaultValue;
    private static Object clientHandlerDefaultValue;
    private static Object serverHandlerDefaultValue;
    private static Object tinyPacketHandlerDefaultValue;
    private static int assignedIds;
    private int localId;
    private int networkId;
    private ModContainer container;
    private NetworkMod mod;
    private Method checkHandler;
    private VersionRange acceptableRange;
    private ITinyPacketHandler tinyPacketHandler;
    
    public NetworkModHandler(final ModContainer container, final NetworkMod modAnnotation) {
        this.container = container;
        this.mod = modAnnotation;
        this.localId = NetworkModHandler.assignedIds++;
        this.networkId = this.localId;
        if (yc.bf.cv == NetworkModHandler.assignedIds) {
            ++NetworkModHandler.assignedIds;
        }
    }
    
    public NetworkModHandler(final ModContainer container, final Class<?> networkModClass, final ASMDataTable table) {
        this(container, networkModClass.getAnnotation(NetworkMod.class));
        if (this.mod == null) {
            return;
        }
        final Set<ASMDataTable.ASMData> versionCheckHandlers = table.getAnnotationsFor(container).get((Object)NetworkMod.VersionCheckHandler.class.getName());
        String versionCheckHandlerMethod = null;
        for (final ASMDataTable.ASMData vch : versionCheckHandlers) {
            if (vch.getClassName().equals(networkModClass.getName())) {
                versionCheckHandlerMethod = vch.getObjectName();
                versionCheckHandlerMethod = versionCheckHandlerMethod.substring(0, versionCheckHandlerMethod.indexOf(40));
                break;
            }
        }
        if (versionCheckHandlerMethod != null) {
            try {
                final Method checkHandlerMethod = networkModClass.getDeclaredMethod(versionCheckHandlerMethod, String.class);
                if (checkHandlerMethod.isAnnotationPresent(NetworkMod.VersionCheckHandler.class)) {
                    this.checkHandler = checkHandlerMethod;
                }
            }
            catch (final Exception e) {
                FMLLog.log(Level.WARNING, e, "The declared version check handler method %s on network mod id %s is not accessible", versionCheckHandlerMethod, container.getModId());
            }
        }
        this.configureNetworkMod(container);
    }
    
    protected void configureNetworkMod(final ModContainer container) {
        if (this.checkHandler == null) {
            final String versionBounds = this.mod.versionBounds();
            if (!Strings.isNullOrEmpty(versionBounds)) {
                try {
                    this.acceptableRange = VersionRange.createFromVersionSpec(versionBounds);
                }
                catch (final InvalidVersionSpecificationException e) {
                    FMLLog.log(Level.WARNING, e, "Invalid bounded range %s specified for network mod id %s", versionBounds, container.getModId());
                }
            }
        }
        FMLLog.finest("Testing mod %s to verify it accepts its own version in a remote connection", container.getModId());
        final boolean acceptsSelf = this.acceptVersion(container.getVersion());
        if (!acceptsSelf) {
            FMLLog.severe("The mod %s appears to reject its own version number (%s) in its version handling. This is likely a severe bug in the mod!", container.getModId(), container.getVersion());
        }
        else {
            FMLLog.finest("The mod %s accepts its own version (%s)", container.getModId(), container.getVersion());
        }
        this.tryCreatingPacketHandler(container, this.mod.packetHandler(), this.mod.channels(), null);
        if (FMLCommonHandler.instance().getSide().isClient() && this.mod.clientPacketHandlerSpec() != this.getClientHandlerSpecDefaultValue()) {
            this.tryCreatingPacketHandler(container, this.mod.clientPacketHandlerSpec().packetHandler(), this.mod.clientPacketHandlerSpec().channels(), Side.CLIENT);
        }
        if (this.mod.serverPacketHandlerSpec() != this.getServerHandlerSpecDefaultValue()) {
            this.tryCreatingPacketHandler(container, this.mod.serverPacketHandlerSpec().packetHandler(), this.mod.serverPacketHandlerSpec().channels(), Side.SERVER);
        }
        if (this.mod.connectionHandler() != this.getConnectionHandlerDefaultValue()) {
            IConnectionHandler instance;
            try {
                instance = (IConnectionHandler)this.mod.connectionHandler().newInstance();
            }
            catch (final Exception e2) {
                FMLLog.log(Level.SEVERE, e2, "Unable to create connection handler instance %s", this.mod.connectionHandler().getName());
                throw new FMLNetworkException(e2);
            }
            NetworkRegistry.instance().registerConnectionHandler(instance);
        }
        if (this.mod.tinyPacketHandler() != this.getTinyPacketHandlerDefaultValue()) {
            try {
                this.tinyPacketHandler = (ITinyPacketHandler)this.mod.tinyPacketHandler().newInstance();
            }
            catch (final Exception e3) {
                FMLLog.log(Level.SEVERE, e3, "Unable to create tiny packet handler instance %s", this.mod.tinyPacketHandler().getName());
                throw new FMLNetworkException(e3);
            }
        }
    }
    
    private void tryCreatingPacketHandler(final ModContainer container, final Class<? extends IPacketHandler> clazz, final String[] channels, final Side side) {
        if (side != null && side.isClient() && !FMLCommonHandler.instance().getSide().isClient()) {
            return;
        }
        if (clazz != this.getPacketHandlerDefaultValue()) {
            if (channels.length == 0) {
                FMLLog.log(Level.WARNING, "The mod id %s attempted to register a packet handler without specifying channels for it", container.getModId());
            }
            else {
                IPacketHandler instance;
                try {
                    instance = (IPacketHandler)clazz.newInstance();
                }
                catch (final Exception e) {
                    FMLLog.log(Level.SEVERE, e, "Unable to create a packet handler instance %s for mod %s", clazz.getName(), container.getModId());
                    throw new FMLNetworkException(e);
                }
                for (final String channel : channels) {
                    NetworkRegistry.instance().registerChannel(instance, channel, side);
                }
            }
        }
        else if (channels.length > 0) {
            FMLLog.warning("The mod id %s attempted to register channels without specifying a packet handler", container.getModId());
        }
    }
    
    private Object getConnectionHandlerDefaultValue() {
        try {
            if (NetworkModHandler.connectionHandlerDefaultValue == null) {
                NetworkModHandler.connectionHandlerDefaultValue = NetworkMod.class.getMethod("connectionHandler", (Class<?>[])new Class[0]).getDefaultValue();
            }
            return NetworkModHandler.connectionHandlerDefaultValue;
        }
        catch (final NoSuchMethodException e) {
            throw new RuntimeException("Derp?", e);
        }
    }
    
    private Object getPacketHandlerDefaultValue() {
        try {
            if (NetworkModHandler.packetHandlerDefaultValue == null) {
                NetworkModHandler.packetHandlerDefaultValue = NetworkMod.class.getMethod("packetHandler", (Class<?>[])new Class[0]).getDefaultValue();
            }
            return NetworkModHandler.packetHandlerDefaultValue;
        }
        catch (final NoSuchMethodException e) {
            throw new RuntimeException("Derp?", e);
        }
    }
    
    private Object getTinyPacketHandlerDefaultValue() {
        try {
            if (NetworkModHandler.tinyPacketHandlerDefaultValue == null) {
                NetworkModHandler.tinyPacketHandlerDefaultValue = NetworkMod.class.getMethod("tinyPacketHandler", (Class<?>[])new Class[0]).getDefaultValue();
            }
            return NetworkModHandler.tinyPacketHandlerDefaultValue;
        }
        catch (final NoSuchMethodException e) {
            throw new RuntimeException("Derp?", e);
        }
    }
    
    private Object getClientHandlerSpecDefaultValue() {
        try {
            if (NetworkModHandler.clientHandlerDefaultValue == null) {
                NetworkModHandler.clientHandlerDefaultValue = NetworkMod.class.getMethod("clientPacketHandlerSpec", (Class<?>[])new Class[0]).getDefaultValue();
            }
            return NetworkModHandler.clientHandlerDefaultValue;
        }
        catch (final NoSuchMethodException e) {
            throw new RuntimeException("Derp?", e);
        }
    }
    
    private Object getServerHandlerSpecDefaultValue() {
        try {
            if (NetworkModHandler.serverHandlerDefaultValue == null) {
                NetworkModHandler.serverHandlerDefaultValue = NetworkMod.class.getMethod("serverPacketHandlerSpec", (Class<?>[])new Class[0]).getDefaultValue();
            }
            return NetworkModHandler.serverHandlerDefaultValue;
        }
        catch (final NoSuchMethodException e) {
            throw new RuntimeException("Derp?", e);
        }
    }
    
    public boolean requiresClientSide() {
        return this.mod.clientSideRequired();
    }
    
    public boolean requiresServerSide() {
        return this.mod.serverSideRequired();
    }
    
    public boolean acceptVersion(final String version) {
        if (this.checkHandler != null) {
            try {
                return (boolean)this.checkHandler.invoke(this.container.getMod(), version);
            }
            catch (final Exception e) {
                FMLLog.log(Level.WARNING, e, "There was a problem invoking the checkhandler method %s for network mod id %s", this.checkHandler.getName(), this.container.getModId());
                return false;
            }
        }
        if (this.acceptableRange != null) {
            return this.acceptableRange.containsVersion(new DefaultArtifactVersion(version));
        }
        return this.container.getVersion().equals(version);
    }
    
    public int getLocalId() {
        return this.localId;
    }
    
    public int getNetworkId() {
        return this.networkId;
    }
    
    public ModContainer getContainer() {
        return this.container;
    }
    
    public NetworkMod getMod() {
        return this.mod;
    }
    
    public boolean isNetworkMod() {
        return this.mod != null;
    }
    
    public void setNetworkId(final int value) {
        this.networkId = value;
    }
    
    public boolean hasTinyPacketHandler() {
        return this.tinyPacketHandler != null;
    }
    
    public ITinyPacketHandler getTinyPacketHandler() {
        return this.tinyPacketHandler;
    }
    
    static {
        NetworkModHandler.assignedIds = 1;
    }
}



================================================
FILE: cpw/mods/fml/common/network/NetworkRegistry.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

import java.util.logging.Level;
import cpw.mods.fml.common.Loader;
import cpw.mods.fml.common.FMLCommonHandler;
import com.google.common.base.Splitter;
import net.minecraft.server.MinecraftServer;
import java.util.Iterator;
import cpw.mods.fml.common.FMLLog;
import com.google.common.base.Strings;
import com.google.common.base.Charsets;
import com.google.common.collect.Iterables;
import java.util.Arrays;
import com.google.common.base.Joiner;
import cpw.mods.fml.relauncher.Side;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.google.common.collect.ArrayListMultimap;
import java.util.List;
import cpw.mods.fml.common.ModContainer;
import java.util.Map;
import java.util.Set;
import com.google.common.collect.Multimap;

public class NetworkRegistry
{
    private static final NetworkRegistry INSTANCE;
    private Multimap<Player, String> activeChannels;
    private Multimap<String, IPacketHandler> universalPacketHandlers;
    private Multimap<String, IPacketHandler> clientPacketHandlers;
    private Multimap<String, IPacketHandler> serverPacketHandlers;
    private Set<IConnectionHandler> connectionHandlers;
    private Map<ModContainer, IGuiHandler> serverGuiHandlers;
    private Map<ModContainer, IGuiHandler> clientGuiHandlers;
    private List<IChatListener> chatListeners;
    
    public NetworkRegistry() {
        this.activeChannels = (Multimap<Player, String>)ArrayListMultimap.create();
        this.universalPacketHandlers = (Multimap<String, IPacketHandler>)ArrayListMultimap.create();
        this.clientPacketHandlers = (Multimap<String, IPacketHandler>)ArrayListMultimap.create();
        this.serverPacketHandlers = (Multimap<String, IPacketHandler>)ArrayListMultimap.create();
        this.connectionHandlers = Sets.newLinkedHashSet();
        this.serverGuiHandlers = Maps.newHashMap();
        this.clientGuiHandlers = Maps.newHashMap();
        this.chatListeners = Lists.newArrayList();
    }
    
    public static NetworkRegistry instance() {
        return NetworkRegistry.INSTANCE;
    }
    
    byte[] getPacketRegistry(final Side side) {
        return Joiner.on('\0').join(Iterables.concat((Iterable)Arrays.asList("FML"), (Iterable)this.universalPacketHandlers.keySet(), (Iterable)(side.isClient() ? this.clientPacketHandlers.keySet() : this.serverPacketHandlers.keySet()))).getBytes(Charsets.UTF_8);
    }
    
    public boolean isChannelActive(final String channel, final Player player) {
        return this.activeChannels.containsEntry((Object)player, (Object)channel);
    }
    
    public void registerChannel(final IPacketHandler handler, final String channelName) {
        if (Strings.isNullOrEmpty(channelName) || (channelName != null && channelName.length() > 16)) {
            FMLLog.severe("Invalid channel name '%s' : %s", channelName, Strings.isNullOrEmpty(channelName) ? "Channel name is empty" : "Channel name is too long (16 chars is maximum)");
            throw new RuntimeException("Channel name is invalid");
        }
        this.universalPacketHandlers.put((Object)channelName, (Object)handler);
    }
    
    public void registerChannel(final IPacketHandler handler, final String channelName, final Side side) {
        if (side == null) {
            this.registerChannel(handler, channelName);
            return;
        }
        if (Strings.isNullOrEmpty(channelName) || (channelName != null && channelName.length() > 16)) {
            FMLLog.severe("Invalid channel name '%s' : %s", channelName, Strings.isNullOrEmpty(channelName) ? "Channel name is empty" : "Channel name is too long (16 chars is maximum)");
            throw new RuntimeException("Channel name is invalid");
        }
        if (side.isClient()) {
            this.clientPacketHandlers.put((Object)channelName, (Object)handler);
        }
        else {
            this.serverPacketHandlers.put((Object)channelName, (Object)handler);
        }
    }
    
    void activateChannel(final Player player, final String channel) {
        this.activeChannels.put((Object)player, (Object)channel);
    }
    
    void deactivateChannel(final Player player, final String channel) {
        this.activeChannels.remove((Object)player, (Object)channel);
    }
    
    public void registerConnectionHandler(final IConnectionHandler handler) {
        this.connectionHandlers.add(handler);
    }
    
    public void registerChatListener(final IChatListener listener) {
        this.chatListeners.add(listener);
    }
    
    void playerLoggedIn(final jv player, final ka netHandler, final cm manager) {
        this.generateChannelRegistration((uf)player, (ez)netHandler, manager);
        for (final IConnectionHandler handler : this.connectionHandlers) {
            handler.playerLoggedIn((Player)player, (ez)netHandler, manager);
        }
    }
    
    String connectionReceived(final jy netHandler, final cm manager) {
        for (final IConnectionHandler handler : this.connectionHandlers) {
            final String kick = handler.connectionReceived(netHandler, manager);
            if (!Strings.isNullOrEmpty(kick)) {
                return kick;
            }
        }
        return null;
    }
    
    void connectionOpened(final ez netClientHandler, final String server, final int port, final cm networkManager) {
        for (final IConnectionHandler handler : this.connectionHandlers) {
            handler.connectionOpened(netClientHandler, server, port, networkManager);
        }
    }
    
    void connectionOpened(final ez netClientHandler, final MinecraftServer server, final cm networkManager) {
        for (final IConnectionHandler handler : this.connectionHandlers) {
            handler.connectionOpened(netClientHandler, server, networkManager);
        }
    }
    
    void clientLoggedIn(final ez clientHandler, final cm manager, final ep login) {
        this.generateChannelRegistration(clientHandler.getPlayer(), clientHandler, manager);
        for (final IConnectionHandler handler : this.connectionHandlers) {
            handler.clientLoggedIn(clientHandler, manager, login);
        }
    }
    
    void connectionClosed(final cm manager, final uf player) {
        for (final IConnectionHandler handler : this.connectionHandlers) {
            handler.connectionClosed(manager);
        }
        this.activeChannels.removeAll((Object)player);
    }
    
    void generateChannelRegistration(final uf player, final ez netHandler, final cm manager) {
        final ea pkt = new ea();
        pkt.a = "REGISTER";
        pkt.c = this.getPacketRegistry((player instanceof jv) ? Side.SERVER : Side.CLIENT);
        pkt.b = pkt.c.length;
        manager.a((ey)pkt);
    }
    
    void handleCustomPacket(final ea packet, final cm network, final ez handler) {
        if ("REGISTER".equals(packet.a)) {
            this.handleRegistrationPacket(packet, (Player)handler.getPlayer());
        }
        else if ("UNREGISTER".equals(packet.a)) {
            this.handleUnregistrationPacket(packet, (Player)handler.getPlayer());
        }
        else {
            this.handlePacket(packet, network, (Player)handler.getPlayer());
        }
    }
    
    private void handlePacket(final ea packet, final cm network, final Player player) {
        final String channel = packet.a;
        for (final IPacketHandler handler : Iterables.concat((Iterable)this.universalPacketHandlers.get((Object)channel), (Iterable)((player instanceof jv) ? this.serverPacketHandlers.get((Object)channel) : this.clientPacketHandlers.get((Object)channel)))) {
            handler.onPacketData(network, packet, player);
        }
    }
    
    private void handleRegistrationPacket(final ea packet, final Player player) {
        final List<String> channels = this.extractChannelList(packet);
        for (final String channel : channels) {
            this.activateChannel(player, channel);
        }
    }
    
    private void handleUnregistrationPacket(final ea packet, final Player player) {
        final List<String> channels = this.extractChannelList(packet);
        for (final String channel : channels) {
            this.deactivateChannel(player, channel);
        }
    }
    
    private List<String> extractChannelList(final ea packet) {
        final String request = new String(packet.c, Charsets.UTF_8);
        final List<String> channels = Lists.newArrayList(Splitter.on('\0').split((CharSequence)request));
        return channels;
    }
    
    public void registerGuiHandler(final Object mod, final IGuiHandler handler) {
        ModContainer mc = FMLCommonHandler.instance().findContainerFor(mod);
        if (mc == null) {
            mc = Loader.instance().activeModContainer();
            FMLLog.log(Level.WARNING, "Mod %s attempted to register a gui network handler during a construction phase", mc.getModId());
        }
        final NetworkModHandler nmh = FMLNetworkHandler.instance().findNetworkModHandler(mc);
        if (nmh == null) {
            FMLLog.log(Level.FINE, "The mod %s needs to be a @NetworkMod to register a Networked Gui Handler", mc.getModId());
        }
        else {
            this.serverGuiHandlers.put(mc, handler);
        }
        this.clientGuiHandlers.put(mc, handler);
    }
    
    void openRemoteGui(final ModContainer mc, final jv player, final int modGuiId, final abw world, final int x, final int y, final int z) {
        final IGuiHandler handler = this.serverGuiHandlers.get(mc);
        final NetworkModHandler nmh = FMLNetworkHandler.instance().findNetworkModHandler(mc);
        if (handler != null && nmh != null) {
            final uy container = (uy)handler.getServerGuiElement(modGuiId, (uf)player, world, x, y, z);
            if (container != null) {
                player.bN();
                player.k();
                final int windowId = player.bY;
                final ea pkt = new ea();
                pkt.a = "FML";
                pkt.c = FMLPacket.makePacket(FMLPacket.Type.GUIOPEN, windowId, nmh.getNetworkId(), modGuiId, x, y, z);
                pkt.b = pkt.c.length;
                player.a.b((ey)pkt);
                player.bp = container;
                player.bp.d = windowId;
                player.bp.a((vi)player);
            }
        }
    }
    
    void openLocalGui(final ModContainer mc, final uf player, final int modGuiId, final abw world, final int x, final int y, final int z) {
        final IGuiHandler handler = this.clientGuiHandlers.get(mc);
        FMLCommonHandler.instance().showGuiScreen(handler.getClientGuiElement(modGuiId, player, world, x, y, z));
    }
    
    public dm handleChat(final ez handler, dm chat) {
        Side s = Side.CLIENT;
        if (handler instanceof ka) {
            s = Side.SERVER;
        }
        for (final IChatListener listener : this.chatListeners) {
            chat = (s.isClient() ? listener.clientChat(handler, chat) : listener.serverChat(handler, chat));
        }
        return chat;
    }
    
    public void handleTinyPacket(final ez handler, final dr mapData) {
        final NetworkModHandler nmh = FMLNetworkHandler.instance().findNetworkModHandler((int)mapData.a);
        if (nmh == null) {
            FMLLog.info("Received a tiny packet for network id %d that is not recognised here", mapData.a);
            return;
        }
        if (nmh.hasTinyPacketHandler()) {
            nmh.getTinyPacketHandler().handle(handler, mapData);
        }
        else {
            FMLLog.info("Received a tiny packet for a network mod that does not accept tiny packets %s", nmh.getContainer().getModId());
        }
    }
    
    static {
        INSTANCE = new NetworkRegistry();
    }
}



================================================
FILE: cpw/mods/fml/common/network/OpenGuiPacket.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

import com.google.common.io.ByteArrayDataInput;
import com.google.common.io.ByteArrayDataOutput;
import com.google.common.io.ByteStreams;

public class OpenGuiPacket extends FMLPacket
{
    private int windowId;
    private int networkId;
    private int modGuiId;
    private int x;
    private int y;
    private int z;
    
    public OpenGuiPacket() {
        super(Type.GUIOPEN);
    }
    
    @Override
    public byte[] generatePacket(final Object... data) {
        final ByteArrayDataOutput dat = ByteStreams.newDataOutput();
        dat.writeInt((int)data[0]);
        dat.writeInt((int)data[1]);
        dat.writeInt((int)data[2]);
        dat.writeInt((int)data[3]);
        dat.writeInt((int)data[4]);
        dat.writeInt((int)data[5]);
        return dat.toByteArray();
    }
    
    @Override
    public FMLPacket consumePacket(final byte[] data) {
        final ByteArrayDataInput dat = ByteStreams.newDataInput(data);
        this.windowId = dat.readInt();
        this.networkId = dat.readInt();
        this.modGuiId = dat.readInt();
        this.x = dat.readInt();
        this.y = dat.readInt();
        this.z = dat.readInt();
        return this;
    }
    
    @Override
    public void execute(final cm network, final FMLNetworkHandler handler, final ez netHandler, final String userName) {
        final uf player = netHandler.getPlayer();
        player.openGui((Object)this.networkId, this.modGuiId, player.q, this.x, this.y, this.z);
        player.bp.d = this.windowId;
    }
}



================================================
FILE: cpw/mods/fml/common/network/PacketDispatcher.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

import net.minecraft.server.MinecraftServer;
import cpw.mods.fml.common.FMLLog;
import cpw.mods.fml.common.FMLCommonHandler;

public class PacketDispatcher
{
    public static ea getPacket(final String type, final byte[] data) {
        return new ea(type, data);
    }
    
    public static void sendPacketToServer(final ey packet) {
        FMLCommonHandler.instance().getSidedDelegate().sendPacket(packet);
    }
    
    public static void sendPacketToPlayer(final ey packet, final Player player) {
        if (player instanceof jv) {
            ((jv)player).a.b(packet);
        }
    }
    
    public static void sendPacketToAllAround(final double X, final double Y, final double Z, final double range, final int dimensionId, final ey packet) {
        final MinecraftServer server = FMLCommonHandler.instance().getMinecraftServerInstance();
        if (server != null) {
            server.af().a(X, Y, Z, range, dimensionId, packet);
        }
        else {
            FMLLog.fine("Attempt to send packet to all around without a server instance available", new Object[0]);
        }
    }
    
    public static void sendPacketToAllInDimension(final ey packet, final int dimId) {
        final MinecraftServer server = FMLCommonHandler.instance().getMinecraftServerInstance();
        if (server != null) {
            server.af().a(packet, dimId);
        }
        else {
            FMLLog.fine("Attempt to send packet to all in dimension without a server instance available", new Object[0]);
        }
    }
    
    public static void sendPacketToAllPlayers(final ey packet) {
        final MinecraftServer server = FMLCommonHandler.instance().getMinecraftServerInstance();
        if (server != null) {
            server.af().a(packet);
        }
        else {
            FMLLog.fine("Attempt to send packet to all in dimension without a server instance available", new Object[0]);
        }
    }
    
    public static dr getTinyPacket(final Object mod, final short tag, final byte[] data) {
        final NetworkModHandler nmh = FMLNetworkHandler.instance().findNetworkModHandler(mod);
        return new dr((short)nmh.getNetworkId(), tag, data);
    }
}



================================================
FILE: cpw/mods/fml/common/network/Player.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.network;

public interface Player
{
}



================================================
FILE: cpw/mods/fml/common/patcher/ClassPatch.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.patcher;

public class ClassPatch
{
    public final String name;
    public final String sourceClassName;
    public final String targetClassName;
    public final boolean existsAtTarget;
    public final byte[] patch;
    public final int inputChecksum;
    
    public ClassPatch(final String name, final String sourceClassName, final String targetClassName, final boolean existsAtTarget, final int inputChecksum, final byte[] patch) {
        this.name = name;
        this.sourceClassName = sourceClassName;
        this.targetClassName = targetClassName;
        this.existsAtTarget = existsAtTarget;
        this.inputChecksum = inputChecksum;
        this.patch = patch;
    }
    
    @Override
    public String toString() {
        return String.format("%s : %s => %s (%b) size %d", this.name, this.sourceClassName, this.targetClassName, this.existsAtTarget, this.patch.length);
    }
}



================================================
FILE: cpw/mods/fml/common/patcher/ClassPatchManager.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.patcher;

import com.google.common.io.ByteArrayDataInput;
import com.google.common.io.ByteStreams;
import java.util.jar.JarEntry;
import com.google.common.base.Joiner;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.base.Throwables;
import java.util.jar.JarInputStream;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.util.jar.Pack200;
import java.io.OutputStream;
import java.util.jar.JarOutputStream;
import java.io.ByteArrayOutputStream;
import LZMA.LzmaInputStream;
import java.util.regex.Pattern;
import java.util.Locale;
import cpw.mods.fml.relauncher.Side;
import java.util.Iterator;
import java.util.List;
import java.util.logging.Level;
import com.google.common.hash.Hashing;
import java.io.IOException;
import net.minecraft.launchwrapper.LaunchClassLoader;
import cpw.mods.fml.relauncher.FMLRelaunchLog;
import com.google.common.io.Files;
import com.google.common.collect.Maps;
import java.io.File;
import java.util.Map;
import com.google.common.collect.ListMultimap;
import cpw.mods.fml.repackage.com.nothome.delta.GDiffPatcher;

public class ClassPatchManager
{
    public static final ClassPatchManager INSTANCE;
    public static final boolean dumpPatched;
    private GDiffPatcher patcher;
    private ListMultimap<String, ClassPatch> patches;
    private Map<String, byte[]> patchedClasses;
    private File tempDir;
    
    private ClassPatchManager() {
        this.patcher = new GDiffPatcher();
        this.patchedClasses = Maps.newHashMap();
        if (ClassPatchManager.dumpPatched) {
            this.tempDir = Files.createTempDir();
            FMLRelaunchLog.info("Dumping patched classes to %s", this.tempDir.getAbsolutePath());
        }
    }
    
    public byte[] getPatchedResource(final String name, final String mappedName, final LaunchClassLoader loader) throws IOException {
        final byte[] rawClassBytes = loader.getClassBytes(name);
        return this.applyPatch(name, mappedName, rawClassBytes);
    }
    
    public byte[] applyPatch(final String name, final String mappedName, byte[] inputData) {
        if (this.patches == null) {
            return inputData;
        }
        if (this.patchedClasses.containsKey(name)) {
            return this.patchedClasses.get(name);
        }
        final List<ClassPatch> list = this.patches.get((Object)name);
        if (list.isEmpty()) {
            return inputData;
        }
        boolean ignoredError = false;
        FMLRelaunchLog.fine("Runtime patching class %s (input size %d), found %d patch%s", mappedName, (inputData == null) ? 0 : inputData.length, list.size(), (list.size() != 1) ? "es" : "");
        for (final ClassPatch patch : list) {
            if (!patch.targetClassName.equals(mappedName) && !patch.sourceClassName.equals(name)) {
                FMLRelaunchLog.warning("Binary patch found %s for wrong class %s", patch.targetClassName, mappedName);
            }
            if (!patch.existsAtTarget && (inputData == null || inputData.length == 0)) {
                inputData = new byte[0];
            }
            else if (!patch.existsAtTarget) {
                FMLRelaunchLog.warning("Patcher expecting empty class data file for %s, but received non-empty", patch.targetClassName);
            }
            else {
                final int inputChecksum = Hashing.adler32().hashBytes(inputData).asInt();
                if (patch.inputChecksum != inputChecksum) {
                    FMLRelaunchLog.severe("There is a binary discrepency between the expected input class %s (%s) and the actual class. Checksum on disk is %x, in patch %x. Things are probably about to go very wrong. Did you put something into the jar file?", mappedName, name, inputChecksum, patch.inputChecksum);
                    if (Boolean.parseBoolean(System.getProperty("fml.ignorePatchDiscrepancies", "false"))) {
                        FMLRelaunchLog.severe("FML is going to ignore this error, note that the patch will not be applied, and there is likely to be a malfunctioning behaviour, including not running at all", new Object[0]);
                        ignoredError = true;
                        continue;
                    }
                    FMLRelaunchLog.severe("The game is going to exit, because this is a critical error, and it is very improbable that the modded game will work, please obtain clean jar files.", new Object[0]);
                    System.exit(1);
                }
            }
            synchronized (this.patcher) {
                try {
                    inputData = this.patcher.patch(inputData, patch.patch);
                }
                catch (final IOException e) {
                    FMLRelaunchLog.log(Level.SEVERE, e, "Encountered problem runtime patching class %s", name);
                }
            }
        }
        if (!ignoredError) {
            FMLRelaunchLog.fine("Successfully applied runtime patches for %s (new size %d)", mappedName, inputData.length);
        }
        if (ClassPatchManager.dumpPatched) {
            try {
                Files.write(inputData, new File(this.tempDir, mappedName));
            }
            catch (final IOException e2) {
                FMLRelaunchLog.log(Level.SEVERE, e2, "Failed to write %s to %s", mappedName, this.tempDir.getAbsolutePath());
            }
        }
        this.patchedClasses.put(name, inputData);
        return inputData;
    }
    
    public void setup(final Side side) {
        final Pattern binpatchMatcher = Pattern.compile(String.format("binpatch/%s/.*.binpatch", side.toString().toLowerCase(Locale.ENGLISH)));
        JarInputStream jis;
        try {
            final InputStream binpatchesCompressed = this.getClass().getResourceAsStream("/binpatches.pack.lzma");
            if (binpatchesCompressed == null) {
                FMLRelaunchLog.log(Level.SEVERE, "The binary patch set is missing. Either you are in a development environment, or things are not going to work!", new Object[0]);
                return;
            }
            final LzmaInputStream binpatchesDecompressed = new LzmaInputStream(binpatchesCompressed);
            final ByteArrayOutputStream jarBytes = new ByteArrayOutputStream();
            final JarOutputStream jos = new JarOutputStream(jarBytes);
            Pack200.newUnpacker().unpack((InputStream)binpatchesDecompressed, jos);
            jis = new JarInputStream(new ByteArrayInputStream(jarBytes.toByteArray()));
        }
        catch (final Exception e) {
            FMLRelaunchLog.log(Level.SEVERE, e, "Error occurred reading binary patches. Expect severe problems!", new Object[0]);
            throw Throwables.propagate((Throwable)e);
        }
        this.patches = (ListMultimap<String, ClassPatch>)ArrayListMultimap.create();
    Label_0154_Outer:
        while (true) {
            while (true) {
                try {
                    while (true) {
                        final JarEntry entry = jis.getNextJarEntry();
                        if (entry == null) {
                            break;
                        }
                        if (binpatchMatcher.matcher(entry.getName()).matches()) {
                            final ClassPatch cp = this.readPatch(entry, jis);
                            if (cp == null) {
                                continue Label_0154_Outer;
                            }
                            this.patches.put((Object)cp.sourceClassName, (Object)cp);
                        }
                        else {
                            jis.closeEntry();
                        }
                    }
                    break;
                }
                catch (final IOException e2) {
                    continue Label_0154_Outer;
                }
                continue;
            }
        }
        FMLRelaunchLog.fine("Read %d binary patches", this.patches.size());
        FMLRelaunchLog.fine("Patch list :\n\t%s", Joiner.on("\t\n").join((Iterable)this.patches.asMap().entrySet()));
        this.patchedClasses.clear();
    }
    
    private ClassPatch readPatch(final JarEntry patchEntry, final JarInputStream jis) {
        FMLRelaunchLog.finest("Reading patch data from %s", patchEntry.getName());
        ByteArrayDataInput input;
        try {
            input = ByteStreams.newDataInput(ByteStreams.toByteArray((InputStream)jis));
        }
        catch (final IOException e) {
            FMLRelaunchLog.log(Level.WARNING, e, "Unable to read binpatch file %s - ignoring", patchEntry.getName());
            return null;
        }
        final String name = input.readUTF();
        final String sourceClassName = input.readUTF();
        final String targetClassName = input.readUTF();
        final boolean exists = input.readBoolean();
        int inputChecksum = 0;
        if (exists) {
            inputChecksum = input.readInt();
        }
        final int patchLength = input.readInt();
        final byte[] patchBytes = new byte[patchLength];
        input.readFully(patchBytes);
        return new ClassPatch(name, sourceClassName, targetClassName, exists, inputChecksum, patchBytes);
    }
    
    static {
        INSTANCE = new ClassPatchManager();
        dumpPatched = Boolean.parseBoolean(System.getProperty("fml.dumpPatchedClasses", "false"));
    }
}



================================================
FILE: cpw/mods/fml/common/patcher/GenDiffSet.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.patcher;

import java.util.Arrays;
import java.io.IOException;
import com.google.common.io.ByteArrayDataOutput;
import java.util.jar.JarEntry;
import java.util.Iterator;
import com.google.common.hash.Hashing;
import com.google.common.io.Files;
import com.google.common.io.ByteStreams;
import java.util.zip.ZipEntry;
import java.util.Locale;
import java.io.File;
import java.util.jar.JarFile;
import cpw.mods.fml.common.asm.transformers.deobf.FMLDeobfuscatingRemapper;
import cpw.mods.fml.repackage.com.nothome.delta.Delta;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.List;

public class GenDiffSet
{
    private static final List<String> RESERVED_NAMES;
    
    public static void main(final String[] args) throws IOException {
        final String sourceJar = args[0];
        final String targetDir = args[1];
        final String deobfData = args[2];
        final String outputDir = args[3];
        final String killTarget = args[4];
        Logger.getLogger("GENDIFF").log(Level.INFO, String.format("Creating patches at %s for %s from %s", outputDir, sourceJar, targetDir));
        final Delta delta = new Delta();
        final FMLDeobfuscatingRemapper remapper = FMLDeobfuscatingRemapper.INSTANCE;
        remapper.setupLoadOnly(deobfData, false);
        final JarFile sourceZip = new JarFile(sourceJar);
        final boolean kill = killTarget.equalsIgnoreCase("true");
        final File f = new File(outputDir);
        f.mkdirs();
        for (String fileName : remapper.getObfedClasses()) {
            String jarName;
            final String name = jarName = fileName;
            if (GenDiffSet.RESERVED_NAMES.contains(name.toUpperCase(Locale.ENGLISH))) {
                fileName = "_" + name;
            }
            final File targetFile = new File(targetDir, fileName.replace('/', File.separatorChar) + ".class");
            jarName += ".class";
            if (targetFile.exists()) {
                final String sourceClassName = name.replace('/', '.');
                final String targetClassName = remapper.map(name).replace('/', '.');
                final JarEntry entry = sourceZip.getJarEntry(jarName);
                final byte[] vanillaBytes = (entry != null) ? ByteStreams.toByteArray(sourceZip.getInputStream(entry)) : new byte[0];
                final byte[] patchedBytes = Files.toByteArray(targetFile);
                final byte[] diff = delta.compute(vanillaBytes, patchedBytes);
                final ByteArrayDataOutput diffOut = ByteStreams.newDataOutput(diff.length + 50);
                diffOut.writeUTF(name);
                diffOut.writeUTF(sourceClassName);
                diffOut.writeUTF(targetClassName);
                diffOut.writeBoolean(entry != null);
                if (entry != null) {
                    diffOut.writeInt(Hashing.adler32().hashBytes(vanillaBytes).asInt());
                }
                diffOut.writeInt(diff.length);
                diffOut.write(diff);
                final File target = new File(outputDir, targetClassName + ".binpatch");
                target.getParentFile().mkdirs();
                Files.write(diffOut.toByteArray(), target);
                Logger.getLogger("GENDIFF").info(String.format("Wrote patch for %s (%s) at %s", name, targetClassName, target.getAbsolutePath()));
                if (!kill) {
                    continue;
                }
                targetFile.delete();
                Logger.getLogger("GENDIFF").info(String.format("  Deleted target: %s", targetFile.toString()));
            }
        }
        sourceZip.close();
    }
    
    static {
        RESERVED_NAMES = Arrays.asList("CON", "PRN", "AUX", "NUL", "COM1", "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9", "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9");
    }
}



================================================
FILE: cpw/mods/fml/common/registry/BlockProxy.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.registry;

public interface BlockProxy
{
}



================================================
FILE: cpw/mods/fml/common/registry/BlockTracker.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.registry;

import java.util.BitSet;

class BlockTracker
{
    private static final BlockTracker INSTANCE;
    private BitSet allocatedBlocks;
    
    private BlockTracker() {
        (this.allocatedBlocks = new BitSet(4096)).set(0, 4096);
        for (int i = 0; i < aqz.s.length; ++i) {
            if (aqz.s[i] != null) {
                this.allocatedBlocks.clear(i);
            }
        }
    }
    
    public static int nextBlockId() {
        return instance().getNextBlockId();
    }
    
    private int getNextBlockId() {
        final int idx = this.allocatedBlocks.nextSetBit(0);
        this.allocatedBlocks.clear(idx);
        return idx;
    }
    
    private static BlockTracker instance() {
        return BlockTracker.INSTANCE;
    }
    
    public static void reserveBlockId(final int id) {
        instance().doReserveId(id);
    }
    
    private void doReserveId(final int id) {
        this.allocatedBlocks.clear(id);
    }
    
    static {
        INSTANCE = new BlockTracker();
    }
}



================================================
FILE: cpw/mods/fml/common/registry/EntityRegistry.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.registry;

import cpw.mods.fml.common.network.EntitySpawnPacket;
import com.google.common.base.Function;
import java.util.List;
import com.google.common.primitives.UnsignedBytes;
import cpw.mods.fml.common.Loader;
import java.util.logging.Level;
import cpw.mods.fml.common.FMLLog;
import cpw.mods.fml.common.FMLCommonHandler;
import java.util.Iterator;
import com.google.common.collect.HashBiMap;
import com.google.common.collect.Maps;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.BiMap;
import java.util.Map;
import cpw.mods.fml.common.ModContainer;
import com.google.common.collect.ListMultimap;
import java.util.BitSet;

public class EntityRegistry
{
    private static final EntityRegistry INSTANCE;
    private BitSet availableIndicies;
    private ListMultimap<ModContainer, EntityRegistration> entityRegistrations;
    private Map<String, ModContainer> entityNames;
    private BiMap<Class<? extends nn>, EntityRegistration> entityClassRegistrations;
    
    public static EntityRegistry instance() {
        return EntityRegistry.INSTANCE;
    }
    
    private EntityRegistry() {
        this.entityRegistrations = (ListMultimap<ModContainer, EntityRegistration>)ArrayListMultimap.create();
        this.entityNames = Maps.newHashMap();
        this.entityClassRegistrations = (BiMap<Class<? extends nn>, EntityRegistration>)HashBiMap.create();
        (this.availableIndicies = new BitSet(256)).set(1, 255);
        for (final Object id : nt.d.keySet()) {
            this.availableIndicies.clear((int)id);
        }
    }
    
    public static void registerModEntity(final Class<? extends nn> entityClass, final String entityName, final int id, final Object mod, final int trackingRange, final int updateFrequency, final boolean sendsVelocityUpdates) {
        instance().doModEntityRegistration(entityClass, entityName, id, mod, trackingRange, updateFrequency, sendsVelocityUpdates);
    }
    
    private void doModEntityRegistration(final Class<? extends nn> entityClass, final String entityName, final int id, final Object mod, final int trackingRange, final int updateFrequency, final boolean sendsVelocityUpdates) {
        final ModContainer mc = FMLCommonHandler.instance().findContainerFor(mod);
        final EntityRegistration er = new EntityRegistration(mc, entityClass, entityName, id, trackingRange, updateFrequency, sendsVelocityUpdates);
        try {
            this.entityClassRegistrations.put((Object)entityClass, (Object)er);
            this.entityNames.put(entityName, mc);
            if (!nt.c.containsKey(entityClass)) {
                final String entityModName = String.format("%s.%s", mc.getModId(), entityName);
                nt.c.put(entityClass, entityModName);
                nt.b.put(entityModName, entityClass);
                FMLLog.finest("Automatically registered mod %s entity %s as %s", mc.getModId(), entityName, entityModName);
            }
            else {
                FMLLog.fine("Skipping automatic mod %s entity registration for already registered class %s", mc.getModId(), entityClass.getName());
            }
        }
        catch (final IllegalArgumentException e) {
            FMLLog.log(Level.WARNING, e, "The mod %s tried to register the entity (name,class) (%s,%s) one or both of which are already registered", mc.getModId(), entityName, entityClass.getName());
            return;
        }
        this.entityRegistrations.put((Object)mc, (Object)er);
    }
    
    public static void registerGlobalEntityID(final Class<? extends nn> entityClass, final String entityName, int id) {
        if (nt.c.containsKey(entityClass)) {
            final ModContainer activeModContainer = Loader.instance().activeModContainer();
            String modId = "unknown";
            if (activeModContainer != null) {
                modId = activeModContainer.getModId();
            }
            else {
                FMLLog.severe("There is a rogue mod failing to register entities from outside the context of mod loading. This is incredibly dangerous and should be stopped.", new Object[0]);
            }
            FMLLog.warning("The mod %s tried to register the entity class %s which was already registered - if you wish to override default naming for FML mod entities, register it here first", modId, entityClass);
            return;
        }
        id = instance().validateAndClaimId(id);
        nt.a((Class)entityClass, entityName, id);
    }
    
    private int validateAndClaimId(final int id) {
        int realId = id;
        if (id < -128) {
            FMLLog.warning("Compensating for modloader out of range compensation by mod : entityId %d for mod %s is now %d", id, Loader.instance().activeModContainer().getModId(), realId);
            realId += 3000;
        }
        if (realId < 0) {
            realId += 127;
        }
        try {
            UnsignedBytes.checkedCast((long)realId);
        }
        catch (final IllegalArgumentException e) {
            FMLLog.log(Level.SEVERE, "The entity ID %d for mod %s is not an unsigned byte and may not work", id, Loader.instance().activeModContainer().getModId());
        }
        if (!this.availableIndicies.get(realId)) {
            FMLLog.severe("The mod %s has attempted to register an entity ID %d which is already reserved. This could cause severe problems", Loader.instance().activeModContainer().getModId(), id);
        }
        this.availableIndicies.clear(realId);
        return realId;
    }
    
    public static void registerGlobalEntityID(final Class<? extends nn> entityClass, final String entityName, final int id, final int backgroundEggColour, final int foregroundEggColour) {
        if (nt.c.containsKey(entityClass)) {
            final ModContainer activeModContainer = Loader.instance().activeModContainer();
            String modId = "unknown";
            if (activeModContainer != null) {
                modId = activeModContainer.getModId();
            }
            else {
                FMLLog.severe("There is a rogue mod failing to register entities from outside the context of mod loading. This is incredibly dangerous and should be stopped.", new Object[0]);
            }
            FMLLog.warning("The mod %s tried to register the entity class %s which was already registered - if you wish to override default naming for FML mod entities, register it here first", modId, entityClass);
            return;
        }
        instance().validateAndClaimId(id);
        nt.a((Class)entityClass, entityName, id, backgroundEggColour, foregroundEggColour);
    }
    
    public static void addSpawn(final Class<? extends og> entityClass, final int weightedProb, final int min, final int max, final oh typeOfCreature, final acq... biomes) {
        for (final acq biome : biomes) {
            final List<acr> spawns = biome.a(typeOfCreature);
            for (final acr entry : spawns) {
                if (entry.b == entityClass) {
                    entry.a = weightedProb;
                    entry.c = min;
                    entry.d = max;
                    break;
                }
            }
            spawns.add(new acr((Class)entityClass, weightedProb, min, max));
        }
    }
    
    public static void addSpawn(final String entityName, final int weightedProb, final int min, final int max, final oh spawnList, final acq... biomes) {
        final Class<? extends nn> entityClazz = nt.b.get(entityName);
        if (og.class.isAssignableFrom(entityClazz)) {
            addSpawn((Class<? extends og>)entityClazz, weightedProb, min, max, spawnList, biomes);
        }
    }
    
    public static void removeSpawn(final Class<? extends og> entityClass, final oh typeOfCreature, final acq... biomes) {
        for (final acq biome : biomes) {
            final Iterator<acr> spawns = biome.a(typeOfCreature).iterator();
            while (spawns.hasNext()) {
                final acr entry = spawns.next();
                if (entry.b == entityClass) {
                    spawns.remove();
                }
            }
        }
    }
    
    public static void removeSpawn(final String entityName, final oh spawnList, final acq... biomes) {
        final Class<? extends nn> entityClazz = nt.b.get(entityName);
        if (og.class.isAssignableFrom(entityClazz)) {
            removeSpawn((Class<? extends og>)entityClazz, spawnList, biomes);
        }
    }
    
    public static int findGlobalUniqueEntityId() {
        final int res = instance().availableIndicies.nextSetBit(0);
        if (res < 0) {
            throw new RuntimeException("No more entity indicies left");
        }
        return res;
    }
    
    public EntityRegistration lookupModSpawn(final Class<? extends nn> clazz, boolean keepLooking) {
        Class<?> localClazz = clazz;
        do {
            final EntityRegistration er = (EntityRegistration)this.entityClassRegistrations.get((Object)localClazz);
            if (er != null) {
                return er;
            }
            localClazz = localClazz.getSuperclass();
            keepLooking = !Object.class.equals(localClazz);
        } while (keepLooking);
        return null;
    }
    
    public EntityRegistration lookupModSpawn(final ModContainer mc, final int modEntityId) {
        for (final EntityRegistration er : this.entityRegistrations.get((Object)mc)) {
            if (er.getModEntityId() == modEntityId) {
                return er;
            }
        }
        return null;
    }
    
    public boolean tryTrackingEntity(final jm entityTracker, final nn entity) {
        final EntityRegistration er = this.lookupModSpawn(entity.getClass(), true);
        if (er != null) {
            entityTracker.a(entity, er.getTrackingRange(), er.getUpdateFrequency(), er.sendsVelocityUpdates());
            return true;
        }
        return false;
    }
    
    @Deprecated
    public static EntityRegistration registerModLoaderEntity(final Object mod, final Class<? extends nn> entityClass, final int entityTypeId, final int updateRange, final int updateInterval, final boolean sendVelocityInfo) {
        final String entityName = nt.c.get(entityClass);
        if (entityName == null) {
            throw new IllegalArgumentException(String.format("The ModLoader mod %s has tried to register an entity tracker for a non-existent entity type %s", Loader.instance().activeModContainer().getModId(), entityClass.getCanonicalName()));
        }
        instance().doModEntityRegistration(entityClass, entityName, entityTypeId, mod, updateRange, updateInterval, sendVelocityInfo);
        return (EntityRegistration)instance().entityClassRegistrations.get((Object)entityClass);
    }
    
    static {
        INSTANCE = new EntityRegistry();
    }
    
    public class EntityRegistration
    {
        private Class<? extends nn> entityClass;
        private ModContainer container;
        private String entityName;
        private int modId;
        private int trackingRange;
        private int updateFrequency;
        private boolean sendsVelocityUpdates;
        private Function<EntitySpawnPacket, nn> customSpawnCallback;
        private boolean usesVanillaSpawning;
        
        public EntityRegistration(final ModContainer mc, final Class<? extends nn> entityClass, final String entityName, final int id, final int trackingRange, final int updateFrequency, final boolean sendsVelocityUpdates) {
            this.container = mc;
            this.entityClass = entityClass;
            this.entityName = entityName;
            this.modId = id;
            this.trackingRange = trackingRange;
            this.updateFrequency = updateFrequency;
            this.sendsVelocityUpdates = sendsVelocityUpdates;
        }
        
        public Class<? extends nn> getEntityClass() {
            return this.entityClass;
        }
        
        public ModContainer getContainer() {
            return this.container;
        }
        
        public String getEntityName() {
            return this.entityName;
        }
        
        public int getModEntityId() {
            return this.modId;
        }
        
        public int getTrackingRange() {
            return this.trackingRange;
        }
        
        public int getUpdateFrequency() {
            return this.updateFrequency;
        }
        
        public boolean sendsVelocityUpdates() {
            return this.sendsVelocityUpdates;
        }
        
        public boolean usesVanillaSpawning() {
            return this.usesVanillaSpawning;
        }
        
        public boolean hasCustomSpawning() {
            return this.customSpawnCallback != null;
        }
        
        public nn doCustomSpawning(final EntitySpawnPacket packet) throws Exception {
            return (nn)this.customSpawnCallback.apply((Object)packet);
        }
        
        public void setCustomSpawning(final Function<EntitySpawnPacket, nn> callable, final boolean usesVanillaSpawning) {
            this.customSpawnCallback = callable;
            this.usesVanillaSpawning = usesVanillaSpawning;
        }
    }
}



================================================
FILE: cpw/mods/fml/common/registry/GameData.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.registry;

import com.google.common.collect.HashBasedTable;
import java.io.IOException;
import com.google.common.io.Files;
import com.google.common.base.Charsets;
import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableListMultimap;
import com.google.common.collect.Tables;
import com.google.common.collect.Sets;
import java.util.Iterator;
import com.google.common.base.Function;
import java.util.Set;
import cpw.mods.fml.common.ModContainer;
import cpw.mods.fml.common.LoaderState;
import com.google.common.collect.ImmutableMap;
import com.google.common.base.Throwables;
import cpw.mods.fml.common.FMLLog;
import java.util.logging.Level;
import com.google.common.collect.Maps;
import java.io.InputStream;
import java.io.FileInputStream;
import java.util.Properties;
import java.io.File;
import cpw.mods.fml.common.Loader;
import com.google.common.collect.Table;
import com.google.common.collect.ImmutableTable;
import com.google.common.collect.MapDifference;
import java.util.concurrent.CountDownLatch;
import java.util.Map;

public class GameData
{
    private static Map<Integer, ItemData> idMap;
    private static CountDownLatch serverValidationLatch;
    private static CountDownLatch clientValidationLatch;
    private static MapDifference<Integer, ItemData> difference;
    private static boolean shouldContinue;
    private static boolean isSaveValid;
    private static ImmutableTable<String, String, Integer> modObjectTable;
    private static Table<String, String, ye> customItemStacks;
    private static Map<String, String> ignoredMods;
    private static boolean validated;
    
    private static boolean isModIgnoredForIdValidation(final String modId) {
        if (GameData.ignoredMods == null) {
            final File f = new File(Loader.instance().getConfigDir(), "fmlIDChecking.properties");
            if (f.exists()) {
                final Properties p = new Properties();
                try {
                    p.load(new FileInputStream(f));
                    GameData.ignoredMods = (Map<String, String>)Maps.fromProperties(p);
                    if (GameData.ignoredMods.size() > 0) {
                        FMLLog.log("fml.ItemTracker", Level.WARNING, "Using non-empty ignored mods configuration file %s", GameData.ignoredMods.keySet());
                    }
                }
                catch (final Exception e) {
                    Throwables.propagateIfPossible((Throwable)e);
                    FMLLog.log("fml.ItemTracker", Level.SEVERE, e, "Failed to read ignored ID checker mods properties file", new Object[0]);
                    GameData.ignoredMods = (Map<String, String>)ImmutableMap.of();
                }
            }
            else {
                GameData.ignoredMods = (Map<String, String>)ImmutableMap.of();
            }
        }
        return GameData.ignoredMods.containsKey(modId);
    }
    
    public static void newItemAdded(final yc item) {
        ModContainer mc = Loader.instance().activeModContainer();
        if (mc == null) {
            mc = Loader.instance().getMinecraftModContainer();
            if (Loader.instance().hasReachedState(LoaderState.INITIALIZATION) || GameData.validated) {
                FMLLog.severe("It appears something has tried to allocate an Item or Block outside of the preinitialization phase for mods. This will NOT work in 1.7 and beyond!", new Object[0]);
            }
        }
        final String itemType = item.getClass().getName();
        final ItemData itemData = new ItemData(item, mc);
        if (GameData.idMap.containsKey(item.cv)) {
            final ItemData id = GameData.idMap.get(item.cv);
            FMLLog.log("fml.ItemTracker", Level.INFO, "The mod %s is overwriting existing item at %d (%s from %s) with %s", mc.getModId(), id.getItemId(), id.getItemType(), id.getModId(), itemType);
        }
        GameData.idMap.put(item.cv, itemData);
        if (!"Minecraft".equals(mc.getModId())) {
            FMLLog.log("fml.ItemTracker", Level.FINE, "Adding item %s(%d) owned by %s", item.getClass().getName(), item.cv, mc.getModId());
        }
    }
    
    public static void validateWorldSave(final Set<ItemData> worldSaveItems) {
        GameData.isSaveValid = true;
        GameData.shouldContinue = true;
        if (worldSaveItems == null) {
            GameData.serverValidationLatch.countDown();
            try {
                GameData.clientValidationLatch.await();
            }
            catch (final InterruptedException ex) {}
            return;
        }
        final Function<? super ItemData, Integer> idMapFunction = (Function<? super ItemData, Integer>)new Function<ItemData, Integer>() {
            public Integer apply(final ItemData input) {
                return input.getItemId();
            }
        };
        final Map<Integer, ItemData> worldMap = (Map<Integer, ItemData>)Maps.uniqueIndex((Iterable)worldSaveItems, (Function)idMapFunction);
        GameData.difference = (MapDifference<Integer, ItemData>)Maps.difference((Map)worldMap, (Map)GameData.idMap);
        FMLLog.log("fml.ItemTracker", Level.FINE, "The difference set is %s", GameData.difference);
        if (!GameData.difference.entriesDiffering().isEmpty() || !GameData.difference.entriesOnlyOnLeft().isEmpty()) {
            FMLLog.log("fml.ItemTracker", Level.SEVERE, "FML has detected item discrepancies", new Object[0]);
            FMLLog.log("fml.ItemTracker", Level.SEVERE, "Missing items : %s", GameData.difference.entriesOnlyOnLeft());
            FMLLog.log("fml.ItemTracker", Level.SEVERE, "Mismatched items : %s", GameData.difference.entriesDiffering());
            boolean foundNonIgnored = false;
            for (final ItemData diff : GameData.difference.entriesOnlyOnLeft().values()) {
                if (!isModIgnoredForIdValidation(diff.getModId())) {
                    foundNonIgnored = true;
                }
            }
            for (final MapDifference.ValueDifference<ItemData> diff2 : GameData.difference.entriesDiffering().values()) {
                if (!isModIgnoredForIdValidation(((ItemData)diff2.leftValue()).getModId()) && !isModIgnoredForIdValidation(((ItemData)diff2.rightValue()).getModId())) {
                    foundNonIgnored = true;
                }
            }
            if (!foundNonIgnored) {
                FMLLog.log("fml.ItemTracker", Level.SEVERE, "FML is ignoring these ID discrepancies because of configuration. YOUR GAME WILL NOW PROBABLY CRASH. HOPEFULLY YOU WON'T HAVE CORRUPTED YOUR WORLD. BLAME %s", GameData.ignoredMods.keySet());
            }
            GameData.isSaveValid = !foundNonIgnored;
            GameData.serverValidationLatch.countDown();
        }
        else {
            GameData.isSaveValid = true;
            GameData.serverValidationLatch.countDown();
        }
        try {
            GameData.clientValidationLatch.await();
            if (!GameData.shouldContinue) {
                throw new RuntimeException("This server instance is going to stop abnormally because of a fatal ID mismatch");
            }
        }
        catch (final InterruptedException ex2) {}
    }
    
    public static void writeItemData(final cg itemList) {
        for (final ItemData dat : GameData.idMap.values()) {
            itemList.a((cl)dat.toNBT());
        }
    }
    
    public static void initializeServerGate(final int gateCount) {
        GameData.serverValidationLatch = new CountDownLatch(gateCount - 1);
        GameData.clientValidationLatch = new CountDownLatch(gateCount - 1);
    }
    
    public static MapDifference<Integer, ItemData> gateWorldLoadingForValidation() {
        try {
            GameData.serverValidationLatch.await();
            if (!GameData.isSaveValid) {
                return GameData.difference;
            }
        }
        catch (final InterruptedException ex) {}
        return GameData.difference = null;
    }
    
    public static void releaseGate(final boolean carryOn) {
        GameData.shouldContinue = carryOn;
        GameData.clientValidationLatch.countDown();
    }
    
    public static Set<ItemData> buildWorldItemData(final cg modList) {
        final Set<ItemData> worldSaveItems = Sets.newHashSet();
        for (int i = 0; i < modList.c(); ++i) {
            final by mod = (by)modList.b(i);
            final ItemData dat = new ItemData(mod);
            worldSaveItems.add(dat);
        }
        return worldSaveItems;
    }
    
    static void setName(final yc item, final String name, final String modId) {
        final int id = item.cv;
        final ItemData itemData = GameData.idMap.get(id);
        itemData.setName(name, modId);
    }
    
    public static void buildModObjectTable() {
        if (GameData.modObjectTable != null) {
            throw new IllegalStateException("Illegal call to buildModObjectTable!");
        }
        final Map<Integer, Table.Cell<String, String, Integer>> map = Maps.transformValues((Map)GameData.idMap, (Function)new Function<ItemData, Table.Cell<String, String, Integer>>() {
            public Table.Cell<String, String, Integer> apply(final ItemData data) {
                if ("Minecraft".equals(data.getModId()) || !data.isOveridden()) {
                    return null;
                }
                return (Table.Cell<String, String, Integer>)Tables.immutableCell((Object)data.getModId(), (Object)data.getItemType(), (Object)data.getItemId());
            }
        });
        final ImmutableTable.Builder<String, String, Integer> tBuilder = (ImmutableTable.Builder<String, String, Integer>)ImmutableTable.builder();
        for (final Table.Cell<String, String, Integer> c : map.values()) {
            if (c != null) {
                tBuilder.put((Table.Cell)c);
            }
        }
        GameData.modObjectTable = (ImmutableTable<String, String, Integer>)tBuilder.build();
    }
    
    static yc findItem(final String modId, final String name) {
        if (GameData.modObjectTable == null || !GameData.modObjectTable.contains((Object)modId, (Object)name)) {
            return null;
        }
        return yc.g[(int)GameData.modObjectTable.get((Object)modId, (Object)name)];
    }
    
    static aqz findBlock(final String modId, final String name) {
        if (GameData.modObjectTable == null) {
            return null;
        }
        final Integer blockId = (Integer)GameData.modObjectTable.get((Object)modId, (Object)name);
        if (blockId == null || blockId >= aqz.s.length) {
            return null;
        }
        return aqz.s[blockId];
    }
    
    static ye findItemStack(final String modId, final String name) {
        ye is = (ye)GameData.customItemStacks.get((Object)modId, (Object)name);
        if (is == null) {
            final yc i = findItem(modId, name);
            if (i != null) {
                is = new ye(i, 0, 0);
            }
        }
        if (is == null) {
            final aqz b = findBlock(modId, name);
            if (b != null) {
                is = new ye(b, 0, 32767);
            }
        }
        return is;
    }
    
    static void registerCustomItemStack(final String name, final ye itemStack) {
        GameData.customItemStacks.put((Object)Loader.instance().activeModContainer().getModId(), (Object)name, (Object)itemStack);
    }
    
    public static void dumpRegistry(final File minecraftDir) {
        if (GameData.customItemStacks == null) {
            return;
        }
        if (Boolean.valueOf(System.getProperty("fml.dumpRegistry", "false"))) {
            final ImmutableListMultimap.Builder<String, String> builder = (ImmutableListMultimap.Builder<String, String>)ImmutableListMultimap.builder();
            for (final String modId : GameData.customItemStacks.rowKeySet()) {
                builder.putAll((Object)modId, (Iterable)GameData.customItemStacks.row((Object)modId).keySet());
            }
            final File f = new File(minecraftDir, "itemStackRegistry.csv");
            final Joiner.MapJoiner mapJoiner = Joiner.on("\n").withKeyValueSeparator(",");
            try {
                Files.write((CharSequence)mapJoiner.join((Iterable)builder.build().entries()), f, Charsets.UTF_8);
                FMLLog.log(Level.INFO, "Dumped item registry data to %s", f.getAbsolutePath());
            }
            catch (final IOException e) {
                FMLLog.log(Level.SEVERE, e, "Failed to write registry data to %s", f.getAbsolutePath());
            }
        }
    }
    
    static GameRegistry.UniqueIdentifier getUniqueName(final aqz block) {
        if (block == null) {
            return null;
        }
        final ItemData itemData = GameData.idMap.get(block.cF);
        if (itemData == null || !itemData.isOveridden() || GameData.customItemStacks.contains((Object)itemData.getModId(), (Object)itemData.getItemType())) {
            return null;
        }
        return new GameRegistry.UniqueIdentifier(itemData.getModId(), itemData.getItemType());
    }
    
    static GameRegistry.UniqueIdentifier getUniqueName(final yc item) {
        if (item == null) {
            return null;
        }
        final ItemData itemData = GameData.idMap.get(item.cv);
        if (itemData == null || !itemData.isOveridden() || GameData.customItemStacks.contains((Object)itemData.getModId(), (Object)itemData.getItemType())) {
            return null;
        }
        return new GameRegistry.UniqueIdentifier(itemData.getModId(), itemData.getItemType());
    }
    
    public static void validateRegistry() {
        for (int i = 0; i < yc.g.length; ++i) {
            if (yc.g[i] != null) {
                final ItemData itemData = GameData.idMap.get(i);
                if (itemData == null) {
                    FMLLog.severe("Found completely unknown item of class %s with ID %d, this will NOT work for a 1.7 upgrade", yc.g[i].getClass().getName(), i);
                }
                else if (!itemData.isOveridden() && !"Minecraft".equals(itemData.getModId())) {
                    FMLLog.severe("Found anonymous item of class %s with ID %d owned by mod %s, this item will NOT survive a 1.7 upgrade!", yc.g[i].getClass().getName(), i, itemData.getModId());
                }
            }
        }
        GameData.validated = true;
    }
    
    static {
        GameData.idMap = Maps.newHashMap();
        GameData.shouldContinue = true;
        GameData.isSaveValid = true;
        GameData.customItemStacks = (Table<String, String, ye>)HashBasedTable.create();
    }
}



================================================
FILE: cpw/mods/fml/common/registry/GameRegistry.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.registry;

import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.google.common.collect.ArrayListMultimap;
import cpw.mods.fml.common.ObfuscationReflectionHelper;
import java.util.Map;
import java.lang.reflect.Constructor;
import cpw.mods.fml.common.LoaderException;
import java.util.logging.Level;
import cpw.mods.fml.common.FMLLog;
import cpw.mods.fml.common.LoaderState;
import cpw.mods.fml.common.Loader;
import cpw.mods.fml.common.Mod;
import java.util.Iterator;
import java.util.Random;
import cpw.mods.fml.common.IPlayerTracker;
import cpw.mods.fml.common.IPickupNotifier;
import cpw.mods.fml.common.ICraftingHandler;
import cpw.mods.fml.common.IFuelHandler;
import java.util.List;
import cpw.mods.fml.common.IWorldGenerator;
import java.util.Set;
import cpw.mods.fml.common.ModContainer;
import com.google.common.collect.Multimap;

public class GameRegistry
{
    private static Multimap<ModContainer, BlockProxy> blockRegistry;
    private static Set<IWorldGenerator> worldGenerators;
    private static List<IFuelHandler> fuelHandlers;
    private static List<ICraftingHandler> craftingHandlers;
    private static List<IPickupNotifier> pickupHandlers;
    private static List<IPlayerTracker> playerTrackers;
    
    public static void registerWorldGenerator(final IWorldGenerator generator) {
        GameRegistry.worldGenerators.add(generator);
    }
    
    public static void generateWorld(final int chunkX, final int chunkZ, final abw world, final ado chunkGenerator, final ado chunkProvider) {
        final long worldSeed = world.H();
        final Random fmlRandom = new Random(worldSeed);
        final long xSeed = fmlRandom.nextLong() >> 3;
        final long zSeed = fmlRandom.nextLong() >> 3;
        final long chunkSeed = xSeed * chunkX + zSeed * chunkZ ^ worldSeed;
        for (final IWorldGenerator generator : GameRegistry.worldGenerators) {
            fmlRandom.setSeed(chunkSeed);
            generator.generate(fmlRandom, chunkX, chunkZ, world, chunkGenerator, chunkProvider);
        }
    }
    
    public static Object buildBlock(final ModContainer container, final Class<?> type, final Mod.Block annotation) throws Exception {
        final Object o = type.getConstructor(Integer.TYPE).newInstance(findSpareBlockId());
        registerBlock((aqz)o);
        return o;
    }
    
    private static int findSpareBlockId() {
        return BlockTracker.nextBlockId();
    }
    
    public static void registerItem(final yc item, final String name) {
        registerItem(item, name, null);
    }
    
    public static void registerItem(final yc item, final String name, final String modId) {
        GameData.setName(item, name, modId);
    }
    
    @Deprecated
    public static void registerBlock(final aqz block) {
        registerBlock(block, zh.class);
    }
    
    public static void registerBlock(final aqz block, final String name) {
        registerBlock(block, zh.class, name);
    }
    
    @Deprecated
    public static void registerBlock(final aqz block, final Class<? extends zh> itemclass) {
        registerBlock(block, itemclass, null);
    }
    
    public static void registerBlock(final aqz block, final Class<? extends zh> itemclass, final String name) {
        registerBlock(block, itemclass, name, null);
    }
    
    public static void registerBlock(final aqz block, final Class<? extends zh> itemclass, final String name, final String modId) {
        if (Loader.instance().isInState(LoaderState.CONSTRUCTING)) {
            FMLLog.warning("The mod %s is attempting to register a block whilst it it being constructed. This is bad modding practice - please use a proper mod lifecycle event.", Loader.instance().activeModContainer());
        }
        try {
            assert block != null : "registerBlock: block cannot be null";
            assert itemclass != null : "registerBlock: itemclass cannot be null";
            final int blockItemId = block.cF - 256;
            yc i;
            try {
                final Constructor<? extends zh> itemCtor = itemclass.getConstructor(Integer.TYPE);
                i = (yc)itemCtor.newInstance(blockItemId);
            }
            catch (final NoSuchMethodException e) {
                final Constructor<? extends zh> itemCtor = itemclass.getConstructor(Integer.TYPE, aqz.class);
                i = (yc)itemCtor.newInstance(blockItemId, block);
            }
            registerItem(i, name, modId);
        }
        catch (final Exception e2) {
            FMLLog.log(Level.SEVERE, e2, "Caught an exception during block registration", new Object[0]);
            throw new LoaderException(e2);
        }
        GameRegistry.blockRegistry.put((Object)Loader.instance().activeModContainer(), (Object)block);
    }
    
    public static void addRecipe(final ye output, final Object... params) {
        addShapedRecipe(output, params);
    }
    
    public static aah addShapedRecipe(final ye output, final Object... params) {
        return (aah)aaf.a().a(output, params);
    }
    
    public static void addShapelessRecipe(final ye output, final Object... params) {
        aaf.a().b(output, params);
    }
    
    public static void addRecipe(final aah recipe) {
        aaf.a().b().add(recipe);
    }
    
    public static void addSmelting(final int input, final ye output, final float xp) {
        aab.a().a(input, output, xp);
    }
    
    public static void registerTileEntity(final Class<? extends asp> tileEntityClass, final String id) {
        asp.a((Class)tileEntityClass, id);
    }
    
    public static void registerTileEntityWithAlternatives(final Class<? extends asp> tileEntityClass, final String id, final String... alternatives) {
        asp.a((Class)tileEntityClass, id);
        final Map<String, Class> teMappings = ObfuscationReflectionHelper.getPrivateValue((Class<? super Object>)asp.class, (Object)null, "field_70326_a", "nameToClassMap", "a");
        for (final String s : alternatives) {
            if (!teMappings.containsKey(s)) {
                teMappings.put(s, tileEntityClass);
            }
        }
    }
    
    public static void addBiome(final acq biome) {
        acg.b.addNewBiome(biome);
    }
    
    public static void removeBiome(final acq biome) {
        acg.b.removeBiome(biome);
    }
    
    public static void registerFuelHandler(final IFuelHandler handler) {
        GameRegistry.fuelHandlers.add(handler);
    }
    
    public static int getFuelValue(final ye itemStack) {
        int fuelValue = 0;
        for (final IFuelHandler handler : GameRegistry.fuelHandlers) {
            fuelValue = Math.max(fuelValue, handler.getBurnTime(itemStack));
        }
        return fuelValue;
    }
    
    public static void registerCraftingHandler(final ICraftingHandler handler) {
        GameRegistry.craftingHandlers.add(handler);
    }
    
    public static void onItemCrafted(final uf player, final ye item, final mo craftMatrix) {
        for (final ICraftingHandler handler : GameRegistry.craftingHandlers) {
            handler.onCrafting(player, item, craftMatrix);
        }
    }
    
    public static void onItemSmelted(final uf player, final ye item) {
        for (final ICraftingHandler handler : GameRegistry.craftingHandlers) {
            handler.onSmelting(player, item);
        }
    }
    
    public static void registerPickupHandler(final IPickupNotifier handler) {
        GameRegistry.pickupHandlers.add(handler);
    }
    
    public static void onPickupNotification(final uf player, final ss item) {
        for (final IPickupNotifier notify : GameRegistry.pickupHandlers) {
            notify.notifyPickup(item, player);
        }
    }
    
    public static void registerPlayerTracker(final IPlayerTracker tracker) {
        GameRegistry.playerTrackers.add(tracker);
    }
    
    public static void onPlayerLogin(final uf player) {
        for (final IPlayerTracker tracker : GameRegistry.playerTrackers) {
            try {
                tracker.onPlayerLogin(player);
            }
            catch (final Exception e) {
                FMLLog.log(Level.SEVERE, e, "A critical error occured handling the onPlayerLogin event with player tracker %s", tracker.getClass().getName());
            }
        }
    }
    
    public static void onPlayerLogout(final uf player) {
        for (final IPlayerTracker tracker : GameRegistry.playerTrackers) {
            try {
                tracker.onPlayerLogout(player);
            }
            catch (final Exception e) {
                FMLLog.log(Level.SEVERE, e, "A critical error occured handling the onPlayerLogout event with player tracker %s", tracker.getClass().getName());
            }
        }
    }
    
    public static void onPlayerChangedDimension(final uf player) {
        for (final IPlayerTracker tracker : GameRegistry.playerTrackers) {
            try {
                tracker.onPlayerChangedDimension(player);
            }
            catch (final Exception e) {
                FMLLog.log(Level.SEVERE, e, "A critical error occured handling the onPlayerChangedDimension event with player tracker %s", tracker.getClass().getName());
            }
        }
    }
    
    public static void onPlayerRespawn(final uf player) {
        for (final IPlayerTracker tracker : GameRegistry.playerTrackers) {
            try {
                tracker.onPlayerRespawn(player);
            }
            catch (final Exception e) {
                FMLLog.log(Level.SEVERE, e, "A critical error occured handling the onPlayerRespawn event with player tracker %s", tracker.getClass().getName());
            }
        }
    }
    
    public static aqz findBlock(final String modId, final String name) {
        return GameData.findBlock(modId, name);
    }
    
    public static yc findItem(final String modId, final String name) {
        return GameData.findItem(modId, name);
    }
    
    public static void registerCustomItemStack(final String name, final ye itemStack) {
        GameData.registerCustomItemStack(name, itemStack);
    }
    
    public static ye findItemStack(final String modId, final String name, final int stackSize) {
        final ye foundStack = GameData.findItemStack(modId, name);
        if (foundStack != null) {
            final ye is = foundStack.m();
            is.b = Math.min(stackSize, is.e());
            return is;
        }
        return null;
    }
    
    public static UniqueIdentifier findUniqueIdentifierFor(final aqz block) {
        return GameData.getUniqueName(block);
    }
    
    public static UniqueIdentifier findUniqueIdentifierFor(final yc item) {
        return GameData.getUniqueName(item);
    }
    
    static {
        GameRegistry.blockRegistry = (Multimap<ModContainer, BlockProxy>)ArrayListMultimap.create();
        GameRegistry.worldGenerators = Sets.newHashSet();
        GameRegistry.fuelHandlers = Lists.newArrayList();
        GameRegistry.craftingHandlers = Lists.newArrayList();
        GameRegistry.pickupHandlers = Lists.newArrayList();
        GameRegistry.playerTrackers = Lists.newArrayList();
    }
    
    public static class UniqueIdentifier
    {
        public final String modId;
        public final String name;
        
        UniqueIdentifier(final String modId, final String name) {
            this.modId = modId;
            this.name = name;
        }
    }
}



================================================
FILE: cpw/mods/fml/common/registry/IEntityAdditionalSpawnData.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.registry;

import com.google.common.io.ByteArrayDataInput;
import com.google.common.io.ByteArrayDataOutput;

public interface IEntityAdditionalSpawnData
{
    void writeSpawnData(final ByteArrayDataOutput p0);
    
    void readSpawnData(final ByteArrayDataInput p0);
}



================================================
FILE: cpw/mods/fml/common/registry/ItemData.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.registry;

import com.google.common.collect.Maps;
import cpw.mods.fml.common.LoaderException;
import cpw.mods.fml.common.FMLLog;
import cpw.mods.fml.common.Loader;
import com.google.common.base.Objects;
import com.google.common.collect.HashMultiset;
import cpw.mods.fml.common.ModContainer;
import com.google.common.collect.Multiset;
import java.util.Map;

public class ItemData
{
    private static Map<String, Multiset<String>> modOrdinals;
    private final String modId;
    private final String itemType;
    private final int itemId;
    private final int ordinal;
    private String forcedModId;
    private String forcedName;
    
    public ItemData(final yc item, final ModContainer mc) {
        this.itemId = item.cv;
        if (item.getClass().equals(zh.class)) {
            this.itemType = aqz.s[this.getItemId()].getClass().getName();
        }
        else {
            this.itemType = item.getClass().getName();
        }
        this.modId = mc.getModId();
        if (!ItemData.modOrdinals.containsKey(mc.getModId())) {
            ItemData.modOrdinals.put(mc.getModId(), (Multiset<String>)HashMultiset.create());
        }
        this.ordinal = ItemData.modOrdinals.get(mc.getModId()).add((Object)this.itemType, 1);
    }
    
    public ItemData(final by tag) {
        this.modId = tag.i("ModId");
        this.itemType = tag.i("ItemType");
        this.itemId = tag.e("ItemId");
        this.ordinal = tag.e("ordinal");
        this.forcedModId = (tag.b("ForcedModId") ? tag.i("ForcedModId") : null);
        this.forcedName = (tag.b("ForcedName") ? tag.i("ForcedName") : null);
    }
    
    public String getItemType() {
        return (this.forcedName != null) ? this.forcedName : this.itemType;
    }
    
    public String getModId() {
        return (this.forcedModId != null) ? this.forcedModId : this.modId;
    }
    
    public int getOrdinal() {
        return this.ordinal;
    }
    
    public int getItemId() {
        return this.itemId;
    }
    
    public by toNBT() {
        final by tag = new by();
        tag.a("ModId", this.modId);
        tag.a("ItemType", this.itemType);
        tag.a("ItemId", this.itemId);
        tag.a("ordinal", this.ordinal);
        if (this.forcedModId != null) {
            tag.a("ForcedModId", this.forcedModId);
        }
        if (this.forcedName != null) {
            tag.a("ForcedName", this.forcedName);
        }
        return tag;
    }
    
    @Override
    public int hashCode() {
        return Objects.hashCode(new Object[] { this.itemId, this.ordinal });
    }
    
    @Override
    public boolean equals(final Object obj) {
        try {
            final ItemData other = (ItemData)obj;
            return Objects.equal((Object)this.getModId(), (Object)other.getModId()) && Objects.equal((Object)this.getItemType(), (Object)other.getItemType()) && Objects.equal((Object)this.itemId, (Object)other.itemId) && (this.isOveridden() || Objects.equal((Object)this.ordinal, (Object)other.ordinal));
        }
        catch (final ClassCastException cce) {
            return false;
        }
    }
    
    @Override
    public String toString() {
        return String.format("Item %d, Type %s, owned by %s, ordinal %d, name %s, claimedModId %s", this.itemId, this.itemType, this.modId, this.ordinal, this.forcedName, this.forcedModId);
    }
    
    public boolean mayDifferByOrdinal(final ItemData rightValue) {
        return Objects.equal((Object)this.getItemType(), (Object)rightValue.getItemType()) && Objects.equal((Object)this.getModId(), (Object)rightValue.getModId());
    }
    
    public boolean isOveridden() {
        return this.forcedName != null;
    }
    
    public void setName(final String name, final String modId) {
        if (name == null) {
            this.forcedName = null;
            this.forcedModId = null;
            return;
        }
        String localModId;
        if ((localModId = modId) == null) {
            localModId = Loader.instance().activeModContainer().getModId();
        }
        if (ItemData.modOrdinals.get(localModId).count((Object)name) > 0) {
            FMLLog.severe("The mod %s is attempting to redefine the item at id %d with a non-unique name (%s.%s)", Loader.instance().activeModContainer(), this.itemId, localModId, name);
            throw new LoaderException();
        }
        ItemData.modOrdinals.get(localModId).add((Object)name);
        this.forcedModId = modId;
        this.forcedName = name;
    }
    
    static {
        ItemData.modOrdinals = Maps.newHashMap();
    }
}



================================================
FILE: cpw/mods/fml/common/registry/ItemProxy.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.registry;

public interface ItemProxy
{
}



================================================
FILE: cpw/mods/fml/common/registry/IThrowableEntity.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.registry;

public interface IThrowableEntity
{
    nn getThrower();
    
    void setThrower(final nn p0);
}



================================================
FILE: cpw/mods/fml/common/registry/LanguageRegistry.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.registry;

import java.util.Hashtable;
import java.io.InputStream;
import java.io.IOException;
import java.io.Reader;
import java.io.InputStreamReader;
import com.google.common.base.Charsets;
import cpw.mods.fml.common.ModContainer;
import java.net.URL;
import cpw.mods.fml.common.FMLLog;
import java.util.logging.Level;
import cpw.mods.fml.common.Loader;
import cpw.mods.fml.common.FMLCommonHandler;
import java.util.HashMap;
import java.util.Properties;
import java.util.Map;

public class LanguageRegistry
{
    private static final LanguageRegistry INSTANCE;
    private Map<String, Properties> modLanguageData;
    
    public LanguageRegistry() {
        this.modLanguageData = new HashMap<String, Properties>();
    }
    
    public static LanguageRegistry instance() {
        return LanguageRegistry.INSTANCE;
    }
    
    public String getStringLocalization(final String key) {
        return this.getStringLocalization(key, FMLCommonHandler.instance().getCurrentLanguage());
    }
    
    public String getStringLocalization(final String key, final String lang) {
        String localizedString = "";
        final Properties langPack = this.modLanguageData.get(lang);
        if (langPack != null && langPack.getProperty(key) != null) {
            localizedString = langPack.getProperty(key);
        }
        return localizedString;
    }
    
    public void addStringLocalization(final String key, final String value) {
        this.addStringLocalization(key, "en_US", value);
    }
    
    public void addStringLocalization(final String key, final String lang, final String value) {
        Properties langPack = this.modLanguageData.get(lang);
        if (langPack == null) {
            langPack = new Properties();
            this.modLanguageData.put(lang, langPack);
        }
        ((Hashtable<String, String>)langPack).put(key, value);
    }
    
    public void addStringLocalization(final Properties langPackAdditions) {
        this.addStringLocalization(langPackAdditions, "en_US");
    }
    
    public void addStringLocalization(final Properties langPackAdditions, final String lang) {
        Properties langPack = this.modLanguageData.get(lang);
        if (langPack == null) {
            langPack = new Properties();
            this.modLanguageData.put(lang, langPack);
        }
        if (langPackAdditions != null) {
            langPack.putAll(langPackAdditions);
        }
    }
    
    public static void reloadLanguageTable() {
    }
    
    public void addNameForObject(final Object objectToName, final String lang, final String name) {
        String objectName;
        if (objectToName instanceof yc) {
            objectName = ((yc)objectToName).a();
        }
        else if (objectToName instanceof aqz) {
            objectName = ((aqz)objectToName).a();
        }
        else {
            if (!(objectToName instanceof ye)) {
                throw new IllegalArgumentException(String.format("Illegal object for naming %s", objectToName));
            }
            objectName = ((ye)objectToName).b().d((ye)objectToName);
        }
        objectName += ".name";
        this.addStringLocalization(objectName, lang, name);
    }
    
    public static void addName(final Object objectToName, final String name) {
        instance().addNameForObject(objectToName, "en_US", name);
    }
    
    public void loadLanguageTable(final Map field_135032_a, final String lang) {
        final Properties usPack = this.modLanguageData.get("en_US");
        if (usPack != null) {
            field_135032_a.putAll(usPack);
        }
        final Properties langPack = this.modLanguageData.get(lang);
        if (langPack == null) {
            return;
        }
        field_135032_a.putAll(langPack);
    }
    
    public void loadLocalization(final String localizationFile, final String lang, final boolean isXML) {
        final URL urlResource = this.getClass().getResource(localizationFile);
        if (urlResource != null) {
            this.loadLocalization(urlResource, lang, isXML);
        }
        else {
            final ModContainer activeModContainer = Loader.instance().activeModContainer();
            if (activeModContainer != null) {
                FMLLog.log(activeModContainer.getModId(), Level.SEVERE, "The language resource %s cannot be located on the classpath. This is a programming error.", localizationFile);
            }
            else {
                FMLLog.log(Level.SEVERE, "The language resource %s cannot be located on the classpath. This is a programming error.", localizationFile);
            }
        }
    }
    
    public void loadLocalization(final URL localizationFile, final String lang, final boolean isXML) {
        InputStream langStream = null;
        final Properties langPack = new Properties();
        try {
            langStream = localizationFile.openStream();
            if (isXML) {
                langPack.loadFromXML(langStream);
            }
            else {
                langPack.load(new InputStreamReader(langStream, Charsets.UTF_8));
            }
            this.addStringLocalization(langPack, lang);
        }
        catch (final IOException e) {
            FMLLog.log(Level.SEVERE, e, "Unable to load localization from file %s", localizationFile);
        }
        finally {
            try {
                if (langStream != null) {
                    langStream.close();
                }
            }
            catch (final IOException ex) {}
        }
    }
    
    static {
        INSTANCE = new LanguageRegistry();
    }
}



================================================
FILE: cpw/mods/fml/common/registry/TickRegistry.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.registry;

import com.google.common.collect.Queues;
import java.util.List;
import cpw.mods.fml.common.SingleIntervalHandler;
import cpw.mods.fml.common.ITickHandler;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.common.IScheduledTickHandler;
import java.util.concurrent.atomic.AtomicLong;
import java.util.PriorityQueue;

public class TickRegistry
{
    private static PriorityQueue<TickQueueElement> clientTickHandlers;
    private static PriorityQueue<TickQueueElement> serverTickHandlers;
    private static AtomicLong clientTickCounter;
    private static AtomicLong serverTickCounter;
    
    public static void registerScheduledTickHandler(final IScheduledTickHandler handler, final Side side) {
        getQueue(side).add(new TickQueueElement(handler, getCounter(side).get()));
    }
    
    private static PriorityQueue<TickQueueElement> getQueue(final Side side) {
        return side.isClient() ? TickRegistry.clientTickHandlers : TickRegistry.serverTickHandlers;
    }
    
    private static AtomicLong getCounter(final Side side) {
        return side.isClient() ? TickRegistry.clientTickCounter : TickRegistry.serverTickCounter;
    }
    
    public static void registerTickHandler(final ITickHandler handler, final Side side) {
        registerScheduledTickHandler(new SingleIntervalHandler(handler), side);
    }
    
    public static void updateTickQueue(final List<IScheduledTickHandler> ticks, final Side side) {
        synchronized (ticks) {
            ticks.clear();
            final long tick = getCounter(side).incrementAndGet();
            final PriorityQueue<TickQueueElement> tickHandlers = getQueue(side);
            while (tickHandlers.size() != 0 && tickHandlers.peek().scheduledNow(tick)) {
                final TickQueueElement tickQueueElement = tickHandlers.poll();
                tickQueueElement.update(tick);
                tickHandlers.offer(tickQueueElement);
                ticks.add(tickQueueElement.ticker);
            }
        }
    }
    
    static {
        TickRegistry.clientTickHandlers = Queues.newPriorityQueue();
        TickRegistry.serverTickHandlers = Queues.newPriorityQueue();
        TickRegistry.clientTickCounter = new AtomicLong();
        TickRegistry.serverTickCounter = new AtomicLong();
    }
    
    public static class TickQueueElement implements Comparable<TickQueueElement>
    {
        private long next;
        public IScheduledTickHandler ticker;
        
        public TickQueueElement(final IScheduledTickHandler ticker, final long tickCounter) {
            this.ticker = ticker;
            this.update(tickCounter);
        }
        
        @Override
        public int compareTo(final TickQueueElement o) {
            return (int)(this.next - o.next);
        }
        
        public void update(final long tickCounter) {
            this.next = tickCounter + Math.max(this.ticker.nextTickSpacing(), 1);
        }
        
        public boolean scheduledNow(final long tickCounter) {
            return tickCounter >= this.next;
        }
    }
}



================================================
FILE: cpw/mods/fml/common/registry/VillagerRegistry.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.registry;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Random;
import java.util.Collections;
import java.util.Collection;
import cpw.mods.fml.common.FMLLog;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.ArrayListMultimap;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;
import java.util.List;
import java.util.Map;
import com.google.common.collect.Multimap;

public class VillagerRegistry
{
    private static final VillagerRegistry INSTANCE;
    private Multimap<Integer, IVillageTradeHandler> tradeHandlers;
    private Map<Class<?>, IVillageCreationHandler> villageCreationHandlers;
    private List<Integer> newVillagerIds;
    @SideOnly(Side.CLIENT)
    private Map<Integer, bjo> newVillagers;
    
    public VillagerRegistry() {
        this.tradeHandlers = (Multimap<Integer, IVillageTradeHandler>)ArrayListMultimap.create();
        this.villageCreationHandlers = Maps.newHashMap();
        this.newVillagerIds = Lists.newArrayList();
    }
    
    public static VillagerRegistry instance() {
        return VillagerRegistry.INSTANCE;
    }
    
    public void registerVillagerId(final int id) {
        if (this.newVillagerIds.contains(id)) {
            FMLLog.severe("Attempt to register duplicate villager id %d", id);
            throw new RuntimeException();
        }
        this.newVillagerIds.add(id);
    }
    
    @SideOnly(Side.CLIENT)
    public void registerVillagerSkin(final int villagerId, final bjo villagerSkin) {
        if (this.newVillagers == null) {
            this.newVillagers = Maps.newHashMap();
        }
        this.newVillagers.put(villagerId, villagerSkin);
    }
    
    public void registerVillageCreationHandler(final IVillageCreationHandler handler) {
        this.villageCreationHandlers.put(handler.getComponentClass(), handler);
    }
    
    public void registerVillageTradeHandler(final int villagerId, final IVillageTradeHandler handler) {
        this.tradeHandlers.put((Object)villagerId, (Object)handler);
    }
    
    @SideOnly(Side.CLIENT)
    public static bjo getVillagerSkin(final int villagerType, final bjo defaultSkin) {
        if (instance().newVillagers != null && instance().newVillagers.containsKey(villagerType)) {
            return instance().newVillagers.get(villagerType);
        }
        return defaultSkin;
    }
    
    public static Collection<Integer> getRegisteredVillagers() {
        return Collections.unmodifiableCollection((Collection<? extends Integer>)instance().newVillagerIds);
    }
    
    public static void manageVillagerTrades(final abm recipeList, final ub villager, final int villagerType, final Random random) {
        for (final IVillageTradeHandler handler : instance().tradeHandlers.get((Object)villagerType)) {
            handler.manipulateTradesForVillager(villager, recipeList, random);
        }
    }
    
    public static void addExtraVillageComponents(final ArrayList components, final Random random, final int i) {
        final List<ajd> parts = components;
        for (final IVillageCreationHandler handler : instance().villageCreationHandlers.values()) {
            parts.add(handler.getVillagePieceWeight(random, i));
        }
    }
    
    public static Object getVillageComponent(final ajd villagePiece, final ajj startPiece, final List pieces, final Random random, final int p1, final int p2, final int p3, final int p4, final int p5) {
        return instance().villageCreationHandlers.get(villagePiece.a).buildComponent(villagePiece, startPiece, pieces, random, p1, p2, p3, p4, p5);
    }
    
    public static void addEmeraldBuyRecipe(final ub villager, final abm list, final Random random, final yc item, final float chance, final int min, final int max) {
        if (min > 0 && max > 0) {
            ub.bB.put(item.cv, new mh((Object)min, (Object)max));
        }
        ub.a(list, item.o(), random, chance);
    }
    
    public static void addEmeraldSellRecipe(final ub villager, final abm list, final Random random, final yc item, final float chance, final int min, final int max) {
        if (min > 0 && max > 0) {
            ub.bC.put(item.cv, new mh((Object)min, (Object)max));
        }
        ub.b(list, item.o(), random, chance);
    }
    
    public static void applyRandomTrade(final ub villager, final Random rand) {
        final int extra = instance().newVillagerIds.size();
        final int trade = rand.nextInt(5 + extra);
        villager.p((trade < 5) ? trade : ((int)instance().newVillagerIds.get(trade - 5)));
    }
    
    static {
        INSTANCE = new VillagerRegistry();
    }
    
    public interface IVillageTradeHandler
    {
        void manipulateTradesForVillager(final ub p0, final abm p1, final Random p2);
    }
    
    public interface IVillageCreationHandler
    {
        ajd getVillagePieceWeight(final Random p0, final int p1);
        
        Class<?> getComponentClass();
        
        Object buildComponent(final ajd p0, final ajj p1, final List p2, final Random p3, final int p4, final int p5, final int p6, final int p7, final int p8);
    }
}



================================================
FILE: cpw/mods/fml/common/toposort/ModSorter.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.toposort;

import java.util.Collection;
import java.util.Arrays;
import java.util.Iterator;
import cpw.mods.fml.common.Loader;
import cpw.mods.fml.common.versioning.ArtifactVersion;
import java.util.HashMap;
import cpw.mods.fml.common.ModAPIManager;
import com.google.common.collect.Maps;
import cpw.mods.fml.common.DummyModContainer;
import java.util.Map;
import java.util.List;
import cpw.mods.fml.common.ModContainer;

public class ModSorter
{
    private TopologicalSort.DirectedGraph<ModContainer> modGraph;
    private ModContainer beforeAll;
    private ModContainer afterAll;
    private ModContainer before;
    private ModContainer after;
    
    public ModSorter(final List<ModContainer> modList, final Map<String, ModContainer> nameLookup) {
        this.beforeAll = new DummyModContainer("BeforeAll");
        this.afterAll = new DummyModContainer("AfterAll");
        this.before = new DummyModContainer("Before");
        this.after = new DummyModContainer("After");
        final HashMap<String, ModContainer> sortingNameLookup = Maps.newHashMap((Map)nameLookup);
        ModAPIManager.INSTANCE.injectAPIModContainers(modList, sortingNameLookup);
        this.buildGraph(modList, sortingNameLookup);
    }
    
    private void buildGraph(final List<ModContainer> modList, final Map<String, ModContainer> nameLookup) {
        (this.modGraph = new TopologicalSort.DirectedGraph<ModContainer>()).addNode(this.beforeAll);
        this.modGraph.addNode(this.before);
        this.modGraph.addNode(this.afterAll);
        this.modGraph.addNode(this.after);
        this.modGraph.addEdge(this.before, this.after);
        this.modGraph.addEdge(this.beforeAll, this.before);
        this.modGraph.addEdge(this.after, this.afterAll);
        for (final ModContainer mod : modList) {
            this.modGraph.addNode(mod);
        }
        for (final ModContainer mod : modList) {
            if (mod.isImmutable()) {
                this.modGraph.addEdge(this.beforeAll, mod);
                this.modGraph.addEdge(mod, this.before);
            }
            else {
                boolean preDepAdded = false;
                boolean postDepAdded = false;
                for (final ArtifactVersion dep : mod.getDependencies()) {
                    preDepAdded = true;
                    final String modid = dep.getLabel();
                    if (modid.equals("*")) {
                        this.modGraph.addEdge(mod, this.afterAll);
                        this.modGraph.addEdge(this.after, mod);
                        postDepAdded = true;
                    }
                    else {
                        this.modGraph.addEdge(this.before, mod);
                        if (!nameLookup.containsKey(modid) && !Loader.isModLoaded(modid)) {
                            continue;
                        }
                        this.modGraph.addEdge(nameLookup.get(modid), mod);
                    }
                }
                for (final ArtifactVersion dep : mod.getDependants()) {
                    postDepAdded = true;
                    final String modid = dep.getLabel();
                    if (modid.equals("*")) {
                        this.modGraph.addEdge(this.beforeAll, mod);
                        this.modGraph.addEdge(mod, this.before);
                        preDepAdded = true;
                    }
                    else {
                        this.modGraph.addEdge(mod, this.after);
                        if (!Loader.isModLoaded(modid)) {
                            continue;
                        }
                        this.modGraph.addEdge(mod, nameLookup.get(modid));
                    }
                }
                if (!preDepAdded) {
                    this.modGraph.addEdge(this.before, mod);
                }
                if (postDepAdded) {
                    continue;
                }
                this.modGraph.addEdge(mod, this.after);
            }
        }
    }
    
    public List<ModContainer> sort() {
        final List<ModContainer> sortedList = TopologicalSort.topologicalSort(this.modGraph);
        sortedList.removeAll(Arrays.asList(this.beforeAll, this.before, this.after, this.afterAll));
        return sortedList;
    }
}



================================================
FILE: cpw/mods/fml/common/toposort/ModSortingException.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.toposort;

import java.util.Set;

public class ModSortingException extends RuntimeException
{
    private SortingExceptionData sortingExceptionData;
    
    public <T> ModSortingException(final String string, final T node, final Set<T> visitedNodes) {
        super(string);
        this.sortingExceptionData = new SortingExceptionData((T)node, (Set<T>)visitedNodes);
    }
    
    public <T> SortingExceptionData<T> getExceptionData() {
        return this.sortingExceptionData;
    }
    
    public class SortingExceptionData<T>
    {
        private T firstBadNode;
        private Set<T> visitedNodes;
        
        public SortingExceptionData(final T node, final Set<T> visitedNodes) {
            this.firstBadNode = node;
            this.visitedNodes = visitedNodes;
        }
        
        public T getFirstBadNode() {
            return this.firstBadNode;
        }
        
        public Set<T> getVisitedNodes() {
            return this.visitedNodes;
        }
    }
}



================================================
FILE: cpw/mods/fml/common/toposort/TopologicalSort.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.toposort;

import java.util.Collections;
import java.util.NoSuchElementException;
import java.util.TreeSet;
import java.util.Comparator;
import java.util.HashMap;
import java.util.SortedSet;
import java.util.Map;
import com.google.common.collect.Sets;
import cpw.mods.fml.common.FMLLog;
import java.util.Iterator;
import java.util.Set;
import java.util.HashSet;
import java.util.ArrayList;
import java.util.List;

public class TopologicalSort
{
    public static <T> List<T> topologicalSort(final DirectedGraph<T> graph) {
        final DirectedGraph<T> rGraph = reverse(graph);
        final List<T> sortedResult = new ArrayList<T>();
        final Set<T> visitedNodes = new HashSet<T>();
        final Set<T> expandedNodes = new HashSet<T>();
        for (final T node : rGraph) {
            explore(node, rGraph, sortedResult, visitedNodes, expandedNodes);
        }
        return sortedResult;
    }
    
    public static <T> DirectedGraph<T> reverse(final DirectedGraph<T> graph) {
        final DirectedGraph<T> result = new DirectedGraph<T>();
        for (final T node : graph) {
            result.addNode(node);
        }
        for (final T from : graph) {
            for (final T to : graph.edgesFrom(from)) {
                result.addEdge(to, from);
            }
        }
        return result;
    }
    
    public static <T> void explore(final T node, final DirectedGraph<T> graph, final List<T> sortedResult, final Set<T> visitedNodes, final Set<T> expandedNodes) {
        if (!visitedNodes.contains(node)) {
            visitedNodes.add(node);
            for (final T inbound : graph.edgesFrom(node)) {
                explore(inbound, (DirectedGraph<Object>)graph, (List<Object>)sortedResult, (Set<Object>)visitedNodes, (Set<Object>)expandedNodes);
            }
            sortedResult.add(node);
            expandedNodes.add(node);
            return;
        }
        if (expandedNodes.contains(node)) {
            return;
        }
        FMLLog.severe("Mod Sorting failed.", new Object[0]);
        FMLLog.severe("Visting node %s", node);
        FMLLog.severe("Current sorted list : %s", sortedResult);
        FMLLog.severe("Visited set for this node : %s", visitedNodes);
        FMLLog.severe("Explored node set : %s", expandedNodes);
        final Sets.SetView<T> cycleList = (Sets.SetView<T>)Sets.difference((Set)visitedNodes, (Set)expandedNodes);
        FMLLog.severe("Likely cycle is in : %s", cycleList);
        throw new ModSortingException("There was a cycle detected in the input graph, sorting is not possible", (T)node, (Set<T>)cycleList);
    }
    
    public static class DirectedGraph<T> implements Iterable<T>
    {
        private final Map<T, SortedSet<T>> graph;
        private List<T> orderedNodes;
        
        public DirectedGraph() {
            this.graph = new HashMap<T, SortedSet<T>>();
            this.orderedNodes = new ArrayList<T>();
        }
        
        public boolean addNode(final T node) {
            if (this.graph.containsKey(node)) {
                return false;
            }
            this.orderedNodes.add(node);
            this.graph.put(node, new TreeSet<T>(new Comparator<T>() {
                @Override
                public int compare(final T o1, final T o2) {
                    return DirectedGraph.this.orderedNodes.indexOf(o1) - DirectedGraph.this.orderedNodes.indexOf(o2);
                }
            }));
            return true;
        }
        
        public void addEdge(final T from, final T to) {
            if (!this.graph.containsKey(from) || !this.graph.containsKey(to)) {
                throw new NoSuchElementException("Missing nodes from graph");
            }
            this.graph.get(from).add(to);
        }
        
        public void removeEdge(final T from, final T to) {
            if (!this.graph.containsKey(from) || !this.graph.containsKey(to)) {
                throw new NoSuchElementException("Missing nodes from graph");
            }
            this.graph.get(from).remove(to);
        }
        
        public boolean edgeExists(final T from, final T to) {
            if (!this.graph.containsKey(from) || !this.graph.containsKey(to)) {
                throw new NoSuchElementException("Missing nodes from graph");
            }
            return this.graph.get(from).contains(to);
        }
        
        public Set<T> edgesFrom(final T from) {
            if (!this.graph.containsKey(from)) {
                throw new NoSuchElementException("Missing node from graph");
            }
            return (Set<T>)Collections.unmodifiableSortedSet((SortedSet<Object>)this.graph.get(from));
        }
        
        @Override
        public Iterator<T> iterator() {
            return this.orderedNodes.iterator();
        }
        
        public int size() {
            return this.graph.size();
        }
        
        public boolean isEmpty() {
            return this.graph.isEmpty();
        }
        
        @Override
        public String toString() {
            return this.graph.toString();
        }
    }
}



================================================
FILE: cpw/mods/fml/common/versioning/ArtifactVersion.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.versioning;

public interface ArtifactVersion extends Comparable<ArtifactVersion>
{
    String getLabel();
    
    String getVersionString();
    
    boolean containsVersion(final ArtifactVersion p0);
    
    String getRangeString();
}



================================================
FILE: cpw/mods/fml/common/versioning/ComparableVersion.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.versioning;

import java.util.Hashtable;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Properties;
import java.util.List;
import java.math.BigInteger;
import java.util.Stack;
import java.util.Locale;

public class ComparableVersion implements Comparable<ComparableVersion>
{
    private String value;
    private String canonical;
    private ListItem items;
    
    public ComparableVersion(final String version) {
        this.parseVersion(version);
    }
    
    public final void parseVersion(String version) {
        this.value = version;
        this.items = new ListItem();
        version = version.toLowerCase(Locale.ENGLISH);
        ListItem list = this.items;
        final Stack<Item> stack = new Stack<Item>();
        stack.push(list);
        boolean isDigit = false;
        int startIndex = 0;
        for (int i = 0; i < version.length(); ++i) {
            final char c = version.charAt(i);
            if (c == '.') {
                if (i == startIndex) {
                    ((ArrayList<IntegerItem>)list).add(IntegerItem.ZERO);
                }
                else {
                    list.add(parseItem(isDigit, version.substring(startIndex, i)));
                }
                startIndex = i + 1;
            }
            else if (c == '-') {
                if (i == startIndex) {
                    ((ArrayList<IntegerItem>)list).add(IntegerItem.ZERO);
                }
                else {
                    list.add(parseItem(isDigit, version.substring(startIndex, i)));
                }
                startIndex = i + 1;
                if (isDigit) {
                    list.normalize();
                    if (i + 1 < version.length() && Character.isDigit(version.charAt(i + 1))) {
                        ((ArrayList<ListItem>)list).add(list = new ListItem());
                        stack.push(list);
                    }
                }
            }
            else if (Character.isDigit(c)) {
                if (!isDigit && i > startIndex) {
                    ((ArrayList<StringItem>)list).add(new StringItem(version.substring(startIndex, i), true));
                    startIndex = i;
                }
                isDigit = true;
            }
            else {
                if (isDigit && i > startIndex) {
                    list.add(parseItem(true, version.substring(startIndex, i)));
                    startIndex = i;
                }
                isDigit = false;
            }
        }
        if (version.length() > startIndex) {
            list.add(parseItem(isDigit, version.substring(startIndex)));
        }
        while (!stack.isEmpty()) {
            list = stack.pop();
            list.normalize();
        }
        this.canonical = this.items.toString();
    }
    
    private static Item parseItem(final boolean isDigit, final String buf) {
        return isDigit ? new IntegerItem(buf) : new StringItem(buf, false);
    }
    
    @Override
    public int compareTo(final ComparableVersion o) {
        return this.items.compareTo(o.items);
    }
    
    @Override
    public String toString() {
        return this.value;
    }
    
    @Override
    public boolean equals(final Object o) {
        return o instanceof ComparableVersion && this.canonical.equals(((ComparableVersion)o).canonical);
    }
    
    @Override
    public int hashCode() {
        return this.canonical.hashCode();
    }
    
    private static class IntegerItem implements Item
    {
        private static final BigInteger BigInteger_ZERO;
        private final BigInteger value;
        public static final IntegerItem ZERO;
        
        private IntegerItem() {
            this.value = IntegerItem.BigInteger_ZERO;
        }
        
        public IntegerItem(final String str) {
            this.value = new BigInteger(str);
        }
        
        @Override
        public int getType() {
            return 0;
        }
        
        @Override
        public boolean isNull() {
            return IntegerItem.BigInteger_ZERO.equals(this.value);
        }
        
        @Override
        public int compareTo(final Item item) {
            if (item == null) {
                return IntegerItem.BigInteger_ZERO.equals(this.value) ? 0 : 1;
            }
            switch (item.getType()) {
                case 0: {
                    return this.value.compareTo(((IntegerItem)item).value);
                }
                case 1: {
                    return 1;
                }
                case 2: {
                    return 1;
                }
                default: {
                    throw new RuntimeException("invalid item: " + item.getClass());
                }
            }
        }
        
        @Override
        public String toString() {
            return this.value.toString();
        }
        
        static {
            BigInteger_ZERO = new BigInteger("0");
            ZERO = new IntegerItem();
        }
    }
    
    private static class StringItem implements Item
    {
        private static final String[] QUALIFIERS;
        private static final List<String> _QUALIFIERS;
        private static final Properties ALIASES;
        private static final String RELEASE_VERSION_INDEX;
        private String value;
        
        public StringItem(String value, final boolean followedByDigit) {
            if (followedByDigit && value.length() == 1) {
                switch (value.charAt(0)) {
                    case 'a': {
                        value = "alpha";
                        break;
                    }
                    case 'b': {
                        value = "beta";
                        break;
                    }
                    case 'm': {
                        value = "milestone";
                        break;
                    }
                }
            }
            this.value = StringItem.ALIASES.getProperty(value, value);
        }
        
        @Override
        public int getType() {
            return 1;
        }
        
        @Override
        public boolean isNull() {
            return comparableQualifier(this.value).compareTo(StringItem.RELEASE_VERSION_INDEX) == 0;
        }
        
        public static String comparableQualifier(final String qualifier) {
            final int i = StringItem._QUALIFIERS.indexOf(qualifier);
            return (i == -1) ? (StringItem._QUALIFIERS.size() + "-" + qualifier) : String.valueOf(i);
        }
        
        @Override
        public int compareTo(final Item item) {
            if (item == null) {
                return comparableQualifier(this.value).compareTo(StringItem.RELEASE_VERSION_INDEX);
            }
            switch (item.getType()) {
                case 0: {
                    return -1;
                }
                case 1: {
                    return comparableQualifier(this.value).compareTo(comparableQualifier(((StringItem)item).value));
                }
                case 2: {
                    return -1;
                }
                default: {
                    throw new RuntimeException("invalid item: " + item.getClass());
                }
            }
        }
        
        @Override
        public String toString() {
            return this.value;
        }
        
        static {
            QUALIFIERS = new String[] { "alpha", "beta", "milestone", "rc", "snapshot", "", "sp" };
            _QUALIFIERS = Arrays.asList(StringItem.QUALIFIERS);
            ((Hashtable<String, String>)(ALIASES = new Properties())).put("ga", "");
            ((Hashtable<String, String>)StringItem.ALIASES).put("final", "");
            ((Hashtable<String, String>)StringItem.ALIASES).put("cr", "rc");
            RELEASE_VERSION_INDEX = String.valueOf(StringItem._QUALIFIERS.indexOf(""));
        }
    }
    
    private static class ListItem extends ArrayList<Item> implements Item
    {
        @Override
        public int getType() {
            return 2;
        }
        
        @Override
        public boolean isNull() {
            return this.size() == 0;
        }
        
        void normalize() {
            final ListIterator<Item> iterator = this.listIterator(this.size());
            while (iterator.hasPrevious()) {
                final Item item = iterator.previous();
                if (!item.isNull()) {
                    break;
                }
                iterator.remove();
            }
        }
        
        @Override
        public int compareTo(final Item item) {
            if (item == null) {
                if (this.size() == 0) {
                    return 0;
                }
                final Item first = this.get(0);
                return first.compareTo(null);
            }
            else {
                switch (item.getType()) {
                    case 0: {
                        return -1;
                    }
                    case 1: {
                        return 1;
                    }
                    case 2: {
                        final Iterator<Item> left = this.iterator();
                        final Iterator<Item> right = ((ListItem)item).iterator();
                        while (left.hasNext() || right.hasNext()) {
                            final Item l = left.hasNext() ? left.next() : null;
                            final Item r = right.hasNext() ? right.next() : null;
                            final int result = (l == null) ? (-1 * r.compareTo(l)) : l.compareTo(r);
                            if (result != 0) {
                                return result;
                            }
                        }
                        return 0;
                    }
                    default: {
                        throw new RuntimeException("invalid item: " + item.getClass());
                    }
                }
            }
        }
        
        @Override
        public String toString() {
            final StringBuilder buffer = new StringBuilder("(");
            final Iterator<Item> iter = this.iterator();
            while (iter.hasNext()) {
                buffer.append(iter.next());
                if (iter.hasNext()) {
                    buffer.append(',');
                }
            }
            buffer.append(')');
            return buffer.toString();
        }
    }
    
    private interface Item
    {
        public static final int INTEGER_ITEM = 0;
        public static final int STRING_ITEM = 1;
        public static final int LIST_ITEM = 2;
        
        int compareTo(final Item p0);
        
        int getType();
        
        boolean isNull();
    }
}



================================================
FILE: cpw/mods/fml/common/versioning/DefaultArtifactVersion.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.versioning;

public class DefaultArtifactVersion implements ArtifactVersion
{
    private ComparableVersion comparableVersion;
    private String label;
    private boolean unbounded;
    private VersionRange range;
    
    public DefaultArtifactVersion(final String versionNumber) {
        this.comparableVersion = new ComparableVersion(versionNumber);
        this.range = VersionRange.createFromVersion(versionNumber, this);
    }
    
    public DefaultArtifactVersion(final String label, final VersionRange range) {
        this.label = label;
        this.range = range;
    }
    
    public DefaultArtifactVersion(final String label, final String version) {
        this(version);
        this.label = label;
    }
    
    public DefaultArtifactVersion(final String string, final boolean unbounded) {
        this.label = string;
        this.unbounded = true;
    }
    
    @Override
    public boolean equals(final Object obj) {
        return ((DefaultArtifactVersion)obj).containsVersion(this);
    }
    
    @Override
    public int compareTo(final ArtifactVersion o) {
        return this.unbounded ? 0 : this.comparableVersion.compareTo(((DefaultArtifactVersion)o).comparableVersion);
    }
    
    @Override
    public String getLabel() {
        return this.label;
    }
    
    @Override
    public boolean containsVersion(final ArtifactVersion source) {
        return source.getLabel().equals(this.getLabel()) && (this.unbounded || (this.range != null && this.range.containsVersion(source)));
    }
    
    @Override
    public String getVersionString() {
        return (this.comparableVersion == null) ? "unknown" : this.comparableVersion.toString();
    }
    
    @Override
    public String getRangeString() {
        return (this.range == null) ? "any" : this.range.toString();
    }
    
    @Override
    public String toString() {
        return (this.label == null) ? this.comparableVersion.toString() : (this.label + (this.unbounded ? "" : ("@" + this.range)));
    }
    
    public VersionRange getRange() {
        return this.range;
    }
}



================================================
FILE: cpw/mods/fml/common/versioning/InvalidVersionSpecificationException.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.versioning;

public class InvalidVersionSpecificationException extends Exception
{
    public InvalidVersionSpecificationException(final String message) {
        super(message);
    }
}



================================================
FILE: cpw/mods/fml/common/versioning/Restriction.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.versioning;

public class Restriction
{
    private final ArtifactVersion lowerBound;
    private final boolean lowerBoundInclusive;
    private final ArtifactVersion upperBound;
    private final boolean upperBoundInclusive;
    public static final Restriction EVERYTHING;
    
    public Restriction(final ArtifactVersion lowerBound, final boolean lowerBoundInclusive, final ArtifactVersion upperBound, final boolean upperBoundInclusive) {
        this.lowerBound = lowerBound;
        this.lowerBoundInclusive = lowerBoundInclusive;
        this.upperBound = upperBound;
        this.upperBoundInclusive = upperBoundInclusive;
    }
    
    public ArtifactVersion getLowerBound() {
        return this.lowerBound;
    }
    
    public boolean isLowerBoundInclusive() {
        return this.lowerBoundInclusive;
    }
    
    public ArtifactVersion getUpperBound() {
        return this.upperBound;
    }
    
    public boolean isUpperBoundInclusive() {
        return this.upperBoundInclusive;
    }
    
    public boolean containsVersion(final ArtifactVersion version) {
        if (this.lowerBound != null) {
            final int comparison = this.lowerBound.compareTo(version);
            if (comparison == 0 && !this.lowerBoundInclusive) {
                return false;
            }
            if (comparison > 0) {
                return false;
            }
        }
        if (this.upperBound != null) {
            final int comparison = this.upperBound.compareTo(version);
            if (comparison == 0 && !this.upperBoundInclusive) {
                return false;
            }
            if (comparison < 0) {
                return false;
            }
        }
        return true;
    }
    
    @Override
    public int hashCode() {
        int result = 13;
        if (this.lowerBound == null) {
            ++result;
        }
        else {
            result += this.lowerBound.hashCode();
        }
        result *= (this.lowerBoundInclusive ? 1 : 2);
        if (this.upperBound == null) {
            result -= 3;
        }
        else {
            result -= this.upperBound.hashCode();
        }
        result *= (this.upperBoundInclusive ? 2 : 3);
        return result;
    }
    
    @Override
    public boolean equals(final Object other) {
        if (this == other) {
            return true;
        }
        if (!(other instanceof Restriction)) {
            return false;
        }
        final Restriction restriction = (Restriction)other;
        if (this.lowerBound != null) {
            if (!this.lowerBound.equals(restriction.lowerBound)) {
                return false;
            }
        }
        else if (restriction.lowerBound != null) {
            return false;
        }
        if (this.lowerBoundInclusive != restriction.lowerBoundInclusive) {
            return false;
        }
        if (this.upperBound != null) {
            if (!this.upperBound.equals(restriction.upperBound)) {
                return false;
            }
        }
        else if (restriction.upperBound != null) {
            return false;
        }
        return this.upperBoundInclusive == restriction.upperBoundInclusive;
    }
    
    @Override
    public String toString() {
        final StringBuilder buf = new StringBuilder();
        buf.append(this.isLowerBoundInclusive() ? "[" : "(");
        if (this.getLowerBound() != null) {
            buf.append(this.getLowerBound().toString());
        }
        buf.append(",");
        if (this.getUpperBound() != null) {
            buf.append(this.getUpperBound().toString());
        }
        buf.append(this.isUpperBoundInclusive() ? "]" : ")");
        return buf.toString();
    }
    
    static {
        EVERYTHING = new Restriction(null, false, null, false);
    }
}



================================================
FILE: cpw/mods/fml/common/versioning/VersionParser.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.versioning;

import cpw.mods.fml.common.LoaderException;
import cpw.mods.fml.common.FMLLog;
import java.util.logging.Level;
import java.util.List;
import com.google.common.collect.Lists;
import com.google.common.base.Strings;
import com.google.common.base.Splitter;

public class VersionParser
{
    private static final Splitter SEPARATOR;
    
    public static ArtifactVersion parseVersionReference(final String labelledRef) {
        if (Strings.isNullOrEmpty(labelledRef)) {
            throw new RuntimeException(String.format("Empty reference %s", labelledRef));
        }
        final List<String> parts = Lists.newArrayList(VersionParser.SEPARATOR.split((CharSequence)labelledRef));
        if (parts.size() > 2) {
            throw new RuntimeException(String.format("Invalid versioned reference %s", labelledRef));
        }
        if (parts.size() == 1) {
            return new DefaultArtifactVersion(parts.get(0), true);
        }
        return new DefaultArtifactVersion(parts.get(0), parseRange(parts.get(1)));
    }
    
    public static boolean satisfies(final ArtifactVersion target, final ArtifactVersion source) {
        return target.containsVersion(source);
    }
    
    public static VersionRange parseRange(final String range) {
        try {
            return VersionRange.createFromVersionSpec(range);
        }
        catch (final InvalidVersionSpecificationException e) {
            FMLLog.log(Level.SEVERE, e, "Unable to parse a version range specification successfully %s", range);
            throw new LoaderException(e);
        }
    }
    
    static {
        SEPARATOR = Splitter.on('@').omitEmptyStrings().trimResults();
    }
}



================================================
FILE: cpw/mods/fml/common/versioning/VersionRange.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.common.versioning;

import com.google.common.base.Joiner;
import java.util.Iterator;
import java.util.Collections;
import java.util.Collection;
import java.util.ArrayList;
import java.util.List;

public class VersionRange
{
    private final ArtifactVersion recommendedVersion;
    private final List<Restriction> restrictions;
    
    private VersionRange(final ArtifactVersion recommendedVersion, final List<Restriction> restrictions) {
        this.recommendedVersion = recommendedVersion;
        this.restrictions = restrictions;
    }
    
    public ArtifactVersion getRecommendedVersion() {
        return this.recommendedVersion;
    }
    
    public List<Restriction> getRestrictions() {
        return this.restrictions;
    }
    
    public VersionRange cloneOf() {
        List<Restriction> copiedRestrictions = null;
        if (this.restrictions != null) {
            copiedRestrictions = new ArrayList<Restriction>();
            if (!this.restrictions.isEmpty()) {
                copiedRestrictions.addAll(this.restrictions);
            }
        }
        return new VersionRange(this.recommendedVersion, copiedRestrictions);
    }
    
    public static VersionRange createFromVersionSpec(final String spec) throws InvalidVersionSpecificationException {
        if (spec == null) {
            return null;
        }
        final List<Restriction> restrictions = new ArrayList<Restriction>();
        String process = spec;
        ArtifactVersion version = null;
        ArtifactVersion upperBound = null;
        ArtifactVersion lowerBound = null;
        while (process.startsWith("[") || process.startsWith("(")) {
            final int index1 = process.indexOf(")");
            final int index2 = process.indexOf("]");
            int index3;
            if (((index3 = index2) < 0 || index1 < index2) && index1 >= 0) {
                index3 = index1;
            }
            if (index3 < 0) {
                throw new InvalidVersionSpecificationException("Unbounded range: " + spec);
            }
            final Restriction restriction = parseRestriction(process.substring(0, index3 + 1));
            if (lowerBound == null) {
                lowerBound = restriction.getLowerBound();
            }
            if (upperBound != null && (restriction.getLowerBound() == null || restriction.getLowerBound().compareTo(upperBound) < 0)) {
                throw new InvalidVersionSpecificationException("Ranges overlap: " + spec);
            }
            restrictions.add(restriction);
            upperBound = restriction.getUpperBound();
            process = process.substring(index3 + 1).trim();
            if (process.length() <= 0 || !process.startsWith(",")) {
                continue;
            }
            process = process.substring(1).trim();
        }
        if (process.length() > 0) {
            if (restrictions.size() > 0) {
                throw new InvalidVersionSpecificationException("Only fully-qualified sets allowed in multiple set scenario: " + spec);
            }
            version = new DefaultArtifactVersion(process);
            restrictions.add(Restriction.EVERYTHING);
        }
        return new VersionRange(version, restrictions);
    }
    
    private static Restriction parseRestriction(final String spec) throws InvalidVersionSpecificationException {
        final boolean lowerBoundInclusive = spec.startsWith("[");
        final boolean upperBoundInclusive = spec.endsWith("]");
        final String process = spec.substring(1, spec.length() - 1).trim();
        final int index = process.indexOf(",");
        Restriction restriction;
        if (index < 0) {
            if (!lowerBoundInclusive || !upperBoundInclusive) {
                throw new InvalidVersionSpecificationException("Single version must be surrounded by []: " + spec);
            }
            final ArtifactVersion version = new DefaultArtifactVersion(process);
            restriction = new Restriction(version, lowerBoundInclusive, version, upperBoundInclusive);
        }
        else {
            final String lowerBound = process.substring(0, index).trim();
            final String upperBound = process.substring(index + 1).trim();
            if (lowerBound.equals(upperBound)) {
                throw new InvalidVersionSpecificationException("Range cannot have identical boundaries: " + spec);
            }
            ArtifactVersion lowerVersion = null;
            if (lowerBound.length() > 0) {
                lowerVersion = new DefaultArtifactVersion(lowerBound);
            }
            ArtifactVersion upperVersion = null;
            if (upperBound.length() > 0) {
                upperVersion = new DefaultArtifactVersion(upperBound);
            }
            if (upperVersion != null && lowerVersion != null && upperVersion.compareTo(lowerVersion) < 0) {
                throw new InvalidVersionSpecificationException("Range defies version ordering: " + spec);
            }
            restriction = new Restriction(lowerVersion, lowerBoundInclusive, upperVersion, upperBoundInclusive);
        }
        return restriction;
    }
    
    public static VersionRange createFromVersion(final String version, ArtifactVersion existing) {
        final List<Restriction> restrictions = Collections.emptyList();
        if (existing == null) {
            existing = new DefaultArtifactVersion(version);
        }
        return new VersionRange(existing, restrictions);
    }
    
    public VersionRange restrict(final VersionRange restriction) {
        final List<Restriction> r1 = this.restrictions;
        final List<Restriction> r2 = restriction.restrictions;
        List<Restriction> restrictions;
        if (r1.isEmpty() || r2.isEmpty()) {
            restrictions = Collections.emptyList();
        }
        else {
            restrictions = this.intersection(r1, r2);
        }
        ArtifactVersion version = null;
        if (restrictions.size() > 0) {
            for (final Restriction r3 : restrictions) {
                if (this.recommendedVersion != null && r3.containsVersion(this.recommendedVersion)) {
                    version = this.recommendedVersion;
                    break;
                }
                if (version != null || restriction.getRecommendedVersion() == null || !r3.containsVersion(restriction.getRecommendedVersion())) {
                    continue;
                }
                version = restriction.getRecommendedVersion();
            }
        }
        else if (this.recommendedVersion != null) {
            version = this.recommendedVersion;
        }
        else if (restriction.recommendedVersion != null) {
            version = restriction.recommendedVersion;
        }
        return new VersionRange(version, restrictions);
    }
    
    private List<Restriction> intersection(final List<Restriction> r1, final List<Restriction> r2) {
        final List<Restriction> restrictions = new ArrayList<Restriction>(r1.size() + r2.size());
        final Iterator<Restriction> i1 = r1.iterator();
        final Iterator<Restriction> i2 = r2.iterator();
        Restriction res1 = i1.next();
        Restriction res2 = i2.next();
        boolean done = false;
        while (!done) {
            if (res1.getLowerBound() == null || res2.getUpperBound() == null || res1.getLowerBound().compareTo(res2.getUpperBound()) <= 0) {
                if (res1.getUpperBound() == null || res2.getLowerBound() == null || res1.getUpperBound().compareTo(res2.getLowerBound()) >= 0) {
                    ArtifactVersion lower;
                    boolean lowerInclusive;
                    if (res1.getLowerBound() == null) {
                        lower = res2.getLowerBound();
                        lowerInclusive = res2.isLowerBoundInclusive();
                    }
                    else if (res2.getLowerBound() == null) {
                        lower = res1.getLowerBound();
                        lowerInclusive = res1.isLowerBoundInclusive();
                    }
                    else {
                        final int comparison = res1.getLowerBound().compareTo(res2.getLowerBound());
                        if (comparison < 0) {
                            lower = res2.getLowerBound();
                            lowerInclusive = res2.isLowerBoundInclusive();
                        }
                        else if (comparison == 0) {
                            lower = res1.getLowerBound();
                            lowerInclusive = (res1.isLowerBoundInclusive() && res2.isLowerBoundInclusive());
                        }
                        else {
                            lower = res1.getLowerBound();
                            lowerInclusive = res1.isLowerBoundInclusive();
                        }
                    }
                    ArtifactVersion upper;
                    boolean upperInclusive;
                    if (res1.getUpperBound() == null) {
                        upper = res2.getUpperBound();
                        upperInclusive = res2.isUpperBoundInclusive();
                    }
                    else if (res2.getUpperBound() == null) {
                        upper = res1.getUpperBound();
                        upperInclusive = res1.isUpperBoundInclusive();
                    }
                    else {
                        final int comparison = res1.getUpperBound().compareTo(res2.getUpperBound());
                        if (comparison < 0) {
                            upper = res1.getUpperBound();
                            upperInclusive = res1.isUpperBoundInclusive();
                        }
                        else if (comparison == 0) {
                            upper = res1.getUpperBound();
                            upperInclusive = (res1.isUpperBoundInclusive() && res2.isUpperBoundInclusive());
                        }
                        else {
                            upper = res2.getUpperBound();
                            upperInclusive = res2.isUpperBoundInclusive();
                        }
                    }
                    if (lower == null || upper == null || lower.compareTo(upper) != 0) {
                        restrictions.add(new Restriction(lower, lowerInclusive, upper, upperInclusive));
                    }
                    else if (lowerInclusive && upperInclusive) {
                        restrictions.add(new Restriction(lower, lowerInclusive, upper, upperInclusive));
                    }
                    if (upper == res2.getUpperBound()) {
                        if (i2.hasNext()) {
                            res2 = i2.next();
                        }
                        else {
                            done = true;
                        }
                    }
                    else if (i1.hasNext()) {
                        res1 = i1.next();
                    }
                    else {
                        done = true;
                    }
                }
                else if (i1.hasNext()) {
                    res1 = i1.next();
                }
                else {
                    done = true;
                }
            }
            else if (i2.hasNext()) {
                res2 = i2.next();
            }
            else {
                done = true;
            }
        }
        return restrictions;
    }
    
    @Override
    public String toString() {
        if (this.recommendedVersion != null) {
            return this.recommendedVersion.toString();
        }
        return Joiner.on(',').join((Iterable)this.restrictions);
    }
    
    public ArtifactVersion matchVersion(final List<ArtifactVersion> versions) {
        ArtifactVersion matched = null;
        for (final ArtifactVersion version : versions) {
            if (this.containsVersion(version) && (matched == null || version.compareTo(matched) > 0)) {
                matched = version;
            }
        }
        return matched;
    }
    
    public boolean containsVersion(final ArtifactVersion version) {
        for (final Restriction restriction : this.restrictions) {
            if (restriction.containsVersion(version)) {
                return true;
            }
        }
        return false;
    }
    
    public boolean hasRestrictions() {
        return !this.restrictions.isEmpty() && this.recommendedVersion == null;
    }
    
    @Override
    public boolean equals(final Object obj) {
        if (this == obj) {
            return true;
        }
        if (!(obj instanceof VersionRange)) {
            return false;
        }
        final VersionRange other = (VersionRange)obj;
        boolean equals = this.recommendedVersion == other.recommendedVersion || (this.recommendedVersion != null && this.recommendedVersion.equals(other.recommendedVersion));
        equals &= (this.restrictions == other.restrictions || (this.restrictions != null && this.restrictions.equals(other.restrictions)));
        return equals;
    }
    
    @Override
    public int hashCode() {
        int hash = 7;
        hash = 31 * hash + ((this.recommendedVersion == null) ? 0 : this.recommendedVersion.hashCode());
        hash = 31 * hash + ((this.restrictions == null) ? 0 : this.restrictions.hashCode());
        return hash;
    }
    
    public boolean isUnboundedAbove() {
        return this.restrictions.size() == 1 && this.restrictions.get(0).getUpperBound() == null && !this.restrictions.get(0).isUpperBoundInclusive();
    }
    
    public String getLowerBoundString() {
        return (this.restrictions.size() == 1) ? this.restrictions.get(0).getLowerBound().getVersionString() : "";
    }
}



================================================
FILE: cpw/mods/fml/relauncher/CoreModManager.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.relauncher;

import java.util.HashMap;
import java.util.Comparator;
import net.minecraft.launchwrapper.ITweaker;
import cpw.mods.fml.common.launcher.FMLInjectionAndSortingTweaker;
import net.minecraft.launchwrapper.Launch;
import java.util.Iterator;
import cpw.mods.fml.common.FMLLog;
import com.google.common.collect.Maps;
import cpw.mods.fml.common.toposort.TopologicalSort;
import com.google.common.collect.Lists;
import java.net.URL;
import java.net.URLClassLoader;
import java.net.MalformedURLException;
import com.google.common.primitives.Ints;
import com.google.common.base.Strings;
import java.util.jar.JarFile;
import java.util.Arrays;
import com.google.common.collect.ObjectArrays;
import java.io.FilenameFilter;
import java.util.ArrayList;
import com.google.common.base.Throwables;
import java.util.logging.Level;
import java.io.IOException;
import net.minecraft.launchwrapper.LaunchClassLoader;
import java.util.Map;
import java.lang.reflect.Method;
import java.io.File;
import cpw.mods.fml.common.launcher.FMLTweaker;
import java.util.List;
import java.util.jar.Attributes;

public class CoreModManager
{
    private static final Attributes.Name COREMODCONTAINSFMLMOD;
    private static String[] rootPlugins;
    private static List<String> loadedCoremods;
    private static List<FMLPluginWrapper> loadPlugins;
    private static boolean deobfuscatedEnvironment;
    private static FMLTweaker tweaker;
    private static File mcDir;
    private static List<String> reparsedCoremods;
    private static Method ADDURL;
    private static Map<String, Integer> tweakSorting;
    
    public static void handleLaunch(final File mcDir, final LaunchClassLoader classLoader, final FMLTweaker tweaker) {
        CoreModManager.mcDir = mcDir;
        CoreModManager.tweaker = tweaker;
        try {
            final byte[] bs = classLoader.getClassBytes("net.minecraft.world.World");
            if (bs != null) {
                FMLRelaunchLog.info("Managed to load a deobfuscated Minecraft name- we are in a deobfuscated environment. Skipping runtime deobfuscation", new Object[0]);
                CoreModManager.deobfuscatedEnvironment = true;
            }
        }
        catch (final IOException ex) {}
        if (!CoreModManager.deobfuscatedEnvironment) {
            FMLRelaunchLog.fine("Enabling runtime deobfuscation", new Object[0]);
        }
        tweaker.injectCascadingTweak("cpw.mods.fml.common.launcher.FMLInjectionAndSortingTweaker");
        try {
            classLoader.registerTransformer("cpw.mods.fml.common.asm.transformers.PatchingTransformer");
        }
        catch (final Exception e) {
            FMLRelaunchLog.log(Level.SEVERE, e, "The patch transformer failed to load! This is critical, loading cannot continue!", new Object[0]);
            throw Throwables.propagate((Throwable)e);
        }
        CoreModManager.loadPlugins = new ArrayList<FMLPluginWrapper>();
        for (final String rootPluginName : CoreModManager.rootPlugins) {
            loadCoreMod(classLoader, rootPluginName, new File(FMLTweaker.getJarLocation()));
        }
        if (CoreModManager.loadPlugins.isEmpty()) {
            throw new RuntimeException("A fatal error has occured - no valid fml load plugin was found - this is a completely corrupt FML installation.");
        }
        FMLRelaunchLog.fine("All fundamental core mods are successfully located", new Object[0]);
        final String commandLineCoremods = System.getProperty("fml.coreMods.load", "");
        for (final String coreModClassName : commandLineCoremods.split(",")) {
            if (!coreModClassName.isEmpty()) {
                FMLRelaunchLog.info("Found a command line coremod : %s", coreModClassName);
                loadCoreMod(classLoader, coreModClassName, null);
            }
        }
        discoverCoreMods(mcDir, classLoader);
    }
    
    private static void discoverCoreMods(final File mcDir, final LaunchClassLoader classLoader) {
        FMLRelaunchLog.fine("Discovering coremods", new Object[0]);
        final File coreMods = setupCoreModDir(mcDir);
        final FilenameFilter ff = new FilenameFilter() {
            @Override
            public boolean accept(final File dir, final String name) {
                return name.endsWith(".jar");
            }
        };
        File[] coreModList = coreMods.listFiles(ff);
        final File versionedModDir = new File(coreMods, FMLInjectionData.mccversion);
        if (versionedModDir.isDirectory()) {
            final File[] versionedCoreMods = versionedModDir.listFiles(ff);
            coreModList = (File[])ObjectArrays.concat((Object[])coreModList, (Object[])versionedCoreMods, (Class)File.class);
        }
        Arrays.sort(coreModList);
        for (final File coreMod : coreModList) {
            FMLRelaunchLog.fine("Examining for coremod candidacy %s", coreMod.getName());
            JarFile jar = null;
            Attributes mfAttributes = null;
            try {
                jar = new JarFile(coreMod);
                if (jar.getManifest() == null) {}
                mfAttributes = jar.getManifest().getMainAttributes();
            }
            catch (final IOException ioe) {
                FMLRelaunchLog.log(Level.SEVERE, ioe, "Unable to read the jar file %s - ignoring", coreMod.getName());
            }
            finally {
                if (jar != null) {
                    try {
                        jar.close();
                    }
                    catch (final IOException ex) {}
                }
            }
            final String cascadedTweaker = mfAttributes.getValue("TweakClass");
            Label_0508: {
                if (cascadedTweaker != null) {
                    FMLRelaunchLog.info("Loading tweaker %s from %s", cascadedTweaker, coreMod.getName());
                    Integer sortOrder = Ints.tryParse(Strings.nullToEmpty(mfAttributes.getValue("TweakOrder")));
                    sortOrder = ((sortOrder == null) ? Integer.valueOf(0) : sortOrder);
                    handleCascadingTweak(coreMod, jar, cascadedTweaker, classLoader, sortOrder);
                    CoreModManager.loadedCoremods.add(coreMod.getName());
                }
                else {
                    final String fmlCorePlugin = mfAttributes.getValue("FMLCorePlugin");
                    if (fmlCorePlugin == null) {
                        FMLRelaunchLog.fine("Not found coremod data in %s", coreMod.getName());
                    }
                    else {
                        try {
                            classLoader.addURL(coreMod.toURI().toURL());
                            if (!mfAttributes.containsKey(CoreModManager.COREMODCONTAINSFMLMOD)) {
                                FMLRelaunchLog.finest("Adding %s to the list of known coremods, it will not be examined again", coreMod.getName());
                                CoreModManager.loadedCoremods.add(coreMod.getName());
                            }
                            else {
                                FMLRelaunchLog.finest("Found FMLCorePluginContainsFMLMod marker in %s, it will be examined later for regular @Mod instances", coreMod.getName());
                                CoreModManager.reparsedCoremods.add(coreMod.getName());
                            }
                        }
                        catch (final MalformedURLException e) {
                            FMLRelaunchLog.log(Level.SEVERE, e, "Unable to convert file into a URL. weird", new Object[0]);
                            break Label_0508;
                        }
                        loadCoreMod(classLoader, fmlCorePlugin, coreMod);
                    }
                }
            }
        }
    }
    
    private static void handleCascadingTweak(final File coreMod, final JarFile jar, final String cascadedTweaker, final LaunchClassLoader classLoader, final Integer sortingOrder) {
        try {
            if (CoreModManager.ADDURL == null) {
                (CoreModManager.ADDURL = URLClassLoader.class.getDeclaredMethod("addURL", URL.class)).setAccessible(true);
            }
            CoreModManager.ADDURL.invoke(classLoader.getClass().getClassLoader(), coreMod.toURI().toURL());
            classLoader.addURL(coreMod.toURI().toURL());
            CoreModManager.tweaker.injectCascadingTweak(cascadedTweaker);
            CoreModManager.tweakSorting.put(cascadedTweaker, sortingOrder);
        }
        catch (final Exception e) {
            FMLRelaunchLog.log(Level.INFO, e, "There was a problem trying to load the mod dir tweaker %s", coreMod.getAbsolutePath());
        }
    }
    
    private static void injectTweakWrapper(final FMLPluginWrapper wrapper) {
        CoreModManager.loadPlugins.add(wrapper);
    }
    
    private static File setupCoreModDir(final File mcDir) {
        File coreModDir = new File(mcDir, "mods");
        try {
            coreModDir = coreModDir.getCanonicalFile();
        }
        catch (final IOException e) {
            throw new RuntimeException(String.format("Unable to canonicalize the coremod dir at %s", mcDir.getName()), e);
        }
        if (!coreModDir.exists()) {
            coreModDir.mkdir();
        }
        else if (coreModDir.exists() && !coreModDir.isDirectory()) {
            throw new RuntimeException(String.format("Found a coremod file in %s that's not a directory", mcDir.getName()));
        }
        return coreModDir;
    }
    
    public static List<String> getLoadedCoremods() {
        return CoreModManager.loadedCoremods;
    }
    
    public static List<String> getReparseableCoremods() {
        return CoreModManager.reparsedCoremods;
    }
    
    private static FMLPluginWrapper loadCoreMod(final LaunchClassLoader classLoader, final String coreModClass, final File location) {
        String coreModName = coreModClass.substring(coreModClass.lastIndexOf(46) + 1);
        try {
            FMLRelaunchLog.fine("Instantiating coremod class %s", coreModName);
            classLoader.addTransformerExclusion(coreModClass);
            final Class<?> coreModClazz = Class.forName(coreModClass, true, (ClassLoader)classLoader);
            final IFMLLoadingPlugin.Name coreModNameAnn = coreModClazz.getAnnotation(IFMLLoadingPlugin.Name.class);
            if (coreModNameAnn != null && !Strings.isNullOrEmpty(coreModNameAnn.value())) {
                coreModName = coreModNameAnn.value();
                FMLRelaunchLog.finest("coremod named %s is loading", coreModName);
            }
            final IFMLLoadingPlugin.MCVersion requiredMCVersion = coreModClazz.getAnnotation(IFMLLoadingPlugin.MCVersion.class);
            if (!Arrays.asList(CoreModManager.rootPlugins).contains(coreModClass) && (requiredMCVersion == null || Strings.isNullOrEmpty(requiredMCVersion.value()))) {
                FMLRelaunchLog.log(Level.WARNING, "The coremod %s does not have a MCVersion annotation, it may cause issues with this version of Minecraft", coreModClass);
            }
            else {
                if (requiredMCVersion != null && !FMLInjectionData.mccversion.equals(requiredMCVersion.value())) {
                    FMLRelaunchLog.log(Level.SEVERE, "The coremod %s is requesting minecraft version %s and minecraft is %s. It will be ignored.", coreModClass, requiredMCVersion.value(), FMLInjectionData.mccversion);
                    return null;
                }
                if (requiredMCVersion != null) {
                    FMLRelaunchLog.log(Level.FINE, "The coremod %s requested minecraft version %s and minecraft is %s. It will be loaded.", coreModClass, requiredMCVersion.value(), FMLInjectionData.mccversion);
                }
            }
            final IFMLLoadingPlugin.TransformerExclusions trExclusions = coreModClazz.getAnnotation(IFMLLoadingPlugin.TransformerExclusions.class);
            if (trExclusions != null) {
                for (final String st : trExclusions.value()) {
                    classLoader.addTransformerExclusion(st);
                }
            }
            final IFMLLoadingPlugin.DependsOn deplist = coreModClazz.getAnnotation(IFMLLoadingPlugin.DependsOn.class);
            String[] dependencies = new String[0];
            if (deplist != null) {
                dependencies = deplist.value();
            }
            final IFMLLoadingPlugin.SortingIndex index = coreModClazz.getAnnotation(IFMLLoadingPlugin.SortingIndex.class);
            final int sortIndex = (index != null) ? index.value() : 0;
            final IFMLLoadingPlugin plugin = (IFMLLoadingPlugin)coreModClazz.newInstance();
            final FMLPluginWrapper wrap = new FMLPluginWrapper(coreModName, plugin, location, sortIndex, dependencies);
            CoreModManager.loadPlugins.add(wrap);
            FMLRelaunchLog.fine("Enqueued coremod %s", coreModName);
            return wrap;
        }
        catch (final ClassNotFoundException cnfe) {
            if (!Lists.newArrayList((Object[])CoreModManager.rootPlugins).contains(coreModClass)) {
                FMLRelaunchLog.log(Level.SEVERE, cnfe, "Coremod %s: Unable to class load the plugin %s", coreModName, coreModClass);
            }
            else {
                FMLRelaunchLog.fine("Skipping root plugin %s", coreModClass);
            }
        }
        catch (final ClassCastException cce) {
            FMLRelaunchLog.log(Level.SEVERE, cce, "Coremod %s: The plugin %s is not an implementor of IFMLLoadingPlugin", coreModName, coreModClass);
        }
        catch (final InstantiationException ie) {
            FMLRelaunchLog.log(Level.SEVERE, ie, "Coremod %s: The plugin class %s was not instantiable", coreModName, coreModClass);
        }
        catch (final IllegalAccessException iae) {
            FMLRelaunchLog.log(Level.SEVERE, iae, "Coremod %s: The plugin class %s was not accessible", coreModName, coreModClass);
        }
        return null;
    }
    
    private static void sortCoreMods() {
        final TopologicalSort.DirectedGraph<FMLPluginWrapper> sortGraph = new TopologicalSort.DirectedGraph<FMLPluginWrapper>();
        final Map<String, FMLPluginWrapper> pluginMap = Maps.newHashMap();
        for (final FMLPluginWrapper plug : CoreModManager.loadPlugins) {
            sortGraph.addNode(plug);
            pluginMap.put(plug.name, plug);
        }
        for (final FMLPluginWrapper plug : CoreModManager.loadPlugins) {
            for (final String dep : plug.predepends) {
                if (!pluginMap.containsKey(dep)) {
                    FMLRelaunchLog.log(Level.SEVERE, "Missing coremod dependency - the coremod %s depends on coremod %s which isn't present.", plug.name, dep);
                    throw new RuntimeException();
                }
                sortGraph.addEdge(plug, pluginMap.get(dep));
            }
        }
        try {
            CoreModManager.loadPlugins = TopologicalSort.topologicalSort(sortGraph);
            FMLRelaunchLog.fine("Sorted coremod list %s", CoreModManager.loadPlugins);
        }
        catch (final Exception e) {
            FMLLog.log(Level.SEVERE, e, "There was a problem performing the coremod sort", new Object[0]);
            throw Throwables.propagate((Throwable)e);
        }
    }
    
    public static void injectTransformers(final LaunchClassLoader classLoader) {
        Launch.blackboard.put("fml.deobfuscatedEnvironment", CoreModManager.deobfuscatedEnvironment);
        CoreModManager.tweaker.injectCascadingTweak("cpw.mods.fml.common.launcher.FMLDeobfTweaker");
        CoreModManager.tweakSorting.put("cpw.mods.fml.common.launcher.FMLDeobfTweaker", 1000);
    }
    
    public static void injectCoreModTweaks(final FMLInjectionAndSortingTweaker fmlInjectionAndSortingTweaker) {
        final List<ITweaker> tweakers = Launch.blackboard.get("Tweaks");
        tweakers.add(0, (ITweaker)fmlInjectionAndSortingTweaker);
        for (final FMLPluginWrapper wrapper : CoreModManager.loadPlugins) {
            tweakers.add((ITweaker)wrapper);
        }
    }
    
    public static void sortTweakList() {
        final List<ITweaker> tweakers = Launch.blackboard.get("Tweaks");
        sort(tweakers, new Comparator<ITweaker>() {
            @Override
            public int compare(final ITweaker o1, final ITweaker o2) {
                Integer first = null;
                Integer second = null;
                if (o1 instanceof FMLInjectionAndSortingTweaker) {
                    first = Integer.MIN_VALUE;
                }
                if (o2 instanceof FMLInjectionAndSortingTweaker) {
                    second = Integer.MIN_VALUE;
                }
                if (o1 instanceof FMLPluginWrapper) {
                    first = ((FMLPluginWrapper)o1).sortIndex;
                }
                else if (first == null) {
                    first = CoreModManager.tweakSorting.get(o1.getClass().getName());
                }
                if (o2 instanceof FMLPluginWrapper) {
                    second = ((FMLPluginWrapper)o2).sortIndex;
                }
                else if (second == null) {
                    second = CoreModManager.tweakSorting.get(o2.getClass().getName());
                }
                if (first == null) {
                    first = 0;
                }
                if (second == null) {
                    second = 0;
                }
                return Ints.saturatedCast(first - (long)second);
            }
        });
    }
    
    static {
        COREMODCONTAINSFMLMOD = new Attributes.Name("FMLCorePluginContainsFMLMod");
        CoreModManager.rootPlugins = new String[] { "cpw.mods.fml.relauncher.FMLCorePlugin", "net.minecraftforge.classloading.FMLForgePlugin" };
        CoreModManager.loadedCoremods = Lists.newArrayList();
        CoreModManager.reparsedCoremods = Lists.newArrayList();
        CoreModManager.tweakSorting = Maps.newHashMap();
    }
    
    public static void sort(final List arg0, final Comparator arg1) {
        final Object[] array = arg0.toArray(new Object[arg0.size()]);
        Arrays.sort(array, arg1);
        for (int i = 0; i < array.length; ++i) {
            arg0.set(i, array[i]);
        }
    }
    
    private static class FMLPluginWrapper implements ITweaker
    {
        public final String name;
        public final IFMLLoadingPlugin coreModInstance;
        public final List<String> predepends;
        public final File location;
        public final int sortIndex;
        
        public FMLPluginWrapper(final String name, final IFMLLoadingPlugin coreModInstance, final File location, final int sortIndex, final String... predepends) {
            this.name = name;
            this.coreModInstance = coreModInstance;
            this.location = location;
            this.sortIndex = sortIndex;
            this.predepends = Lists.newArrayList((Object[])predepends);
        }
        
        @Override
        public String toString() {
            return String.format("%s {%s}", this.name, this.predepends);
        }
        
        public void acceptOptions(final List<String> args, final File gameDir, final File assetsDir, final String profile) {
        }
        
        public void injectIntoClassLoader(final LaunchClassLoader classLoader) {
            FMLRelaunchLog.fine("Injecting coremod %s {%s} class transformers", this.name, this.coreModInstance.getClass().getName());
            if (this.coreModInstance.getASMTransformerClass() != null) {
                for (final String transformer : this.coreModInstance.getASMTransformerClass()) {
                    FMLRelaunchLog.finest("Registering transformer %s", transformer);
                    classLoader.registerTransformer(transformer);
                }
            }
            FMLRelaunchLog.fine("Injection complete", new Object[0]);
            FMLRelaunchLog.fine("Running coremod plugin for %s {%s}", this.name, this.coreModInstance.getClass().getName());
            final Map<String, Object> data = new HashMap<String, Object>();
            data.put("mcLocation", CoreModManager.mcDir);
            data.put("coremodList", CoreModManager.loadPlugins);
            data.put("runtimeDeobfuscationEnabled", !CoreModManager.deobfuscatedEnvironment);
            FMLRelaunchLog.fine("Running coremod plugin %s", this.name);
            data.put("coremodLocation", this.location);
            this.coreModInstance.injectData(data);
            final String setupClass = this.coreModInstance.getSetupClass();
            if (setupClass != null) {
                try {
                    final IFMLCallHook call = (IFMLCallHook)Class.forName(setupClass, true, (ClassLoader)classLoader).newInstance();
                    final Map<String, Object> callData = new HashMap<String, Object>();
                    callData.put("mcLocation", CoreModManager.mcDir);
                    callData.put("classLoader", classLoader);
                    callData.put("coremodLocation", this.location);
                    callData.put("deobfuscationFileName", FMLInjectionData.debfuscationDataName());
                    call.injectData(callData);
                    call.call();
                }
                catch (final Exception e) {
                    throw new RuntimeException(e);
                }
            }
            FMLRelaunchLog.fine("Coremod plugin class %s run successfully", this.coreModInstance.getClass().getSimpleName());
            final String modContainer = this.coreModInstance.getModContainerClass();
            if (modContainer != null) {
                FMLInjectionData.containers.add(modContainer);
            }
        }
        
        public String getLaunchTarget() {
            return "";
        }
        
        public String[] getLaunchArguments() {
            return new String[0];
        }
    }
}



================================================
FILE: cpw/mods/fml/relauncher/FMLCorePlugin.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.relauncher;

import java.util.Map;

public class FMLCorePlugin implements IFMLLoadingPlugin
{
    @Override
    public String[] getLibraryRequestClass() {
        return null;
    }
    
    @Override
    public String[] getASMTransformerClass() {
        return new String[] { "cpw.mods.fml.common.asm.transformers.AccessTransformer", "cpw.mods.fml.common.asm.transformers.MarkerTransformer", "cpw.mods.fml.common.asm.transformers.SideTransformer" };
    }
    
    @Override
    public String getModContainerClass() {
        return "cpw.mods.fml.common.FMLDummyContainer";
    }
    
    @Override
    public String getSetupClass() {
        return "cpw.mods.fml.common.asm.FMLSanityChecker";
    }
    
    @Override
    public void injectData(final Map<String, Object> data) {
    }
}



================================================
FILE: cpw/mods/fml/relauncher/FMLInjectionData.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.relauncher;

import java.util.ArrayList;
import java.io.InputStream;
import java.io.IOException;
import java.util.logging.Level;
import java.util.Properties;
import net.minecraft.launchwrapper.LaunchClassLoader;
import java.util.List;
import java.io.File;

public class FMLInjectionData
{
    static File minecraftHome;
    static String major;
    static String minor;
    static String rev;
    static String build;
    static String mccversion;
    static String mcpversion;
    static String deobfuscationDataHash;
    public static List<String> containers;
    
    static void build(final File mcHome, final LaunchClassLoader classLoader) {
        FMLInjectionData.minecraftHome = mcHome;
        final InputStream stream = classLoader.getResourceAsStream("fmlversion.properties");
        final Properties properties = new Properties();
        if (stream != null) {
            try {
                properties.load(stream);
            }
            catch (final IOException ex) {
                FMLRelaunchLog.log(Level.SEVERE, ex, "Could not get FML version information - corrupted installation detected!", new Object[0]);
            }
        }
        FMLInjectionData.major = properties.getProperty("fmlbuild.major.number", "missing");
        FMLInjectionData.minor = properties.getProperty("fmlbuild.minor.number", "missing");
        FMLInjectionData.rev = properties.getProperty("fmlbuild.revision.number", "missing");
        FMLInjectionData.build = properties.getProperty("fmlbuild.build.number", "missing");
        FMLInjectionData.mccversion = properties.getProperty("fmlbuild.mcversion", "missing");
        FMLInjectionData.mcpversion = properties.getProperty("fmlbuild.mcpversion", "missing");
        FMLInjectionData.deobfuscationDataHash = properties.getProperty("fmlbuild.deobfuscation.hash", "deadbeef");
    }
    
    static String debfuscationDataName() {
        return "/deobfuscation_data-" + FMLInjectionData.mccversion + ".lzma";
    }
    
    public static Object[] data() {
        return new Object[] { FMLInjectionData.major, FMLInjectionData.minor, FMLInjectionData.rev, FMLInjectionData.build, FMLInjectionData.mccversion, FMLInjectionData.mcpversion, FMLInjectionData.minecraftHome, FMLInjectionData.containers };
    }
    
    static {
        FMLInjectionData.containers = new ArrayList<String>();
    }
}



================================================
FILE: cpw/mods/fml/relauncher/FMLLaunchHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.relauncher;

import com.google.common.base.Throwables;
import java.util.logging.Level;
import java.io.File;
import cpw.mods.fml.common.launcher.FMLTweaker;
import net.minecraft.launchwrapper.LaunchClassLoader;

public class FMLLaunchHandler
{
    private static FMLLaunchHandler INSTANCE;
    static Side side;
    private LaunchClassLoader classLoader;
    private FMLTweaker tweaker;
    private File minecraftHome;
    
    public static void configureForClientLaunch(final LaunchClassLoader loader, final FMLTweaker tweaker) {
        instance(loader, tweaker).setupClient();
    }
    
    public static void configureForServerLaunch(final LaunchClassLoader loader, final FMLTweaker tweaker) {
        instance(loader, tweaker).setupServer();
    }
    
    private static FMLLaunchHandler instance(final LaunchClassLoader launchLoader, final FMLTweaker tweaker) {
        if (FMLLaunchHandler.INSTANCE == null) {
            FMLLaunchHandler.INSTANCE = new FMLLaunchHandler(launchLoader, tweaker);
        }
        return FMLLaunchHandler.INSTANCE;
    }
    
    private FMLLaunchHandler(final LaunchClassLoader launchLoader, final FMLTweaker tweaker) {
        this.classLoader = launchLoader;
        this.tweaker = tweaker;
        this.minecraftHome = tweaker.getGameDir();
        this.classLoader.addClassLoaderExclusion("cpw.mods.fml.relauncher.");
        this.classLoader.addClassLoaderExclusion("net.minecraftforge.classloading.");
        this.classLoader.addTransformerExclusion("cpw.mods.fml.common.asm.transformers.deobf.");
        this.classLoader.addTransformerExclusion("cpw.mods.fml.common.patcher.");
    }
    
    private void setupClient() {
        FMLRelaunchLog.logFileNamePattern = "ForgeModLoader-client-%g.log";
        FMLLaunchHandler.side = Side.CLIENT;
        this.setupHome();
    }
    
    private void setupServer() {
        FMLRelaunchLog.logFileNamePattern = "ForgeModLoader-server-%g.log";
        FMLLaunchHandler.side = Side.SERVER;
        this.setupHome();
    }
    
    private void setupHome() {
        FMLInjectionData.build(this.minecraftHome, this.classLoader);
        FMLRelaunchLog.minecraftHome = this.minecraftHome;
        FMLRelaunchLog.info("Forge Mod Loader version %s.%s.%s.%s for Minecraft %s loading", FMLInjectionData.major, FMLInjectionData.minor, FMLInjectionData.rev, FMLInjectionData.build, FMLInjectionData.mccversion, FMLInjectionData.mcpversion);
        FMLRelaunchLog.info("Java is %s, version %s, running on %s:%s:%s, installed at %s", System.getProperty("java.vm.name"), System.getProperty("java.version"), System.getProperty("os.name"), System.getProperty("os.arch"), System.getProperty("os.version"), System.getProperty("java.home"));
        FMLRelaunchLog.fine("Java classpath at launch is %s", System.getProperty("java.class.path"));
        FMLRelaunchLog.fine("Java library path at launch is %s", System.getProperty("java.library.path"));
        try {
            CoreModManager.handleLaunch(this.minecraftHome, this.classLoader, this.tweaker);
        }
        catch (final Throwable t) {
            t.printStackTrace();
            FMLRelaunchLog.log(Level.SEVERE, t, "An error occurred trying to configure the minecraft home at %s for Forge Mod Loader", this.minecraftHome.getAbsolutePath());
            throw Throwables.propagate(t);
        }
    }
    
    public static Side side() {
        return FMLLaunchHandler.side;
    }
    
    private void injectPostfixTransformers() {
        CoreModManager.injectTransformers(this.classLoader);
    }
    
    public static void appendCoreMods() {
        FMLLaunchHandler.INSTANCE.injectPostfixTransformers();
    }
}



================================================
FILE: cpw/mods/fml/relauncher/FMLLogFormatter.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.relauncher;

import java.util.logging.Level;
import java.io.Writer;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.logging.LogRecord;
import java.text.SimpleDateFormat;
import java.util.logging.Formatter;

final class FMLLogFormatter extends Formatter
{
    static final String LINE_SEPARATOR;
    private SimpleDateFormat dateFormat;
    
    FMLLogFormatter() {
        this.dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    }
    
    @Override
    public String format(final LogRecord record) {
        final StringBuilder msg = new StringBuilder();
        msg.append(this.dateFormat.format(record.getMillis()));
        final Level lvl = record.getLevel();
        String name = lvl.getLocalizedName();
        if (name == null) {
            name = lvl.getName();
        }
        if (name != null && name.length() > 0) {
            msg.append(" [" + name + "] ");
        }
        else {
            msg.append(" ");
        }
        if (record.getLoggerName() != null) {
            msg.append("[" + record.getLoggerName() + "] ");
        }
        else {
            msg.append("[] ");
        }
        msg.append(this.formatMessage(record));
        msg.append(FMLLogFormatter.LINE_SEPARATOR);
        final Throwable thr = record.getThrown();
        if (thr != null) {
            final StringWriter thrDump = new StringWriter();
            thr.printStackTrace(new PrintWriter(thrDump));
            msg.append(thrDump.toString());
        }
        return msg.toString();
    }
    
    static {
        LINE_SEPARATOR = System.getProperty("line.separator");
    }
}



================================================
FILE: cpw/mods/fml/relauncher/FMLRelaunchLog.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.relauncher;

import java.io.IOException;
import java.io.ByteArrayOutputStream;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.logging.ConsoleHandler;
import java.util.logging.LogRecord;
import java.io.InputStream;
import java.io.FileInputStream;
import java.util.logging.Formatter;
import java.util.logging.Handler;
import java.io.OutputStream;
import com.google.common.base.Throwables;
import net.minecraft.launchwrapper.LogWrapper;
import java.util.logging.Level;
import java.util.logging.LogManager;
import java.util.logging.FileHandler;
import java.util.logging.Logger;
import java.io.PrintStream;
import java.io.File;

public class FMLRelaunchLog
{
    public static FMLRelaunchLog log;
    static File minecraftHome;
    private static boolean configured;
    private static Thread consoleLogThread;
    private static PrintStream errCache;
    private Logger myLog;
    private static FileHandler fileHandler;
    private static FMLLogFormatter formatter;
    static String logFileNamePattern;
    
    private FMLRelaunchLog() {
    }
    
    private static void configureLogging() {
        LogManager.getLogManager().reset();
        final Logger globalLogger = Logger.getLogger("global");
        globalLogger.setLevel(Level.OFF);
        LogWrapper.retarget(FMLRelaunchLog.log.myLog = Logger.getLogger("ForgeModLoader"));
        final Logger stdOut = Logger.getLogger("STDOUT");
        stdOut.setParent(FMLRelaunchLog.log.myLog);
        final Logger stdErr = Logger.getLogger("STDERR");
        stdErr.setParent(FMLRelaunchLog.log.myLog);
        FMLRelaunchLog.log.myLog.setLevel(Level.ALL);
        FMLRelaunchLog.log.myLog.setUseParentHandlers(false);
        (FMLRelaunchLog.consoleLogThread = new Thread(new ConsoleLogThread())).setDaemon(true);
        FMLRelaunchLog.consoleLogThread.start();
        FMLRelaunchLog.formatter = new FMLLogFormatter();
        try {
            final File logPath = new File(FMLRelaunchLog.minecraftHome, FMLRelaunchLog.logFileNamePattern);
            FMLRelaunchLog.fileHandler = new FileHandler(logPath.getPath(), 0, 3) {
                @Override
                public synchronized void close() throws SecurityException {
                }
            };
        }
        catch (final Throwable t) {
            throw Throwables.propagate(t);
        }
        resetLoggingHandlers();
        FMLRelaunchLog.errCache = System.err;
        System.setOut(new PrintStream(new LoggingOutStream(stdOut), true));
        System.setErr(new PrintStream(new LoggingOutStream(stdErr), true));
        FMLRelaunchLog.configured = true;
    }
    
    private static void resetLoggingHandlers() {
        ConsoleLogThread.wrappedHandler.setLevel(Level.parse(System.getProperty("fml.log.level", "INFO")));
        FMLRelaunchLog.log.myLog.addHandler(new ConsoleLogWrapper());
        ConsoleLogThread.wrappedHandler.setFormatter(FMLRelaunchLog.formatter);
        FMLRelaunchLog.fileHandler.setLevel(Level.ALL);
        FMLRelaunchLog.fileHandler.setFormatter(FMLRelaunchLog.formatter);
        FMLRelaunchLog.log.myLog.addHandler(FMLRelaunchLog.fileHandler);
    }
    
    public static void loadLogConfiguration(final File logConfigFile) {
        if (logConfigFile != null && logConfigFile.exists() && logConfigFile.canRead()) {
            try {
                LogManager.getLogManager().readConfiguration(new FileInputStream(logConfigFile));
                resetLoggingHandlers();
            }
            catch (final Exception e) {
                log(Level.SEVERE, e, "Error reading logging configuration file %s", logConfigFile.getName());
            }
        }
    }
    
    public static void log(final String logChannel, final Level level, final String format, final Object... data) {
        makeLog(logChannel);
        Logger.getLogger(logChannel).log(level, String.format(format, data));
    }
    
    public static void log(final Level level, final String format, final Object... data) {
        if (!FMLRelaunchLog.configured) {
            configureLogging();
        }
        FMLRelaunchLog.log.myLog.log(level, String.format(format, data));
    }
    
    public static void log(final String logChannel, final Level level, final Throwable ex, final String format, final Object... data) {
        makeLog(logChannel);
        Logger.getLogger(logChannel).log(level, String.format(format, data), ex);
    }
    
    public static void log(final Level level, final Throwable ex, final String format, final Object... data) {
        if (!FMLRelaunchLog.configured) {
            configureLogging();
        }
        FMLRelaunchLog.log.myLog.log(level, String.format(format, data), ex);
    }
    
    public static void severe(final String format, final Object... data) {
        log(Level.SEVERE, format, data);
    }
    
    public static void warning(final String format, final Object... data) {
        log(Level.WARNING, format, data);
    }
    
    public static void info(final String format, final Object... data) {
        log(Level.INFO, format, data);
    }
    
    public static void fine(final String format, final Object... data) {
        log(Level.FINE, format, data);
    }
    
    public static void finer(final String format, final Object... data) {
        log(Level.FINER, format, data);
    }
    
    public static void finest(final String format, final Object... data) {
        log(Level.FINEST, format, data);
    }
    
    public Logger getLogger() {
        return this.myLog;
    }
    
    public static void makeLog(final String logChannel) {
        final Logger l = Logger.getLogger(logChannel);
        l.setParent(FMLRelaunchLog.log.myLog);
    }
    
    static {
        FMLRelaunchLog.log = new FMLRelaunchLog();
    }
    
    private static class ConsoleLogWrapper extends Handler
    {
        @Override
        public void publish(final LogRecord record) {
            final boolean currInt = Thread.interrupted();
            try {
                ConsoleLogThread.recordQueue.put(record);
            }
            catch (final InterruptedException e) {
                e.printStackTrace(FMLRelaunchLog.errCache);
            }
            if (currInt) {
                Thread.currentThread().interrupt();
            }
        }
        
        @Override
        public void flush() {
        }
        
        @Override
        public void close() throws SecurityException {
        }
    }
    
    private static class ConsoleLogThread implements Runnable
    {
        static ConsoleHandler wrappedHandler;
        static LinkedBlockingQueue<LogRecord> recordQueue;
        
        @Override
        public void run() {
            while (true) {
                try {
                    final LogRecord lr = ConsoleLogThread.recordQueue.take();
                    ConsoleLogThread.wrappedHandler.publish(lr);
                }
                catch (final InterruptedException e) {
                    e.printStackTrace(FMLRelaunchLog.errCache);
                    Thread.interrupted();
                }
            }
        }
        
        static {
            ConsoleLogThread.wrappedHandler = new ConsoleHandler();
            ConsoleLogThread.recordQueue = new LinkedBlockingQueue<LogRecord>();
        }
    }
    
    private static class LoggingOutStream extends ByteArrayOutputStream
    {
        private Logger log;
        private StringBuilder currentMessage;
        
        public LoggingOutStream(final Logger log) {
            this.log = log;
            this.currentMessage = new StringBuilder();
        }
        
        @Override
        public void flush() throws IOException {
            synchronized (FMLRelaunchLog.class) {
                super.flush();
                final String record = this.toString();
                super.reset();
                this.currentMessage.append(record.replace(FMLLogFormatter.LINE_SEPARATOR, "\n"));
                int lastIdx = -1;
                for (int idx = this.currentMessage.indexOf("\n", lastIdx + 1); idx >= 0; idx = this.currentMessage.indexOf("\n", lastIdx + 1)) {
                    this.log.log(Level.INFO, this.currentMessage.substring(lastIdx + 1, idx));
                    lastIdx = idx;
                }
                if (lastIdx >= 0) {
                    final String rem = this.currentMessage.substring(lastIdx + 1);
                    this.currentMessage.setLength(0);
                    this.currentMessage.append(rem);
                }
            }
        }
    }
}



================================================
FILE: cpw/mods/fml/relauncher/IFMLCallHook.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.relauncher;

import java.util.Map;
import java.util.concurrent.Callable;

public interface IFMLCallHook extends Callable<Void>
{
    void injectData(final Map<String, Object> p0);
}



================================================
FILE: cpw/mods/fml/relauncher/IFMLLoadingPlugin.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.relauncher;

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Retention;
import java.util.Map;

public interface IFMLLoadingPlugin
{
    @Deprecated
    String[] getLibraryRequestClass();
    
    String[] getASMTransformerClass();
    
    String getModContainerClass();
    
    String getSetupClass();
    
    void injectData(final Map<String, Object> p0);
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.TYPE })
    public @interface SortingIndex {
        int value() default 0;
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.TYPE })
    public @interface DependsOn {
        String[] value() default {};
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.TYPE })
    public @interface Name {
        String value() default "";
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.TYPE })
    public @interface MCVersion {
        String value() default "";
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.TYPE })
    public @interface TransformerExclusions {
        String[] value() default { "" };
    }
}



================================================
FILE: cpw/mods/fml/relauncher/ILibrarySet.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.relauncher;

@Deprecated
public interface ILibrarySet
{
    String[] getLibraries();
    
    String[] getHashes();
    
    String getRootURL();
}



================================================
FILE: cpw/mods/fml/relauncher/ReflectionHelper.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.relauncher;

import java.lang.reflect.Method;
import java.lang.reflect.Field;

public class ReflectionHelper
{
    public static Field findField(final Class<?> clazz, final String... fieldNames) {
        Exception failed = null;
        final String[] arr$ = fieldNames;
        final int len$ = arr$.length;
        int i$ = 0;
        while (i$ < len$) {
            final String fieldName = arr$[i$];
            try {
                final Field f = clazz.getDeclaredField(fieldName);
                f.setAccessible(true);
                return f;
            }
            catch (final Exception e) {
                failed = e;
                ++i$;
                continue;
            }
            break;
        }
        throw new UnableToFindFieldException(fieldNames, failed);
    }
    
    public static <T, E> T getPrivateValue(final Class<? super E> classToAccess, final E instance, final int fieldIndex) {
        try {
            final Field f = classToAccess.getDeclaredFields()[fieldIndex];
            f.setAccessible(true);
            return (T)f.get(instance);
        }
        catch (final Exception e) {
            throw new UnableToAccessFieldException(new String[0], e);
        }
    }
    
    public static <T, E> T getPrivateValue(final Class<? super E> classToAccess, final E instance, final String... fieldNames) {
        try {
            return (T)findField(classToAccess, fieldNames).get(instance);
        }
        catch (final Exception e) {
            throw new UnableToAccessFieldException(fieldNames, e);
        }
    }
    
    public static <T, E> void setPrivateValue(final Class<? super T> classToAccess, final T instance, final E value, final int fieldIndex) {
        try {
            final Field f = classToAccess.getDeclaredFields()[fieldIndex];
            f.setAccessible(true);
            f.set(instance, value);
        }
        catch (final Exception e) {
            throw new UnableToAccessFieldException(new String[0], e);
        }
    }
    
    public static <T, E> void setPrivateValue(final Class<? super T> classToAccess, final T instance, final E value, final String... fieldNames) {
        try {
            findField(classToAccess, fieldNames).set(instance, value);
        }
        catch (final Exception e) {
            throw new UnableToAccessFieldException(fieldNames, e);
        }
    }
    
    public static Class<? super Object> getClass(final ClassLoader loader, final String... classNames) {
        Exception err = null;
        final String[] arr$ = classNames;
        final int len$ = arr$.length;
        int i$ = 0;
        while (i$ < len$) {
            final String className = arr$[i$];
            try {
                return (Class<? super Object>)Class.forName(className, false, loader);
            }
            catch (final Exception e) {
                err = e;
                ++i$;
                continue;
            }
            break;
        }
        throw new UnableToFindClassException(classNames, err);
    }
    
    public static <E> Method findMethod(final Class<? super E> clazz, final E instance, final String[] methodNames, final Class<?>... methodTypes) {
        Exception failed = null;
        final String[] arr$ = methodNames;
        final int len$ = arr$.length;
        int i$ = 0;
        while (i$ < len$) {
            final String methodName = arr$[i$];
            try {
                final Method m = clazz.getDeclaredMethod(methodName, methodTypes);
                m.setAccessible(true);
                return m;
            }
            catch (final Exception e) {
                failed = e;
                ++i$;
                continue;
            }
            break;
        }
        throw new UnableToFindMethodException(methodNames, failed);
    }
    
    public static class UnableToFindMethodException extends RuntimeException
    {
        private String[] methodNames;
        
        public UnableToFindMethodException(final String[] methodNames, final Exception failed) {
            super(failed);
            this.methodNames = methodNames;
        }
    }
    
    public static class UnableToFindClassException extends RuntimeException
    {
        private String[] classNames;
        
        public UnableToFindClassException(final String[] classNames, final Exception err) {
            super(err);
            this.classNames = classNames;
        }
    }
    
    public static class UnableToAccessFieldException extends RuntimeException
    {
        private String[] fieldNameList;
        
        public UnableToAccessFieldException(final String[] fieldNames, final Exception e) {
            super(e);
            this.fieldNameList = fieldNames;
        }
    }
    
    public static class UnableToFindFieldException extends RuntimeException
    {
        private String[] fieldNameList;
        
        public UnableToFindFieldException(final String[] fieldNameList, final Exception e) {
            super(e);
            this.fieldNameList = fieldNameList;
        }
    }
}



================================================
FILE: cpw/mods/fml/relauncher/ServerLaunchWrapper.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.relauncher;

import java.lang.reflect.Method;

public class ServerLaunchWrapper
{
    public static void main(final String[] args) {
        new ServerLaunchWrapper().run(args);
    }
    
    private ServerLaunchWrapper() {
    }
    
    private void run(final String[] args) {
        Class<?> launchwrapper = null;
        try {
            launchwrapper = Class.forName("net.minecraft.launchwrapper.Launch", true, this.getClass().getClassLoader());
            Class.forName("org.objectweb.asm.Type", true, this.getClass().getClassLoader());
        }
        catch (final Exception e) {
            System.err.printf("We appear to be missing one or more essential library files.\nYou will need to add them to your server before FML and Forge will run successfully.", new Object[0]);
            e.printStackTrace(System.err);
            System.exit(1);
        }
        try {
            final Method main = launchwrapper.getMethod("main", String[].class);
            final String[] allArgs = new String[args.length + 2];
            allArgs[0] = "--tweakClass";
            allArgs[1] = "cpw.mods.fml.common.launcher.FMLServerTweaker";
            System.arraycopy(args, 0, allArgs, 2, args.length);
            main.invoke(null, allArgs);
        }
        catch (final Exception e) {
            System.err.printf("A problem occurred running the Server launcher.", new Object[0]);
            e.printStackTrace(System.err);
            System.exit(1);
        }
    }
}



================================================
FILE: cpw/mods/fml/relauncher/Side.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.relauncher;

public enum Side
{
    CLIENT, 
    SERVER;
    
    public boolean isServer() {
        return !this.isClient();
    }
    
    public boolean isClient() {
        return this == Side.CLIENT;
    }
}



================================================
FILE: cpw/mods/fml/relauncher/SideOnly.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.relauncher;

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Retention;

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.FIELD, ElementType.METHOD, ElementType.CONSTRUCTOR })
public @interface SideOnly {
    Side value();
}



================================================
FILE: cpw/mods/fml/repackage/com/nothome/delta/ByteBufferSeekableSource.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.repackage.com.nothome.delta;

import java.io.IOException;
import java.nio.ByteBuffer;

public class ByteBufferSeekableSource implements SeekableSource
{
    private ByteBuffer bb;
    private ByteBuffer cur;
    
    public ByteBufferSeekableSource(final byte[] source) {
        this(ByteBuffer.wrap(source));
    }
    
    public ByteBufferSeekableSource(final ByteBuffer bb) {
        if (bb == null) {
            throw new NullPointerException("bb");
        }
        (this.bb = bb).rewind();
        try {
            this.seek(0L);
        }
        catch (final IOException e) {
            throw new RuntimeException(e);
        }
    }
    
    @Override
    public void seek(final long pos) throws IOException {
        this.cur = this.bb.slice();
        if (pos > this.cur.limit()) {
            throw new IOException("pos " + pos + " cannot seek " + this.cur.limit());
        }
        this.cur.position((int)pos);
    }
    
    @Override
    public int read(final ByteBuffer dest) throws IOException {
        if (!this.cur.hasRemaining()) {
            return -1;
        }
        int c = 0;
        while (this.cur.hasRemaining() && dest.hasRemaining()) {
            dest.put(this.cur.get());
            ++c;
        }
        return c;
    }
    
    @Override
    public void close() throws IOException {
        this.bb = null;
        this.cur = null;
    }
    
    @Override
    public String toString() {
        return "BBSeekable bb=" + this.bb.position() + "-" + this.bb.limit() + " cur=" + this.cur.position() + "-" + this.cur.limit() + "";
    }
}



================================================
FILE: cpw/mods/fml/repackage/com/nothome/delta/Checksum.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.repackage.com.nothome.delta;

import java.io.IOException;
import java.nio.ByteBuffer;
import com.google.common.collect.Maps;
import java.util.Map;

public class Checksum
{
    static final boolean debug = false;
    private Map<Long, Integer> checksums;
    private static final char[] single_hash;
    
    public Checksum(final SeekableSource source, final int chunkSize) throws IOException {
        this.checksums = Maps.newHashMap();
        final ByteBuffer bb = ByteBuffer.allocate(chunkSize * 2);
        int count = 0;
        while (true) {
            source.read(bb);
            bb.flip();
            if (bb.remaining() < chunkSize) {
                break;
            }
            while (bb.remaining() >= chunkSize) {
                final long queryChecksum = queryChecksum0(bb, chunkSize);
                this.checksums.put(queryChecksum, count++);
            }
            bb.compact();
        }
    }
    
    public static long queryChecksum(final ByteBuffer bb, final int len) {
        bb.mark();
        final long sum = queryChecksum0(bb, len);
        bb.reset();
        return sum;
    }
    
    private static long queryChecksum0(final ByteBuffer bb, final int len) {
        int high = 0;
        int low = 0;
        for (int i = 0; i < len; ++i) {
            low += Checksum.single_hash[bb.get() + 128];
            high += low;
        }
        return (high & 0xFFFF) << 16 | (low & 0xFFFF);
    }
    
    public static long incrementChecksum(final long checksum, final byte out, final byte in, final int chunkSize) {
        final char old_c = Checksum.single_hash[out + 128];
        final char new_c = Checksum.single_hash[in + 128];
        final int low = (int)(checksum & 0xFFFFL) - old_c + new_c & 0xFFFF;
        final int high = (int)(checksum >> 16) - old_c * chunkSize + low & 0xFFFF;
        return high << 16 | (low & 0xFFFF);
    }
    
    public static char[] getSingleHash() {
        return Checksum.single_hash;
    }
    
    public int findChecksumIndex(final long hashf) {
        if (!this.checksums.containsKey(hashf)) {
            return -1;
        }
        return this.checksums.get(hashf);
    }
    
    @Override
    public String toString() {
        return super.toString() + " checksums=" + this.checksums;
    }
    
    static {
        single_hash = new char[] { '\ubcd1', '\ubb65', '\u42c2', '\udffe', '\u9666', '\u431b', '\u8504', '\ueb46', '\u6379', '\ud460', '\ucf14', '\u53cf', '\udb51', '\udb08', '\u12c8', '\uf602', '\ue766', '\u2394', '\u250d', '\udcbb', '\ua678', '\u02af', '\ua5c6', '\u7ea6', '\ub645', '\ucb4d', '\uc44b', '\ue5dc', '\u9fe6', '\u5b5c', '\u35f5', '\u701a', '\u220f', '\u6c38', '\u1a56', '\u4ca3', '\uffc6', '\ub152', '\u8d61', '\u7a58', '\u9025', '\u8b3d', '\ubf0f', '\u95a3', '\ue5f4', '\uc127', '\u3bed', '\u320b', '\ub7f3', '\u6054', '\u333c', '\ud383', '\u8154', '\u5242', '\u4e0d', '\u0a94', '\u7028', '\u8689', '\u3a22', '\u0980', '\u1847', '\ub0f1', '\u9b5c', '\u4176', '\ub858', '\ud542', '\u1f6c', '\u2497', '\u6a5a', '\u9fa9', '\u8c5a', '\u7743', '\ua8a9', '\u9a02', '\u4918', '\u438c', '\uc388', '\u9e2b', '\u4cad', '\u01b6', '\uab19', '\uf777', '\u365f', '\u1eb2', '\u091e', '\u7bf8', '\u7a8e', '\u5227', '\ueab1', '\u2074', '\u4523', '\ue781', '\u01a3', '\u163d', '\u3b2e', '\u287d', '\u5e7f', '\ua063', '\ub134', '\u8fae', '\u5e8e', '\ub7b7', '\u4548', '\u1f5a', '\ufa56', '\u7a24', '\u900f', '\u42dc', '\ucc69', '\u02a0', '\u0b22', '\udb31', '\u71fe', '\u0c7d', '\u1732', '\u1159', '\ucb09', '\ue1d2', '\u1351', '\u52e9', '\uf536', '\u5a4f', '\uc316', '\u6bf9', '\u8994', '\ub774', '\u5f3e', '\uf6d6', '\u3a61', '\uf82c', '\ucc22', '\u9d06', '\u299c', '\u09e5', '\u1eec', '\u514f', '\u8d53', '\ua650', '\u5c6e', '\uc577', '\u7958', '\u71ac', '\u8916', '\u9b4f', '\u2c09', '\u5211', '\uf6d8', '\ucaaa', '\uf7ef', '\u287f', '\u7a94', '\uab49', '\ufa2c', '\u7222', '\ue457', '\ud71a', '\u00c3', '\u1a76', '\ue98c', '\uc037', '\u8208', '\u5c2d', '\udfda', '\ue5f5', '\u0b45', '\u15ce', '\u8a7e', '\ufcad', '\uaa2d', '\u4b5c', '\ud42e', '\ub251', '\u907e', '\u9a47', '\uc9a6', '\ud93f', '\u085e', '\u35ce', '\ua153', '\u7e7b', '\u9f0b', '\u25aa', '\u5d9f', '\uc04d', '\u8a0e', '\u2875', '\u4a1c', '\u295f', '\u1393', '\uf760', '\u9178', '\u0f5b', '\ufa7d', '\u83b4', '\u2082', '\u721d', '\u6462', '\u0368', '\u67e2', '\u8624', '\u194d', '\u22f6', '\u78fb', '\u6791', '\ub238', '\ub332', '\u7276', '\uf272', '\u47ec', '\u4504', '\ua961', '\u9fc8', '\u3fdc', '\ub413', 'z', '\u0806', '\u7458', '\u95c6', '\uccaa', '\u18d6', '\ue2ae', '\u1b06', '\uf3f6', '\u5050', '\uc8e8', '\uf4ac', '\uc04c', '\uf41c', '\u992f', '\uae44', '\u5f1b', '\u1113', '\u1738', '\ud9a8', '\u19ea', '\u2d33', '\u9698', '\u2fe9', '\u323f', '\ucde2', '\u6d71', '\ue37d', '\ub697', '\u2c4f', '\u4373', '\u9102', '\u075d', '\u8e25', '\u1672', '\uec28', '\u6acb', '\u86cc', '\u186e', '\u9414', '\ud674', '\ud1a5' };
    }
}



================================================
FILE: cpw/mods/fml/repackage/com/nothome/delta/DebugDiffWriter.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.repackage.com.nothome.delta;

import java.io.IOException;
import java.io.ByteArrayOutputStream;

public class DebugDiffWriter implements DiffWriter
{
    private ByteArrayOutputStream os;
    
    public DebugDiffWriter() {
        this.os = new ByteArrayOutputStream();
    }
    
    @Override
    public void addCopy(final long offset, final int length) throws IOException {
        if (this.os.size() > 0) {
            this.writeBuf();
        }
        System.err.println("COPY off: " + offset + ", len: " + length);
    }
    
    @Override
    public void addData(final byte b) throws IOException {
        this.os.write(b);
        this.writeBuf();
    }
    
    private void writeBuf() {
        System.err.print("DATA: ");
        final byte[] ba = this.os.toByteArray();
        for (int ix = 0; ix < ba.length; ++ix) {
            if (ba[ix] == 10) {
                System.err.print("\\n");
            }
            else {
                System.err.print(String.valueOf((char)ba[ix]));
            }
        }
        System.err.println("");
        this.os.reset();
    }
    
    @Override
    public void flush() throws IOException {
        System.err.println("FLUSH");
    }
    
    @Override
    public void close() throws IOException {
        System.err.println("CLOSE");
    }
}



================================================
FILE: cpw/mods/fml/repackage/com/nothome/delta/Delta.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.repackage.com.nothome.delta;

import java.nio.channels.Channels;
import java.nio.ByteBuffer;
import java.nio.channels.ReadableByteChannel;
import java.io.DataOutputStream;
import java.io.BufferedOutputStream;
import java.io.FileOutputStream;
import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.RandomAccessFile;
import java.io.File;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.OutputStream;

public class Delta
{
    static final boolean debug = false;
    public static final int DEFAULT_CHUNK_SIZE = 16;
    private int S;
    private SourceState source;
    private TargetState target;
    private DiffWriter output;
    
    public Delta() {
        this.setChunkSize(16);
    }
    
    public void setChunkSize(final int size) {
        if (size <= 0) {
            throw new IllegalArgumentException("Invalid size");
        }
        this.S = size;
    }
    
    public void compute(final byte[] source, final byte[] target, final OutputStream output) throws IOException {
        this.compute(new ByteBufferSeekableSource(source), new ByteArrayInputStream(target), new GDiffWriter(output));
    }
    
    public byte[] compute(final byte[] source, final byte[] target) throws IOException {
        final ByteArrayOutputStream os = new ByteArrayOutputStream();
        this.compute(source, target, os);
        return os.toByteArray();
    }
    
    public void compute(final byte[] sourceBytes, final InputStream inputStream, final DiffWriter diffWriter) throws IOException {
        this.compute(new ByteBufferSeekableSource(sourceBytes), inputStream, diffWriter);
    }
    
    public void compute(final File sourceFile, final File targetFile, final DiffWriter output) throws IOException {
        final RandomAccessFileSeekableSource source = new RandomAccessFileSeekableSource(new RandomAccessFile(sourceFile, "r"));
        final InputStream is = new BufferedInputStream(new FileInputStream(targetFile));
        try {
            this.compute(source, is, output);
        }
        finally {
            source.close();
            is.close();
        }
    }
    
    public void compute(final SeekableSource seekSource, final InputStream targetIS, final DiffWriter output) throws IOException {
        this.source = new SourceState(seekSource);
        this.target = new TargetState(targetIS);
        this.output = output;
        while (!this.target.eof()) {
            this.debug("!target.eof()");
            final int index = this.target.find(this.source);
            if (index != -1) {
                final long offset = index * (long)this.S;
                this.source.seek(offset);
                final int match = this.target.longestMatch(this.source);
                if (match >= this.S) {
                    output.addCopy(offset, match);
                }
                else {
                    this.target.tbuf.position(this.target.tbuf.position() - match);
                    this.addData();
                }
            }
            else {
                this.addData();
            }
        }
        output.close();
    }
    
    private void addData() throws IOException {
        final int i = this.target.read();
        if (i == -1) {
            return;
        }
        this.output.addData((byte)i);
    }
    
    public static void main(final String[] argv) throws Exception {
        if (argv.length != 3) {
            System.err.println("usage Delta [-d] source target [output]");
            System.err.println("either -d or an output filename must be specified.");
            System.err.println("aborting..");
            return;
        }
        DiffWriter output = null;
        File sourceFile = null;
        File targetFile = null;
        if (argv[0].equals("-d")) {
            sourceFile = new File(argv[1]);
            targetFile = new File(argv[2]);
            output = new DebugDiffWriter();
        }
        else {
            sourceFile = new File(argv[0]);
            targetFile = new File(argv[1]);
            output = new GDiffWriter(new DataOutputStream(new BufferedOutputStream(new FileOutputStream(new File(argv[2])))));
        }
        if (sourceFile.length() > 2147483647L || targetFile.length() > 2147483647L) {
            System.err.println("source or target is too large, max length is 2147483647");
            System.err.println("aborting..");
            output.close();
            return;
        }
        final Delta d = new Delta();
        d.compute(sourceFile, targetFile, output);
        output.flush();
        output.close();
    }
    
    private void debug(final String s) {
    }
    
    class SourceState
    {
        private Checksum checksum;
        private SeekableSource source;
        
        public SourceState(final SeekableSource source) throws IOException {
            this.checksum = new Checksum(source, Delta.this.S);
            (this.source = source).seek(0L);
        }
        
        public void seek(final long index) throws IOException {
            this.source.seek(index);
        }
        
        @Override
        public String toString() {
            return "Source checksum=" + this.checksum + " source=" + this.source + "";
        }
    }
    
    class TargetState
    {
        private ReadableByteChannel c;
        private ByteBuffer tbuf;
        private ByteBuffer sbuf;
        private long hash;
        private boolean hashReset;
        private boolean eof;
        
        TargetState(final InputStream targetIS) throws IOException {
            this.tbuf = ByteBuffer.allocate(this.blocksize());
            this.sbuf = ByteBuffer.allocate(this.blocksize());
            this.hashReset = true;
            this.c = Channels.newChannel(targetIS);
            this.tbuf.limit(0);
        }
        
        private int blocksize() {
            return Math.min(16384, Delta.this.S * 4);
        }
        
        public int find(final SourceState source) throws IOException {
            if (this.eof) {
                return -1;
            }
            this.sbuf.clear();
            this.sbuf.limit(0);
            if (this.hashReset) {
                Delta.this.debug("hashReset");
                while (this.tbuf.remaining() < Delta.this.S) {
                    this.tbuf.compact();
                    final int read = this.c.read(this.tbuf);
                    this.tbuf.flip();
                    if (read == -1) {
                        Delta.this.debug("target ending");
                        return -1;
                    }
                }
                this.hash = Checksum.queryChecksum(this.tbuf, Delta.this.S);
                this.hashReset = false;
            }
            return source.checksum.findChecksumIndex(this.hash);
        }
        
        public boolean eof() {
            return this.eof;
        }
        
        public int read() throws IOException {
            if (this.tbuf.remaining() <= Delta.this.S) {
                this.readMore();
                if (!this.tbuf.hasRemaining()) {
                    this.eof = true;
                    return -1;
                }
            }
            final byte b = this.tbuf.get();
            if (this.tbuf.remaining() >= Delta.this.S) {
                final byte nchar = this.tbuf.get(this.tbuf.position() + Delta.this.S - 1);
                this.hash = Checksum.incrementChecksum(this.hash, b, nchar, Delta.this.S);
            }
            else {
                Delta.this.debug("out of char");
            }
            return b & 0xFF;
        }
        
        public int longestMatch(final SourceState source) throws IOException {
            Delta.this.debug("longestMatch");
            int match = 0;
            this.hashReset = true;
            while (true) {
                if (!this.sbuf.hasRemaining()) {
                    this.sbuf.clear();
                    final int read = source.source.read(this.sbuf);
                    this.sbuf.flip();
                    if (read == -1) {
                        return match;
                    }
                }
                if (!this.tbuf.hasRemaining()) {
                    this.readMore();
                    if (!this.tbuf.hasRemaining()) {
                        Delta.this.debug("target ending");
                        this.eof = true;
                        return match;
                    }
                }
                if (this.sbuf.get() != this.tbuf.get()) {
                    this.tbuf.position(this.tbuf.position() - 1);
                    return match;
                }
                ++match;
            }
        }
        
        private void readMore() throws IOException {
            this.tbuf.compact();
            this.c.read(this.tbuf);
            this.tbuf.flip();
        }
        
        void hash() {
            this.hash = Checksum.queryChecksum(this.tbuf, Delta.this.S);
        }
        
        @Override
        public String toString() {
            return "Target[ targetBuff=" + this.dump() + " sourceBuff=" + this.sbuf + " hashf=" + this.hash + " eof=" + this.eof + "]";
        }
        
        private String dump() {
            return this.dump(this.tbuf);
        }
        
        private String dump(final ByteBuffer bb) {
            return this.getTextDump(bb);
        }
        
        private void append(final StringBuffer sb, final int value) {
            final char b1 = (char)(value >> 4 & 0xF);
            final char b2 = (char)(value & 0xF);
            sb.append(Character.forDigit(b1, 16));
            sb.append(Character.forDigit(b2, 16));
        }
        
        public String getTextDump(final ByteBuffer bb) {
            final StringBuffer sb = new StringBuffer(bb.remaining() * 2);
            bb.mark();
            while (bb.hasRemaining()) {
                final int val = bb.get();
                if (val > 32 && val < 127) {
                    sb.append(" ").append((char)val);
                }
                else {
                    this.append(sb, val);
                }
            }
            bb.reset();
            return sb.toString();
        }
    }
}



================================================
FILE: cpw/mods/fml/repackage/com/nothome/delta/DiffWriter.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.repackage.com.nothome.delta;

import java.io.IOException;
import java.io.Closeable;

public interface DiffWriter extends Closeable
{
    void addCopy(final long p0, final int p1) throws IOException;
    
    void addData(final byte p0) throws IOException;
    
    void flush() throws IOException;
    
    void close() throws IOException;
}



================================================
FILE: cpw/mods/fml/repackage/com/nothome/delta/GDiffPatcher.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.repackage.com.nothome.delta;

import java.io.EOFException;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.io.FileOutputStream;
import java.io.FileInputStream;
import java.io.RandomAccessFile;
import java.io.File;
import java.nio.ByteBuffer;

public class GDiffPatcher
{
    private ByteBuffer buf;
    private byte[] buf2;
    
    public GDiffPatcher() {
        this.buf = ByteBuffer.allocate(1024);
        this.buf2 = this.buf.array();
    }
    
    public void patch(final File sourceFile, final File patchFile, final File outputFile) throws IOException {
        final RandomAccessFileSeekableSource source = new RandomAccessFileSeekableSource(new RandomAccessFile(sourceFile, "r"));
        final InputStream patch = new FileInputStream(patchFile);
        final OutputStream output = new FileOutputStream(outputFile);
        try {
            this.patch(source, patch, output);
        }
        catch (final IOException e) {
            throw e;
        }
        finally {
            source.close();
            patch.close();
            output.close();
        }
    }
    
    public void patch(final byte[] source, final InputStream patch, final OutputStream output) throws IOException {
        this.patch(new ByteBufferSeekableSource(source), patch, output);
    }
    
    public byte[] patch(final byte[] source, final byte[] patch) throws IOException {
        final ByteArrayOutputStream os = new ByteArrayOutputStream();
        this.patch(source, new ByteArrayInputStream(patch), os);
        return os.toByteArray();
    }
    
    public void patch(final SeekableSource source, final InputStream patch, final OutputStream out) throws IOException {
        final DataOutputStream outOS = new DataOutputStream(out);
        final DataInputStream patchIS = new DataInputStream(patch);
        if (patchIS.readUnsignedByte() != 209 || patchIS.readUnsignedByte() != 255 || patchIS.readUnsignedByte() != 209 || patchIS.readUnsignedByte() != 255 || patchIS.readUnsignedByte() != 4) {
            throw new PatchException("magic string not found, aborting!");
        }
        while (true) {
            final int command = patchIS.readUnsignedByte();
            if (command == 0) {
                outOS.flush();
                return;
            }
            if (command <= 246) {
                this.append(command, patchIS, outOS);
            }
            else {
                switch (command) {
                    case 247: {
                        final int length = patchIS.readUnsignedShort();
                        this.append(length, patchIS, outOS);
                        continue;
                    }
                    case 248: {
                        final int length = patchIS.readInt();
                        this.append(length, patchIS, outOS);
                        continue;
                    }
                    case 249: {
                        final int offset = patchIS.readUnsignedShort();
                        final int length = patchIS.readUnsignedByte();
                        this.copy(offset, length, source, outOS);
                        continue;
                    }
                    case 250: {
                        final int offset = patchIS.readUnsignedShort();
                        final int length = patchIS.readUnsignedShort();
                        this.copy(offset, length, source, outOS);
                        continue;
                    }
                    case 251: {
                        final int offset = patchIS.readUnsignedShort();
                        final int length = patchIS.readInt();
                        this.copy(offset, length, source, outOS);
                        continue;
                    }
                    case 252: {
                        final int offset = patchIS.readInt();
                        final int length = patchIS.readUnsignedByte();
                        this.copy(offset, length, source, outOS);
                        continue;
                    }
                    case 253: {
                        final int offset = patchIS.readInt();
                        final int length = patchIS.readUnsignedShort();
                        this.copy(offset, length, source, outOS);
                        continue;
                    }
                    case 254: {
                        final int offset = patchIS.readInt();
                        final int length = patchIS.readInt();
                        this.copy(offset, length, source, outOS);
                        continue;
                    }
                    case 255: {
                        final long loffset = patchIS.readLong();
                        final int length = patchIS.readInt();
                        this.copy(loffset, length, source, outOS);
                        continue;
                    }
                    default: {
                        throw new IllegalStateException("command " + command);
                    }
                }
            }
        }
    }
    
    private void copy(final long offset, int length, final SeekableSource source, final OutputStream output) throws IOException {
        source.seek(offset);
        while (length > 0) {
            final int len = Math.min(this.buf.capacity(), length);
            this.buf.clear().limit(len);
            final int res = source.read(this.buf);
            if (res == -1) {
                throw new EOFException("in copy " + offset + " " + length);
            }
            output.write(this.buf.array(), 0, res);
            length -= res;
        }
    }
    
    private void append(int length, final InputStream patch, final OutputStream output) throws IOException {
        while (length > 0) {
            final int len = Math.min(this.buf2.length, length);
            final int res = patch.read(this.buf2, 0, len);
            if (res == -1) {
                throw new EOFException("cannot read " + length);
            }
            output.write(this.buf2, 0, res);
            length -= res;
        }
    }
    
    public static void main(final String[] argv) {
        if (argv.length != 3) {
            System.err.println("usage GDiffPatch source patch output");
            System.err.println("aborting..");
            return;
        }
        try {
            final File sourceFile = new File(argv[0]);
            final File patchFile = new File(argv[1]);
            final File outputFile = new File(argv[2]);
            if (sourceFile.length() > 2147483647L || patchFile.length() > 2147483647L) {
                System.err.println("source or patch is too large, max length is 2147483647");
                System.err.println("aborting..");
                return;
            }
            final GDiffPatcher patcher = new GDiffPatcher();
            patcher.patch(sourceFile, patchFile, outputFile);
            System.out.println("finished patching file");
        }
        catch (final Exception ioe) {
            System.err.println("error while patching: " + ioe);
        }
    }
}



================================================
FILE: cpw/mods/fml/repackage/com/nothome/delta/GDiffWriter.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.repackage.com.nothome.delta;

import java.io.OutputStream;
import java.io.IOException;
import java.io.DataOutputStream;
import java.io.ByteArrayOutputStream;

public class GDiffWriter implements DiffWriter
{
    public static final int CHUNK_SIZE = 32767;
    public static final byte EOF = 0;
    public static final int DATA_MAX = 246;
    public static final int DATA_USHORT = 247;
    public static final int DATA_INT = 248;
    public static final int COPY_USHORT_UBYTE = 249;
    public static final int COPY_USHORT_USHORT = 250;
    public static final int COPY_USHORT_INT = 251;
    public static final int COPY_INT_UBYTE = 252;
    public static final int COPY_INT_USHORT = 253;
    public static final int COPY_INT_INT = 254;
    public static final int COPY_LONG_INT = 255;
    private ByteArrayOutputStream buf;
    private boolean debug;
    private DataOutputStream output;
    
    public GDiffWriter(final DataOutputStream os) throws IOException {
        this.buf = new ByteArrayOutputStream();
        this.debug = false;
        this.output = null;
        (this.output = os).writeByte(209);
        this.output.writeByte(255);
        this.output.writeByte(209);
        this.output.writeByte(255);
        this.output.writeByte(4);
    }
    
    public GDiffWriter(final OutputStream output) throws IOException {
        this(new DataOutputStream(output));
    }
    
    @Override
    public void addCopy(final long offset, final int length) throws IOException {
        this.writeBuf();
        if (this.debug) {
            System.err.println("COPY off: " + offset + ", len: " + length);
        }
        if (offset > 2147483647L) {
            this.output.writeByte(255);
            this.output.writeLong(offset);
            this.output.writeInt(length);
        }
        else if (offset < 65536L) {
            if (length < 256) {
                this.output.writeByte(249);
                this.output.writeShort((int)offset);
                this.output.writeByte(length);
            }
            else if (length > 65535) {
                this.output.writeByte(251);
                this.output.writeShort((int)offset);
                this.output.writeInt(length);
            }
            else {
                this.output.writeByte(250);
                this.output.writeShort((int)offset);
                this.output.writeShort(length);
            }
        }
        else if (length < 256) {
            this.output.writeByte(252);
            this.output.writeInt((int)offset);
            this.output.writeByte(length);
        }
        else if (length > 65535) {
            this.output.writeByte(254);
            this.output.writeInt((int)offset);
            this.output.writeInt(length);
        }
        else {
            this.output.writeByte(253);
            this.output.writeInt((int)offset);
            this.output.writeShort(length);
        }
    }
    
    @Override
    public void addData(final byte b) throws IOException {
        this.buf.write(b);
        if (this.buf.size() >= 32767) {
            this.writeBuf();
        }
    }
    
    private void writeBuf() throws IOException {
        if (this.buf.size() > 0) {
            if (this.buf.size() <= 246) {
                this.output.writeByte(this.buf.size());
            }
            else if (this.buf.size() <= 65535) {
                this.output.writeByte(247);
                this.output.writeShort(this.buf.size());
            }
            else {
                this.output.writeByte(248);
                this.output.writeInt(this.buf.size());
            }
            this.buf.writeTo(this.output);
            this.buf.reset();
        }
    }
    
    @Override
    public void flush() throws IOException {
        this.writeBuf();
        this.output.flush();
    }
    
    @Override
    public void close() throws IOException {
        this.flush();
        this.output.write(0);
        this.output.close();
    }
}



================================================
FILE: cpw/mods/fml/repackage/com/nothome/delta/PatchException.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.repackage.com.nothome.delta;

import java.io.IOException;

public class PatchException extends IOException
{
    private static final long serialVersionUID = 1L;
    
    public PatchException() {
    }
    
    public PatchException(final String msg) {
        super(msg);
    }
}



================================================
FILE: cpw/mods/fml/repackage/com/nothome/delta/RandomAccessFileSeekableSource.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.repackage.com.nothome.delta;

import java.nio.ByteBuffer;
import java.io.IOException;
import java.io.RandomAccessFile;

public class RandomAccessFileSeekableSource implements SeekableSource
{
    private RandomAccessFile raf;
    
    public RandomAccessFileSeekableSource(final RandomAccessFile raf) {
        if (raf == null) {
            throw new NullPointerException("raf");
        }
        this.raf = raf;
    }
    
    @Override
    public void seek(final long pos) throws IOException {
        this.raf.seek(pos);
    }
    
    public int read(final byte[] b, final int off, final int len) throws IOException {
        return this.raf.read(b, off, len);
    }
    
    public long length() throws IOException {
        return this.raf.length();
    }
    
    @Override
    public void close() throws IOException {
        this.raf.close();
    }
    
    @Override
    public int read(final ByteBuffer bb) throws IOException {
        final int c = this.raf.read(bb.array(), bb.position(), bb.remaining());
        if (c == -1) {
            return -1;
        }
        bb.position(bb.position() + c);
        return c;
    }
}



================================================
FILE: cpw/mods/fml/repackage/com/nothome/delta/SeekableSource.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.repackage.com.nothome.delta;

import java.nio.ByteBuffer;
import java.io.IOException;
import java.io.Closeable;

public interface SeekableSource extends Closeable
{
    void seek(final long p0) throws IOException;
    
    int read(final ByteBuffer p0) throws IOException;
}



================================================
FILE: cpw/mods/fml/server/FMLServerHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package cpw.mods.fml.server;

import java.io.InputStream;
import java.io.FileInputStream;
import java.util.regex.Matcher;
import java.util.Iterator;
import cpw.mods.fml.common.FMLLog;
import java.util.zip.ZipEntry;
import java.util.Collections;
import java.util.zip.ZipFile;
import java.io.File;
import java.io.IOException;
import cpw.mods.fml.common.ModContainer;
import cpw.mods.fml.common.registry.ItemData;
import com.google.common.collect.MapDifference;
import cpw.mods.fml.common.network.ModMissingPacket;
import cpw.mods.fml.common.network.EntitySpawnAdjustmentPacket;
import cpw.mods.fml.common.network.EntitySpawnPacket;
import cpw.mods.fml.common.registry.EntityRegistry;
import cpw.mods.fml.relauncher.Side;
import com.google.common.collect.ImmutableList;
import java.util.List;
import cpw.mods.fml.common.registry.GameData;
import cpw.mods.fml.common.registry.LanguageRegistry;
import cpw.mods.fml.common.Loader;
import cpw.mods.fml.common.FMLCommonHandler;
import java.util.regex.Pattern;
import net.minecraft.server.MinecraftServer;
import cpw.mods.fml.common.IFMLSidedHandler;

public class FMLServerHandler implements IFMLSidedHandler
{
    private static final FMLServerHandler INSTANCE;
    private MinecraftServer server;
    private static final Pattern assetENUSLang;
    
    private FMLServerHandler() {
        FMLCommonHandler.instance().beginLoading(this);
    }
    
    @Override
    public void beginServerLoading(final MinecraftServer minecraftServer) {
        this.server = minecraftServer;
        Loader.instance().loadMods();
    }
    
    @Override
    public void finishServerLoading() {
        Loader.instance().initializeMods();
        LanguageRegistry.reloadLanguageTable();
        GameData.initializeServerGate(1);
    }
    
    @Override
    public void haltGame(final String message, final Throwable exception) {
        throw new RuntimeException(message, exception);
    }
    
    @Override
    public MinecraftServer getServer() {
        return this.server;
    }
    
    public static FMLServerHandler instance() {
        return FMLServerHandler.INSTANCE;
    }
    
    @Override
    public List<String> getAdditionalBrandingInformation() {
        return (List<String>)ImmutableList.of();
    }
    
    @Override
    public Side getSide() {
        return Side.SERVER;
    }
    
    @Override
    public void showGuiScreen(final Object clientGuiElement) {
    }
    
    @Override
    public nn spawnEntityIntoClientWorld(final EntityRegistry.EntityRegistration er, final EntitySpawnPacket packet) {
        return null;
    }
    
    @Override
    public void adjustEntityLocationOnClient(final EntitySpawnAdjustmentPacket entitySpawnAdjustmentPacket) {
    }
    
    @Override
    public void sendPacket(final ey packet) {
        throw new RuntimeException("You cannot send a bare packet without a target on the server!");
    }
    
    @Override
    public void displayMissingMods(final ModMissingPacket modMissingPacket) {
    }
    
    @Override
    public void handleTinyPacket(final ez handler, final dr mapData) {
    }
    
    @Override
    public void setClientCompatibilityLevel(final byte compatibilityLevel) {
    }
    
    @Override
    public byte getClientCompatibilityLevel() {
        return 0;
    }
    
    @Override
    public boolean shouldServerShouldBeKilledQuietly() {
        return false;
    }
    
    @Override
    public void disconnectIDMismatch(final MapDifference<Integer, ItemData> s, final ez handler, final cm mgr) {
    }
    
    @Override
    public void addModAsResource(final ModContainer container) {
        final File source = container.getSource();
        try {
            if (source.isDirectory()) {
                this.searchDirForENUSLanguage(source, "");
            }
            else {
                this.searchZipForENUSLanguage(source);
            }
        }
        catch (final IOException ex) {}
    }
    
    private void searchZipForENUSLanguage(final File source) throws IOException {
        final ZipFile zf = new ZipFile(source);
        for (final ZipEntry ze : Collections.list(zf.entries())) {
            final Matcher matcher = FMLServerHandler.assetENUSLang.matcher(ze.getName());
            if (matcher.matches()) {
                FMLLog.fine("Injecting found translation data in zip file %s at %s into language system", source.getName(), ze.getName());
                bv.inject(zf.getInputStream(ze));
            }
        }
        zf.close();
    }
    
    private void searchDirForENUSLanguage(final File source, final String path) throws IOException {
        for (final File file : source.listFiles()) {
            final String currPath = path + file.getName();
            if (file.isDirectory()) {
                this.searchDirForENUSLanguage(file, currPath + '/');
            }
            final Matcher matcher = FMLServerHandler.assetENUSLang.matcher(currPath);
            if (matcher.matches()) {
                FMLLog.fine("Injecting found translation data at %s into language system", currPath);
                bv.inject((InputStream)new FileInputStream(file));
            }
        }
    }
    
    @Override
    public void updateResourcePackList() {
    }
    
    @Override
    public String getCurrentLanguage() {
        return "en_US";
    }
    
    @Override
    public void serverStopped() {
    }
    
    static {
        INSTANCE = new FMLServerHandler();
        assetENUSLang = Pattern.compile("assets/(.*)/lang/en_US.lang");
    }
}



================================================
FILE: ibxm/Channel.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package ibxm;

public class Channel
{
    public int pattern_loop_row;
    private Module module;
    private Instrument instrument;
    private Sample sample;
    private int[] global_volume;
    private int[] current_note;
    private boolean linear_periods;
    private boolean fast_volume_slides;
    private boolean key_on;
    private boolean silent;
    private int sample_idx;
    private int sample_frac;
    private int step;
    private int left_gain;
    private int right_gain;
    private int volume;
    private int panning;
    private int fine_tune;
    private int period;
    private int porta_period;
    private int key_add;
    private int tremolo_speed;
    private int tremolo_depth;
    private int tremolo_tick;
    private int tremolo_wave;
    private int tremolo_add;
    private int vibrato_speed;
    private int vibrato_depth;
    private int vibrato_tick;
    private int vibrato_wave;
    private int vibrato_add;
    private int volume_slide_param;
    private int portamento_param;
    private int retrig_param;
    private int volume_envelope_tick;
    private int panning_envelope_tick;
    private int effect_tick;
    private int trigger_tick;
    private int fade_out_volume;
    private int random_seed;
    private int log_2_sampling_rate;
    private static final int LOG_2_29024;
    private static final int LOG_2_8287;
    private static final int LOG_2_8363;
    private static final int LOG_2_1712;
    private static final int[] sine_table;
    
    public Channel(final Module mod, final int sampling_rate, final int[] global_vol) {
        this.module = mod;
        this.global_volume = global_vol;
        this.linear_periods = this.module.linear_periods;
        this.fast_volume_slides = this.module.fast_volume_slides;
        this.current_note = new int[5];
        this.log_2_sampling_rate = LogTable.log_2(sampling_rate);
    }
    
    public void reset() {
        this.tremolo_speed = 0;
        this.tremolo_depth = 0;
        this.tremolo_wave = 0;
        this.vibrato_speed = 0;
        this.vibrato_depth = 0;
        this.vibrato_wave = 0;
        this.volume_slide_param = 0;
        this.portamento_param = 0;
        this.retrig_param = 0;
        this.random_seed = 11256099;
        this.instrument = this.module.get_instrument(0);
        this.row(48, 256, 0, 0, 0);
    }
    
    public void resample(final int[] mixing_buffer, final int frame_offset, final int frames, final int quality) {
        if (!this.silent) {
            switch (quality) {
                default: {
                    this.sample.resample_nearest(this.sample_idx, this.sample_frac, this.step, this.left_gain, this.right_gain, mixing_buffer, frame_offset, frames);
                    break;
                }
                case 1: {
                    this.sample.resample_linear(this.sample_idx, this.sample_frac, this.step, this.left_gain, this.right_gain, mixing_buffer, frame_offset, frames);
                    break;
                }
                case 2: {
                    this.sample.resample_sinc(this.sample_idx, this.sample_frac, this.step, this.left_gain, this.right_gain, mixing_buffer, frame_offset, frames);
                    break;
                }
            }
        }
    }
    
    public void update_sample_idx(final int samples) {
        this.sample_frac += this.step * samples;
        this.sample_idx += this.sample_frac >> 15;
        this.sample_frac &= 0x7FFF;
    }
    
    public void set_volume(int vol) {
        if (vol < 0) {
            vol = 0;
        }
        if (vol > 64) {
            vol = 64;
        }
        this.volume = vol;
    }
    
    public void set_panning(int pan) {
        if (pan < 0) {
            pan = 0;
        }
        if (pan > 255) {
            pan = 255;
        }
        this.panning = pan;
    }
    
    public void row(final int key, final int inst_idx, final int volume_column, int effect, int effect_param) {
        effect &= 0xFF;
        if (effect >= 48) {
            effect = 0;
        }
        if (effect == 0 && effect_param != 0) {
            effect = 64;
        }
        if (effect == 14) {
            effect = 48 + ((effect_param & 0xF0) >> 4);
            effect_param &= 0xF;
        }
        if (effect == 33) {
            effect = 64 + ((effect_param & 0xF0) >> 4);
            effect_param &= 0xF;
        }
        this.current_note[0] = key;
        this.current_note[1] = inst_idx;
        this.current_note[2] = volume_column;
        this.current_note[3] = effect;
        this.current_note[4] = effect_param;
        this.effect_tick = 0;
        ++this.trigger_tick;
        this.update_envelopes();
        this.key_add = 0;
        this.vibrato_add = 0;
        this.tremolo_add = 0;
        if (effect != 61 || effect_param <= 0) {
            this.trigger(key, inst_idx, volume_column, effect);
            switch (volume_column & 0xF0) {
                case 0: {
                    break;
                }
                case 96: {
                    break;
                }
                case 112: {
                    break;
                }
                case 128: {
                    this.set_volume(this.volume - (volume_column & 0xF));
                    break;
                }
                case 144: {
                    this.set_volume(this.volume + (volume_column & 0xF));
                    break;
                }
                case 160: {
                    this.set_vibrato_speed(volume_column & 0xF);
                    break;
                }
                case 176: {
                    this.set_vibrato_depth(volume_column & 0xF);
                    this.vibrato();
                    break;
                }
                case 192: {
                    this.set_panning((volume_column & 0xF) << 4);
                    break;
                }
                case 208: {
                    break;
                }
                case 224: {
                    break;
                }
                case 240: {
                    this.set_portamento_param(volume_column & 0xF);
                    break;
                }
                default: {
                    this.set_volume(volume_column - 16);
                    break;
                }
            }
        }
        if (this.instrument.vibrato_depth > 0) {
            this.auto_vibrato();
        }
        switch (effect) {
            case 1: {
                this.set_portamento_param(effect_param);
                this.portamento_up();
                break;
            }
            case 2: {
                this.set_portamento_param(effect_param);
                this.portamento_down();
                break;
            }
            case 3: {
                this.set_portamento_param(effect_param);
                break;
            }
            case 4: {
                this.set_vibrato_speed((effect_param & 0xF0) >> 4);
                this.set_vibrato_depth(effect_param & 0xF);
                this.vibrato();
                break;
            }
            case 5: {
                this.set_volume_slide_param(effect_param);
                this.volume_slide();
                break;
            }
            case 6: {
                this.set_volume_slide_param(effect_param);
                this.vibrato();
                this.volume_slide();
                break;
            }
            case 7: {
                this.set_tremolo_speed((effect_param & 0xF0) >> 4);
                this.set_tremolo_depth(effect_param & 0xF);
                this.tremolo();
                break;
            }
            case 8: {
                this.set_panning(effect_param);
                break;
            }
            case 9: {
                this.set_sample_index(effect_param << 8);
                break;
            }
            case 10: {
                this.set_volume_slide_param(effect_param);
                this.volume_slide();
            }
            case 12: {
                this.set_volume(effect_param);
            }
            case 13: {}
            case 14: {}
            case 16: {
                this.set_global_volume(effect_param);
                break;
            }
            case 17: {
                this.set_volume_slide_param(effect_param);
                break;
            }
            case 20: {
                if (effect_param == 0) {
                    this.key_on = false;
                    break;
                }
                break;
            }
            case 21: {
                this.set_envelope_tick(effect_param);
                break;
            }
            case 25: {
                this.set_volume_slide_param(effect_param);
                break;
            }
            case 27: {
                this.set_retrig_param(effect_param);
                this.retrig_volume_slide();
                break;
            }
            case 29: {
                this.set_retrig_param(effect_param);
                this.tremor();
                break;
            }
            case 36: {
                this.set_vibrato_speed((effect_param & 0xF0) >> 4);
                this.set_vibrato_depth(effect_param & 0xF);
                this.fine_vibrato();
            }
            case 37: {}
            case 49: {
                this.set_portamento_param(0xF0 | effect_param);
                this.portamento_up();
                break;
            }
            case 50: {
                this.set_portamento_param(0xF0 | effect_param);
                this.portamento_down();
            }
            case 52: {
                this.set_vibrato_wave(effect_param);
            }
            case 53: {}
            case 55: {
                this.set_tremolo_wave(effect_param);
            }
            case 57: {
                this.set_retrig_param(effect_param);
                break;
            }
            case 58: {
                this.set_volume_slide_param(effect_param << 4 | 0xF);
                this.volume_slide();
                break;
            }
            case 59: {
                this.set_volume_slide_param(0xF0 | effect_param);
                this.volume_slide();
                break;
            }
            case 60: {
                if (effect_param == 0) {
                    this.set_volume(0);
                    break;
                }
                break;
            }
            case 61: {}
            case 62: {}
            case 63: {}
            case 65: {
                this.set_portamento_param(0xE0 | effect_param);
                this.portamento_up();
                break;
            }
            case 66: {
                this.set_portamento_param(0xE0 | effect_param);
                this.portamento_down();
                break;
            }
        }
        this.calculate_amplitude();
        this.calculate_frequency();
    }
    
    public void tick() {
        final int volume_column = this.current_note[2];
        final int effect = this.current_note[3];
        final int effect_param = this.current_note[4];
        ++this.effect_tick;
        Label_0734: {
            if (effect == 61 && effect_param == this.effect_tick) {
                this.row(this.current_note[0], this.current_note[1], volume_column, 0, 0);
            }
            else {
                ++this.trigger_tick;
                ++this.vibrato_tick;
                ++this.tremolo_tick;
                this.update_envelopes();
                this.key_add = 0;
                this.vibrato_add = 0;
                this.tremolo_add = 0;
                if (this.instrument.vibrato_depth > 0) {
                    this.auto_vibrato();
                }
                switch (volume_column & 0xF0) {
                    case 96: {
                        this.set_volume(this.volume - (volume_column & 0xF));
                        break;
                    }
                    case 112: {
                        this.set_volume(this.volume + (volume_column & 0xF));
                        break;
                    }
                    case 176: {
                        this.vibrato();
                        break;
                    }
                    case 208: {
                        this.set_panning(this.panning - (volume_column & 0xF));
                        break;
                    }
                    case 224: {
                        this.set_panning(this.panning + (volume_column & 0xF));
                        break;
                    }
                    case 240: {
                        this.tone_portamento();
                        break;
                    }
                }
                switch (effect) {
                    case 1: {
                        this.portamento_up();
                        break;
                    }
                    case 2: {
                        this.portamento_down();
                        break;
                    }
                    case 3: {
                        this.tone_portamento();
                        break;
                    }
                    case 4: {
                        this.vibrato();
                        break;
                    }
                    case 5: {
                        this.tone_portamento();
                        this.volume_slide();
                        break;
                    }
                    case 6: {
                        this.vibrato();
                        this.volume_slide();
                        break;
                    }
                    case 7: {
                        this.tremolo();
                        break;
                    }
                    case 10: {
                        this.volume_slide();
                        break;
                    }
                    case 17: {
                        this.global_volume_slide();
                        break;
                    }
                    case 20: {
                        if (this.effect_tick == effect_param) {
                            this.key_on = false;
                            break;
                        }
                        break;
                    }
                    case 25: {
                        this.panning_slide();
                        break;
                    }
                    case 27: {
                        this.retrig_volume_slide();
                        break;
                    }
                    case 29: {
                        this.tremor();
                        break;
                    }
                    case 36: {
                        this.fine_vibrato();
                        break;
                    }
                    case 57: {
                        this.retrig_volume_slide();
                        break;
                    }
                    case 60: {
                        if (this.effect_tick == effect_param) {
                            this.set_volume(0);
                            break;
                        }
                        break;
                    }
                    case 64: {
                        switch (this.effect_tick % 3) {
                            case 1: {
                                this.key_add = (effect_param & 0xF0) >> 4;
                                break Label_0734;
                            }
                            case 2: {
                                this.key_add = (effect_param & 0xF);
                                break Label_0734;
                            }
                        }
                        break;
                    }
                }
            }
        }
        this.calculate_amplitude();
        this.calculate_frequency();
    }
    
    private void set_vibrato_speed(final int speed) {
        if (speed > 0) {
            this.vibrato_speed = speed;
        }
    }
    
    private void set_vibrato_depth(final int depth) {
        if (depth > 0) {
            this.vibrato_depth = depth;
        }
    }
    
    private void set_vibrato_wave(int wave) {
        if (wave < 0 || wave > 7) {
            wave = 0;
        }
        this.vibrato_wave = wave;
    }
    
    private void set_tremolo_speed(final int speed) {
        if (speed > 0) {
            this.tremolo_speed = speed;
        }
    }
    
    private void set_tremolo_depth(final int depth) {
        if (depth > 0) {
            this.tremolo_depth = depth;
        }
    }
    
    private void set_tremolo_wave(int wave) {
        if (wave < 0 || wave > 7) {
            wave = 0;
        }
        this.tremolo_wave = wave;
    }
    
    private void vibrato() {
        final int vibrato_phase = this.vibrato_tick * this.vibrato_speed;
        this.vibrato_add += this.waveform(vibrato_phase, this.vibrato_wave) * this.vibrato_depth >> 5;
    }
    
    private void fine_vibrato() {
        final int vibrato_phase = this.vibrato_tick * this.vibrato_speed;
        this.vibrato_add += this.waveform(vibrato_phase, this.vibrato_wave) * this.vibrato_depth >> 7;
    }
    
    private void tremolo() {
        final int tremolo_phase = this.tremolo_tick * this.tremolo_speed;
        this.tremolo_add += this.waveform(tremolo_phase, this.tremolo_wave) * this.tremolo_depth >> 6;
    }
    
    private void set_portamento_param(final int param) {
        if (param != 0) {
            this.portamento_param = param;
        }
    }
    
    private void tone_portamento() {
        if (this.porta_period < this.period) {
            int new_period = this.period - (this.portamento_param << 2);
            if (new_period < this.porta_period) {
                new_period = this.porta_period;
            }
            this.set_period(new_period);
        }
        if (this.porta_period > this.period) {
            int new_period = this.period + (this.portamento_param << 2);
            if (new_period > this.porta_period) {
                new_period = this.porta_period;
            }
            this.set_period(new_period);
        }
    }
    
    private void portamento_up() {
        if ((this.portamento_param & 0xF0) == 0xE0) {
            if (this.effect_tick == 0) {
                this.set_period(this.period - (this.portamento_param & 0xF));
            }
        }
        else if ((this.portamento_param & 0xF0) == 0xF0) {
            if (this.effect_tick == 0) {
                this.set_period(this.period - ((this.portamento_param & 0xF) << 2));
            }
        }
        else if (this.effect_tick > 0) {
            this.set_period(this.period - (this.portamento_param << 2));
        }
    }
    
    private void portamento_down() {
        if ((this.portamento_param & 0xF0) == 0xE0) {
            if (this.effect_tick == 0) {
                this.set_period(this.period + (this.portamento_param & 0xF));
            }
        }
        else if ((this.portamento_param & 0xF0) == 0xF0) {
            if (this.effect_tick == 0) {
                this.set_period(this.period + ((this.portamento_param & 0xF) << 2));
            }
        }
        else if (this.effect_tick > 0) {
            this.set_period(this.period + (this.portamento_param << 2));
        }
    }
    
    private void set_period(int p) {
        if (p < 32) {
            p = 32;
        }
        if (p > 32768) {
            p = 32768;
        }
        this.period = p;
    }
    
    private void set_global_volume(int vol) {
        if (vol < 0) {
            vol = 0;
        }
        if (vol > 64) {
            vol = 64;
        }
        this.global_volume[0] = vol;
    }
    
    private void set_volume_slide_param(final int param) {
        if (param != 0) {
            this.volume_slide_param = param;
        }
    }
    
    private void global_volume_slide() {
        final int up = (this.volume_slide_param & 0xF0) >> 4;
        final int down = this.volume_slide_param & 0xF;
        this.set_global_volume(this.global_volume[0] + up - down);
    }
    
    private void volume_slide() {
        final int up = (this.volume_slide_param & 0xF0) >> 4;
        final int down = this.volume_slide_param & 0xF;
        if (down == 15 && up > 0) {
            if (this.effect_tick == 0) {
                this.set_volume(this.volume + up);
            }
        }
        else if (up == 15 && down > 0) {
            if (this.effect_tick == 0) {
                this.set_volume(this.volume - down);
            }
        }
        else if (this.effect_tick > 0 || this.fast_volume_slides) {
            this.set_volume(this.volume + up - down);
        }
    }
    
    private void panning_slide() {
        final int left = (this.volume_slide_param & 0xF0) >> 4;
        final int right = this.volume_slide_param & 0xF;
        this.set_panning(this.panning - left + right);
    }
    
    private void set_retrig_param(final int param) {
        if (param != 0) {
            this.retrig_param = param;
        }
    }
    
    private void tremor() {
        final int on_ticks = ((this.retrig_param & 0xF0) >> 4) + 1;
        final int cycle_length = on_ticks + (this.retrig_param & 0xF) + 1;
        final int cycle_index = this.trigger_tick % cycle_length;
        if (cycle_index >= on_ticks) {
            this.tremolo_add = -64;
        }
    }
    
    private void retrig_volume_slide() {
        final int retrig_volume = (this.retrig_param & 0xF0) >> 4;
        final int retrig_tick = this.retrig_param & 0xF;
        if (retrig_tick > 0 && this.trigger_tick % retrig_tick == 0) {
            this.set_sample_index(0);
            switch (retrig_volume) {
                case 1: {
                    this.set_volume(this.volume - 1);
                    break;
                }
                case 2: {
                    this.set_volume(this.volume - 2);
                    break;
                }
                case 3: {
                    this.set_volume(this.volume - 4);
                    break;
                }
                case 4: {
                    this.set_volume(this.volume - 8);
                    break;
                }
                case 5: {
                    this.set_volume(this.volume - 16);
                    break;
                }
                case 6: {
                    this.set_volume(this.volume - this.volume / 3);
                    break;
                }
                case 7: {
                    this.set_volume(this.volume / 2);
                    break;
                }
                case 9: {
                    this.set_volume(this.volume + 1);
                    break;
                }
                case 10: {
                    this.set_volume(this.volume + 2);
                    break;
                }
                case 11: {
                    this.set_volume(this.volume + 4);
                    break;
                }
                case 12: {
                    this.set_volume(this.volume + 8);
                    break;
                }
                case 13: {
                    this.set_volume(this.volume + 16);
                    break;
                }
                case 14: {
                    this.set_volume(this.volume + this.volume / 2);
                    break;
                }
                case 15: {
                    this.set_volume(this.volume * 2);
                    break;
                }
            }
        }
    }
    
    private void set_sample_index(int index) {
        if (index < 0) {
            index = 0;
        }
        this.sample_idx = index;
        this.sample_frac = 0;
    }
    
    private void set_envelope_tick(final int tick) {
        this.volume_envelope_tick = tick;
        this.panning_envelope_tick = tick;
    }
    
    private void trigger(final int key, final int instrument_idx, final int volume_column, final int effect) {
        if (instrument_idx > 0) {
            this.instrument = this.module.get_instrument(instrument_idx);
            this.sample = this.instrument.get_sample_from_key(key);
            this.set_volume(this.sample.volume);
            if (this.sample.set_panning) {
                this.set_panning(this.sample.panning);
            }
            this.set_envelope_tick(0);
            this.fade_out_volume = 32768;
            this.key_on = true;
        }
        if (key > 0) {
            if (key < 97) {
                this.porta_period = this.key_to_period(key);
                if (effect != 3 && effect != 5 && (volume_column & 0xF0) != 0xF0) {
                    this.trigger_tick = 0;
                    if (this.vibrato_wave < 4) {
                        this.vibrato_tick = 0;
                    }
                    if (this.tremolo_wave < 4) {
                        this.tremolo_tick = 0;
                    }
                    this.set_period(this.porta_period);
                    this.set_sample_index(0);
                }
            }
            else {
                this.key_on = false;
            }
        }
    }
    
    private void update_envelopes() {
        if (this.instrument.volume_envelope_active) {
            if (!this.key_on) {
                this.fade_out_volume -= (this.instrument.volume_fade_out & 0xFFFF);
                if (this.fade_out_volume < 0) {
                    this.fade_out_volume = 0;
                }
            }
            final Envelope envelope = this.instrument.get_volume_envelope();
            this.volume_envelope_tick = envelope.next_tick(this.volume_envelope_tick, this.key_on);
        }
        if (this.instrument.panning_envelope_active) {
            final Envelope envelope = this.instrument.get_panning_envelope();
            this.panning_envelope_tick = envelope.next_tick(this.panning_envelope_tick, this.key_on);
        }
    }
    
    private void auto_vibrato() {
        final int sweep = this.instrument.vibrato_sweep & 0xFF;
        int depth = this.instrument.vibrato_depth & 0xF;
        final int rate = this.instrument.vibrato_rate & 0x3F;
        if (this.trigger_tick < sweep) {
            depth = depth * this.trigger_tick / sweep;
        }
        this.vibrato_add += this.waveform(this.trigger_tick * rate, 0) * depth >> 9;
    }
    
    private int waveform(final int phase, final int wform) {
        int amplitude = 0;
        switch (wform & 0x3) {
            case 0: {
                if ((phase & 0x20) == 0x0) {
                    amplitude = Channel.sine_table[phase & 0x1F];
                    break;
                }
                amplitude = -Channel.sine_table[phase & 0x1F];
                break;
            }
            case 1: {
                if ((phase & 0x20) == 0x0) {
                    amplitude = (phase & 0x1F) << 3;
                    break;
                }
                amplitude = ((phase & 0x1F) << 3) - 255;
                break;
            }
            case 2: {
                if ((phase & 0x20) == 0x0) {
                    amplitude = 255;
                    break;
                }
                amplitude = -255;
                break;
            }
            case 3: {
                amplitude = (this.random_seed >> 15) - 255;
                this.random_seed = (this.random_seed * 65 + 17 & 0xFFFFFF);
                break;
            }
        }
        return amplitude;
    }
    
    private int key_to_period(final int key) {
        final int octave = (key << 15) / 12 + this.sample.transpose;
        int period_out;
        if (this.linear_periods) {
            period_out = 7744 - (octave * 768 >> 15);
        }
        else {
            final int log_2_period = Channel.LOG_2_29024 - octave;
            period_out = LogTable.raise_2(log_2_period);
            period_out >>= 14;
            period_out = (period_out >> 1) + (period_out & 0x1);
        }
        return period_out;
    }
    
    private void calculate_amplitude() {
        int envelope_volume = 0;
        if (this.instrument.volume_envelope_active) {
            final Envelope envelope = this.instrument.get_volume_envelope();
            envelope_volume = envelope.calculate_ampl(this.volume_envelope_tick);
        }
        else if (this.key_on) {
            envelope_volume = 64;
        }
        int tremolo_volume = this.volume + this.tremolo_add;
        if (tremolo_volume < 0) {
            tremolo_volume = 0;
        }
        if (tremolo_volume > 64) {
            tremolo_volume = 64;
        }
        int amplitude = tremolo_volume << 9;
        amplitude = amplitude * envelope_volume >> 6;
        amplitude = amplitude * this.fade_out_volume >> 15;
        amplitude = amplitude * this.global_volume[0] >> 6;
        amplitude = amplitude * this.module.channel_gain >> 15;
        this.silent = this.sample.has_finished(this.sample_idx);
        if (amplitude <= 0) {
            this.silent = true;
        }
        else {
            int envelope_panning = 32;
            if (this.instrument.panning_envelope_active) {
                final Envelope envelope = this.instrument.get_panning_envelope();
                envelope_panning = envelope.calculate_ampl(this.panning_envelope_tick);
            }
            int mixer_panning = (this.panning & 0xFF) << 7;
            int panning_range = 32768 - mixer_panning;
            if (panning_range > mixer_panning) {
                panning_range = mixer_panning;
            }
            mixer_panning += panning_range * (envelope_panning - 32) >> 5;
            this.left_gain = amplitude * (32768 - mixer_panning) >> 15;
            this.right_gain = amplitude * mixer_panning >> 15;
        }
    }
    
    private void calculate_frequency() {
        int vibrato_period = this.period + this.vibrato_add;
        if (vibrato_period < 32) {
            vibrato_period = 32;
        }
        if (vibrato_period > 32768) {
            vibrato_period = 32768;
        }
        int log_2_freq;
        if (this.linear_periods) {
            log_2_freq = Channel.LOG_2_8363 + (4608 - vibrato_period << 15) / 768;
        }
        else {
            log_2_freq = (this.module.pal ? Channel.LOG_2_8287 : Channel.LOG_2_8363);
            log_2_freq = log_2_freq + Channel.LOG_2_1712 - LogTable.log_2(vibrato_period);
        }
        log_2_freq += (this.key_add << 15) / 12;
        this.step = LogTable.raise_2(log_2_freq - this.log_2_sampling_rate);
    }
    
    static {
        LOG_2_29024 = LogTable.log_2(29024);
        LOG_2_8287 = LogTable.log_2(8287);
        LOG_2_8363 = LogTable.log_2(8363);
        LOG_2_1712 = LogTable.log_2(1712);
        sine_table = new int[] { 0, 24, 49, 74, 97, 120, 141, 161, 180, 197, 212, 224, 235, 244, 250, 253, 255, 253, 250, 244, 235, 224, 212, 197, 180, 161, 141, 120, 97, 74, 49, 24 };
    }
}



================================================
FILE: ibxm/Envelope.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package ibxm;

public class Envelope
{
    public boolean sustain;
    public boolean looped;
    private int sustain_tick;
    private int loop_start_tick;
    private int loop_end_tick;
    private int[] ticks;
    private int[] ampls;
    
    public Envelope() {
        this.set_num_points(1);
    }
    
    public void set_num_points(int num_points) {
        if (num_points <= 0) {
            num_points = 1;
        }
        this.ticks = new int[num_points];
        this.ampls = new int[num_points];
        this.set_point(0, 0, 0, false);
    }
    
    public void set_point(int point, int tick, final int ampl, final boolean delta) {
        if (point >= 0 && point < this.ticks.length) {
            if (point == 0) {
                tick = 0;
            }
            if (point > 0) {
                if (delta) {
                    tick += this.ticks[point - 1];
                }
                if (tick <= this.ticks[point - 1]) {
                    System.out.println("Envelope: Point not valid (" + tick + " <= " + this.ticks[point - 1] + ")");
                    tick = this.ticks[point - 1] + 1;
                }
            }
            this.ticks[point] = tick;
            this.ampls[point] = ampl;
            ++point;
            while (point < this.ticks.length) {
                this.ticks[point] = this.ticks[point - 1] + 1;
                this.ampls[point] = 0;
                ++point;
            }
        }
    }
    
    public void set_sustain_point(int point) {
        if (point < 0) {
            point = 0;
        }
        if (point >= this.ticks.length) {
            point = this.ticks.length - 1;
        }
        this.sustain_tick = this.ticks[point];
    }
    
    public void set_loop_points(int start, int end) {
        if (start < 0) {
            start = 0;
        }
        if (start >= this.ticks.length) {
            start = this.ticks.length - 1;
        }
        if (end < start || end >= this.ticks.length) {
            end = start;
        }
        this.loop_start_tick = this.ticks[start];
        this.loop_end_tick = this.ticks[end];
    }
    
    public int next_tick(int tick, final boolean key_on) {
        ++tick;
        if (this.looped && tick >= this.loop_end_tick) {
            tick = this.loop_start_tick;
        }
        if (this.sustain && key_on && tick >= this.sustain_tick) {
            tick = this.sustain_tick;
        }
        return tick;
    }
    
    public int calculate_ampl(final int tick) {
        int ampl = this.ampls[this.ticks.length - 1];
        if (tick < this.ticks[this.ticks.length - 1]) {
            int point = 0;
            for (int idx = 1; idx < this.ticks.length; ++idx) {
                if (this.ticks[idx] <= tick) {
                    point = idx;
                }
            }
            final int delta_t = this.ticks[point + 1] - this.ticks[point];
            final int delta_a = this.ampls[point + 1] - this.ampls[point];
            ampl = (delta_a << 15) / delta_t;
            ampl = ampl * (tick - this.ticks[point]) >> 15;
            ampl += this.ampls[point];
        }
        return ampl;
    }
    
    public void dump() {
        for (int idx = 0; idx < this.ticks.length; ++idx) {
            System.out.println(this.ticks[idx] + ", " + this.ampls[idx]);
        }
        for (int tick = 0; tick < 222; ++tick) {
            System.out.print(this.calculate_ampl(tick) + ", ");
        }
    }
}



================================================
FILE: ibxm/FastTracker2.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package ibxm;

import java.io.UnsupportedEncodingException;
import java.io.IOException;
import java.io.EOFException;
import java.io.DataInput;

public class FastTracker2
{
    public static boolean is_xm(final byte[] header_60_bytes) {
        final String xm_identifier = ascii_text(header_60_bytes, 0, 17);
        return xm_identifier.equals("Extended Module: ");
    }
    
    public static Module load_xm(final byte[] header_60_bytes, final DataInput data_input) throws IOException {
        if (!is_xm(header_60_bytes)) {
            throw new IllegalArgumentException("Not an XM file!");
        }
        final int xm_version = unsigned_short_le(header_60_bytes, 58);
        if (xm_version != 260) {
            throw new IllegalArgumentException("Sorry, XM version " + xm_version + " is not supported!");
        }
        final Module module = new Module();
        module.song_title = ascii_text(header_60_bytes, 17, 20);
        final String tracker_name = ascii_text(header_60_bytes, 38, 20);
        final boolean delta_env = tracker_name.startsWith("DigiBooster Pro");
        final byte[] structure_header = new byte[4];
        data_input.readFully(structure_header);
        final int song_header_length = int_le(structure_header, 0);
        final byte[] song_header = new byte[song_header_length];
        data_input.readFully(song_header, 4, song_header_length - 4);
        final int sequence_length = unsigned_short_le(song_header, 4);
        module.restart_sequence_index = unsigned_short_le(song_header, 6);
        final int num_channels = unsigned_short_le(song_header, 8);
        final int num_patterns = unsigned_short_le(song_header, 10);
        final int num_instruments = unsigned_short_le(song_header, 12);
        final int xm_flags = unsigned_short_le(song_header, 14);
        module.linear_periods = ((xm_flags & 0x1) == 0x1);
        module.global_volume = 64;
        module.channel_gain = 12288;
        module.default_speed = unsigned_short_le(song_header, 16);
        module.default_tempo = unsigned_short_le(song_header, 18);
        module.set_num_channels(num_channels);
        for (int idx = 0; idx < num_channels; ++idx) {
            module.set_initial_panning(idx, 128);
        }
        module.set_sequence_length(sequence_length);
        for (int idx = 0; idx < sequence_length; ++idx) {
            module.set_sequence(idx, song_header[20 + idx] & 0xFF);
        }
        module.set_num_patterns(num_patterns);
        for (int idx = 0; idx < num_patterns; ++idx) {
            module.set_pattern(idx, read_xm_pattern(data_input, num_channels));
        }
        module.set_num_instruments(num_instruments);
        for (int idx = 1; idx <= num_instruments; ++idx) {
            try {
                final Instrument instrument = read_xm_instrument(data_input, delta_env);
                module.set_instrument(idx, instrument);
            }
            catch (final EOFException e) {
                System.out.println("Instrument " + idx + " is missing!");
            }
        }
        return module;
    }
    
    private static Pattern read_xm_pattern(final DataInput data_input, final int num_channels) throws IOException {
        final byte[] structure_header = new byte[4];
        data_input.readFully(structure_header);
        final int pattern_header_length = int_le(structure_header, 0);
        final byte[] pattern_header = new byte[pattern_header_length];
        data_input.readFully(pattern_header, 4, pattern_header_length - 4);
        final int packing_type = pattern_header[4];
        if (packing_type != 0) {
            throw new IllegalArgumentException("Pattern packing type " + packing_type + " is not supported!");
        }
        final Pattern pattern = new Pattern();
        pattern.num_rows = unsigned_short_le(pattern_header, 5);
        final int pattern_data_length = unsigned_short_le(pattern_header, 7);
        final byte[] pattern_data = new byte[pattern_data_length];
        data_input.readFully(pattern_data);
        pattern.set_pattern_data(pattern_data);
        return pattern;
    }
    
    private static Instrument read_xm_instrument(final DataInput data_input, final boolean delta_env) throws IOException {
        final byte[] structure_header = new byte[4];
        data_input.readFully(structure_header);
        final int instrument_header_length = int_le(structure_header, 0);
        final byte[] instrument_header = new byte[instrument_header_length];
        data_input.readFully(instrument_header, 4, instrument_header_length - 4);
        final Instrument instrument = new Instrument();
        instrument.name = ascii_text(instrument_header, 4, 22);
        final int num_samples = unsigned_short_le(instrument_header, 27);
        if (num_samples > 0) {
            instrument.set_num_samples(num_samples);
            for (int idx = 0; idx < 96; ++idx) {
                instrument.set_key_to_sample(idx + 1, instrument_header[33 + idx] & 0xFF);
            }
            Envelope envelope = new Envelope();
            int env_num_points = instrument_header[225] & 0xFF;
            envelope.set_num_points(env_num_points);
            for (int idx = 0; idx < env_num_points; ++idx) {
                final int env_tick = unsigned_short_le(instrument_header, 129 + idx * 4);
                final int env_ampl = unsigned_short_le(instrument_header, 131 + idx * 4);
                envelope.set_point(idx, env_tick, env_ampl, delta_env);
            }
            envelope.set_sustain_point(instrument_header[227] & 0xFF);
            envelope.set_loop_points(instrument_header[228] & 0xFF, instrument_header[229] & 0xFF);
            int flags = instrument_header[233] & 0xFF;
            instrument.volume_envelope_active = ((flags & 0x1) == 0x1);
            envelope.sustain = ((flags & 0x2) == 0x2);
            envelope.looped = ((flags & 0x4) == 0x4);
            instrument.set_volume_envelope(envelope);
            envelope = new Envelope();
            env_num_points = (instrument_header[226] & 0xFF);
            envelope.set_num_points(env_num_points);
            for (int idx = 0; idx < env_num_points; ++idx) {
                final int env_tick = unsigned_short_le(instrument_header, 177 + idx * 4);
                final int env_ampl = unsigned_short_le(instrument_header, 179 + idx * 4);
                envelope.set_point(idx, env_tick, env_ampl, delta_env);
            }
            envelope.set_sustain_point(instrument_header[230] & 0xFF);
            envelope.set_loop_points(instrument_header[231] & 0xFF, instrument_header[232] & 0xFF);
            flags = (instrument_header[234] & 0xFF);
            instrument.panning_envelope_active = ((flags & 0x1) == 0x1);
            envelope.sustain = ((flags & 0x2) == 0x2);
            envelope.looped = ((flags & 0x4) == 0x4);
            instrument.set_panning_envelope(envelope);
            instrument.vibrato_type = (instrument_header[235] & 0xFF);
            instrument.vibrato_sweep = (instrument_header[236] & 0xFF);
            instrument.vibrato_depth = (instrument_header[237] & 0xFF);
            instrument.vibrato_rate = (instrument_header[238] & 0xFF);
            instrument.volume_fade_out = unsigned_short_le(instrument_header, 239);
            final byte[] sample_headers = new byte[num_samples * 40];
            data_input.readFully(sample_headers);
            for (int idx = 0; idx < num_samples; ++idx) {
                instrument.set_sample(idx, read_xm_sample(sample_headers, idx, data_input));
            }
        }
        return instrument;
    }
    
    private static Sample read_xm_sample(final byte[] sample_headers, final int sample_idx, final DataInput data_input) throws IOException {
        final int header_offset = sample_idx * 40;
        final Sample sample = new Sample();
        final int sample_length = int_le(sample_headers, header_offset);
        final int loop_start = int_le(sample_headers, header_offset + 4);
        int loop_length = int_le(sample_headers, header_offset + 8);
        sample.volume = (sample_headers[header_offset + 12] & 0xFF);
        int fine_tune = sample_headers[header_offset + 13];
        fine_tune = (fine_tune << 15) / 1536;
        sample.set_panning = true;
        final int flags = sample_headers[header_offset + 14] & 0xFF;
        if ((flags & 0x3) == 0x0) {
            loop_length = 0;
        }
        final boolean ping_pong = (flags & 0x2) == 0x2;
        final boolean sixteen_bit = (flags & 0x10) == 0x10;
        sample.panning = (sample_headers[header_offset + 15] & 0xFF);
        int relative_note = sample_headers[header_offset + 16];
        relative_note = (relative_note << 15) / 12;
        sample.transpose = relative_note + fine_tune;
        sample.name = ascii_text(sample_headers, header_offset + 18, 22);
        final byte[] raw_sample_data = new byte[sample_length];
        try {
            data_input.readFully(raw_sample_data);
        }
        catch (final EOFException e) {
            System.out.println("Sample has been truncated!");
        }
        int in_idx = 0;
        int out_idx = 0;
        int sam = 0;
        int last_sam = 0;
        if (sixteen_bit) {
            final short[] decoded_sample_data = new short[sample_length >> 1];
            while (in_idx < raw_sample_data.length) {
                sam = (raw_sample_data[in_idx] & 0xFF);
                sam |= (raw_sample_data[in_idx + 1] & 0xFF) << 8;
                last_sam += sam;
                decoded_sample_data[out_idx] = (short)last_sam;
                in_idx += 2;
                ++out_idx;
            }
            sample.set_sample_data(decoded_sample_data, loop_start >> 1, loop_length >> 1, ping_pong);
        }
        else {
            final short[] decoded_sample_data = new short[sample_length];
            while (in_idx < raw_sample_data.length) {
                sam = (raw_sample_data[in_idx] & 0xFF);
                last_sam += sam;
                decoded_sample_data[out_idx] = (short)(last_sam << 8);
                ++in_idx;
                ++out_idx;
            }
            sample.set_sample_data(decoded_sample_data, loop_start, loop_length, ping_pong);
        }
        return sample;
    }
    
    private static int unsigned_short_le(final byte[] buffer, final int offset) {
        int value = buffer[offset] & 0xFF;
        value |= (buffer[offset + 1] & 0xFF) << 8;
        return value;
    }
    
    private static int int_le(final byte[] buffer, final int offset) {
        int value = buffer[offset] & 0xFF;
        value |= (buffer[offset + 1] & 0xFF) << 8;
        value |= (buffer[offset + 2] & 0xFF) << 16;
        value |= (buffer[offset + 3] & 0x7F) << 24;
        return value;
    }
    
    private static String ascii_text(final byte[] buffer, final int offset, final int length) {
        final byte[] string_buffer = new byte[length];
        for (int idx = 0; idx < length; ++idx) {
            int chr = buffer[offset + idx];
            if (chr < 32) {
                chr = 32;
            }
            string_buffer[idx] = (byte)chr;
        }
        String string;
        try {
            string = new String(string_buffer, 0, length, "ISO-8859-1");
        }
        catch (final UnsupportedEncodingException e) {
            string = "";
        }
        return string;
    }
}



================================================
FILE: ibxm/IBXM.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package ibxm;

public class IBXM
{
    public static final String VERSION = "ibxm alpha 51 (c)2008 mumart@gmail.com";
    public static final int FP_SHIFT = 15;
    public static final int FP_ONE = 32768;
    public static final int FP_MASK = 32767;
    private int sampling_rate;
    private int resampling_quality;
    private int volume_ramp_length;
    private int tick_length_samples;
    private int current_tick_samples;
    private int[] mixing_buffer;
    private int[] volume_ramp_buffer;
    private Module module;
    private Channel[] channels;
    private int[] global_volume;
    private int[] note;
    private int current_sequence_index;
    private int next_sequence_index;
    private int current_row;
    private int next_row;
    private int tick_counter;
    private int ticks_per_row;
    private int pattern_loop_count;
    private int pattern_loop_channel;
    
    public IBXM(int sample_rate) {
        if (sample_rate < 8000) {
            sample_rate = 8000;
        }
        this.sampling_rate = sample_rate;
        this.volume_ramp_length = this.sampling_rate >> 10;
        this.volume_ramp_buffer = new int[this.volume_ramp_length * 2];
        this.mixing_buffer = new int[this.sampling_rate / 6];
        this.global_volume = new int[1];
        this.note = new int[5];
        this.set_module(new Module());
        this.set_resampling_quality(1);
    }
    
    public void set_module(final Module m) {
        this.module = m;
        this.channels = new Channel[this.module.get_num_channels()];
        for (int channel_idx = 0; channel_idx < this.channels.length; ++channel_idx) {
            this.channels[channel_idx] = new Channel(this.module, this.sampling_rate, this.global_volume);
        }
        this.set_sequence_index(0, 0);
    }
    
    public void set_resampling_quality(final int quality) {
        this.resampling_quality = quality;
    }
    
    public int calculate_song_duration() {
        this.set_sequence_index(0, 0);
        this.next_tick();
        int song_duration = this.tick_length_samples;
        while (!this.next_tick()) {
            song_duration += this.tick_length_samples;
        }
        this.set_sequence_index(0, 0);
        return song_duration;
    }
    
    public void set_sequence_index(final int sequence_index, final int row) {
        this.global_volume[0] = 64;
        for (int channel_idx = 0; channel_idx < this.channels.length; ++channel_idx) {
            this.channels[channel_idx].reset();
            this.channels[channel_idx].set_panning(this.module.get_initial_panning(channel_idx));
        }
        this.set_global_volume(this.module.global_volume);
        this.set_speed(6);
        this.set_speed(this.module.default_speed);
        this.set_tempo(125);
        this.set_tempo(this.module.default_tempo);
        this.pattern_loop_count = -1;
        this.next_sequence_index = sequence_index;
        this.next_row = row;
        this.tick_counter = 0;
        this.current_tick_samples = this.tick_length_samples;
        this.clear_vol_ramp_buffer();
    }
    
    public void seek(int sample_position) {
        this.set_sequence_index(0, 0);
        this.next_tick();
        while (sample_position > this.tick_length_samples) {
            sample_position -= this.tick_length_samples;
            this.next_tick();
        }
        this.mix_tick();
        this.current_tick_samples = sample_position;
    }
    
    public void get_audio(final byte[] output_buffer, int frames) {
        int output_idx = 0;
        while (frames > 0) {
            int count = this.tick_length_samples - this.current_tick_samples;
            if (count > frames) {
                count = frames;
            }
            int mix_idx = this.current_tick_samples << 1;
            for (int mix_end = mix_idx + (count << 1) - 1; mix_idx <= mix_end; ++mix_idx) {
                int amplitude = this.mixing_buffer[mix_idx];
                if (amplitude > 32767) {
                    amplitude = 32767;
                }
                if (amplitude < -32768) {
                    amplitude = -32768;
                }
                output_buffer[output_idx] = (byte)(amplitude >> 8);
                output_buffer[output_idx + 1] = (byte)(amplitude & 0xFF);
                output_idx += 2;
            }
            this.current_tick_samples = mix_idx >> 1;
            frames -= count;
            if (frames > 0) {
                this.next_tick();
                this.mix_tick();
                this.current_tick_samples = 0;
            }
        }
    }
    
    private void mix_tick() {
        for (int mix_idx = 0, mix_len = this.tick_length_samples + this.volume_ramp_length << 1; mix_idx < mix_len; ++mix_idx) {
            this.mixing_buffer[mix_idx] = 0;
        }
        for (int channel_idx = 0; channel_idx < this.channels.length; ++channel_idx) {
            final int mix_len = this.tick_length_samples + this.volume_ramp_length;
            this.channels[channel_idx].resample(this.mixing_buffer, 0, mix_len, this.resampling_quality);
        }
        this.volume_ramp();
    }
    
    private boolean next_tick() {
        for (int channel_idx = 0; channel_idx < this.channels.length; ++channel_idx) {
            this.channels[channel_idx].update_sample_idx(this.tick_length_samples);
        }
        --this.tick_counter;
        boolean song_end;
        if (this.tick_counter <= 0) {
            this.tick_counter = this.ticks_per_row;
            song_end = this.next_row();
        }
        else {
            for (int channel_idx = 0; channel_idx < this.channels.length; ++channel_idx) {
                this.channels[channel_idx].tick();
            }
            song_end = false;
        }
        return song_end;
    }
    
    private boolean next_row() {
        boolean song_end = false;
        if (this.next_sequence_index < 0) {
            this.next_sequence_index = 0;
            this.next_row = 0;
        }
        if (this.next_sequence_index >= this.module.get_sequence_length()) {
            song_end = true;
            this.next_sequence_index = this.module.restart_sequence_index;
            if (this.next_sequence_index < 0) {
                this.next_sequence_index = 0;
            }
            if (this.next_sequence_index >= this.module.get_sequence_length()) {
                this.next_sequence_index = 0;
            }
            this.next_row = 0;
        }
        if (this.next_sequence_index < this.current_sequence_index) {
            song_end = true;
        }
        if (this.next_sequence_index == this.current_sequence_index && this.next_row <= this.current_row && this.pattern_loop_count < 0) {
            song_end = true;
        }
        this.current_sequence_index = this.next_sequence_index;
        final Pattern pattern = this.module.get_pattern_from_sequence(this.current_sequence_index);
        if (this.next_row < 0 || this.next_row >= pattern.num_rows) {
            this.next_row = 0;
        }
        this.current_row = this.next_row;
        this.next_row = this.current_row + 1;
        if (this.next_row >= pattern.num_rows) {
            this.next_sequence_index = this.current_sequence_index + 1;
            this.next_row = 0;
        }
        for (int channel_idx = 0; channel_idx < this.channels.length; ++channel_idx) {
            pattern.get_note(this.note, this.current_row * this.channels.length + channel_idx);
            final int effect = this.note[3];
            final int effect_param = this.note[4];
            this.channels[channel_idx].row(this.note[0], this.note[1], this.note[2], effect, effect_param);
            switch (effect) {
                case 11: {
                    if (this.pattern_loop_count < 0) {
                        this.next_sequence_index = effect_param;
                        this.next_row = 0;
                        break;
                    }
                    break;
                }
                case 13: {
                    if (this.pattern_loop_count < 0) {
                        this.next_sequence_index = this.current_sequence_index + 1;
                        this.next_row = (effect_param >> 4) * 10 + (effect_param & 0xF);
                        break;
                    }
                    break;
                }
                case 14: {
                    switch (effect_param & 0xF0) {
                        case 96: {
                            if ((effect_param & 0xF) == 0x0) {
                                this.channels[channel_idx].pattern_loop_row = this.current_row;
                            }
                            if (this.channels[channel_idx].pattern_loop_row >= this.current_row) {
                                break;
                            }
                            if (this.pattern_loop_count < 0) {
                                this.pattern_loop_count = (effect_param & 0xF);
                                this.pattern_loop_channel = channel_idx;
                            }
                            if (this.pattern_loop_channel == channel_idx) {
                                if (this.pattern_loop_count == 0) {
                                    this.channels[channel_idx].pattern_loop_row = this.current_row + 1;
                                }
                                else {
                                    this.next_row = this.channels[channel_idx].pattern_loop_row;
                                    this.next_sequence_index = this.current_sequence_index;
                                }
                                --this.pattern_loop_count;
                                break;
                            }
                            break;
                        }
                        case 224: {
                            this.tick_counter += this.ticks_per_row * (effect_param & 0xF);
                            break;
                        }
                    }
                    break;
                }
                case 15: {
                    if (effect_param < 32) {
                        this.set_speed(effect_param);
                        this.tick_counter = this.ticks_per_row;
                        break;
                    }
                    this.set_tempo(effect_param);
                    break;
                }
                case 37: {
                    this.set_speed(effect_param);
                    this.tick_counter = this.ticks_per_row;
                    break;
                }
            }
        }
        return song_end;
    }
    
    private void set_global_volume(int volume) {
        if (volume < 0) {
            volume = 0;
        }
        if (volume > 64) {
            volume = 64;
        }
        this.global_volume[0] = volume;
    }
    
    private void set_speed(final int speed) {
        if (speed > 0 && speed < 256) {
            this.ticks_per_row = speed;
        }
    }
    
    private void set_tempo(final int bpm) {
        if (bpm > 31 && bpm < 256) {
            this.tick_length_samples = this.sampling_rate * 5 / (bpm * 2);
        }
    }
    
    private void volume_ramp() {
        int sample = 0;
        final int volume_ramp_delta = 32768 / this.volume_ramp_length;
        int volume = 0;
        int ramp_idx = 0;
        final int next_idx = 2 * this.tick_length_samples;
        for (int ramp_end = this.volume_ramp_length * 2 - 1; ramp_idx <= ramp_end; ramp_idx += 2) {
            sample = this.volume_ramp_buffer[ramp_idx] * (32768 - volume) >> 15;
            this.mixing_buffer[ramp_idx] = sample + (this.mixing_buffer[ramp_idx] * volume >> 15);
            this.volume_ramp_buffer[ramp_idx] = this.mixing_buffer[next_idx + ramp_idx];
            sample = this.volume_ramp_buffer[ramp_idx + 1] * (32768 - volume) >> 15;
            this.mixing_buffer[ramp_idx + 1] = sample + (this.mixing_buffer[ramp_idx + 1] * volume >> 15);
            this.volume_ramp_buffer[ramp_idx + 1] = this.mixing_buffer[next_idx + ramp_idx + 1];
            volume += volume_ramp_delta;
        }
    }
    
    private void clear_vol_ramp_buffer() {
        for (int ramp_idx = 0, ramp_end = this.volume_ramp_length * 2 - 1; ramp_idx <= ramp_end; ++ramp_idx) {
            this.volume_ramp_buffer[ramp_idx] = 0;
        }
    }
}



================================================
FILE: ibxm/Instrument.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package ibxm;

public class Instrument
{
    public String name;
    public int vibrato_type;
    public int vibrato_sweep;
    public int vibrato_depth;
    public int vibrato_rate;
    public boolean volume_envelope_active;
    public boolean panning_envelope_active;
    public int volume_fade_out;
    private Envelope volume_envelope;
    private Envelope panning_envelope;
    private int[] key_to_sample;
    private Sample[] samples;
    
    public Instrument() {
        this.name = "";
        this.set_volume_envelope(new Envelope());
        this.set_panning_envelope(new Envelope());
        this.key_to_sample = new int[96];
        this.set_num_samples(1);
    }
    
    public Envelope get_volume_envelope() {
        return this.volume_envelope;
    }
    
    public void set_volume_envelope(final Envelope envelope) {
        if (envelope != null) {
            this.volume_envelope = envelope;
        }
    }
    
    public Envelope get_panning_envelope() {
        return this.panning_envelope;
    }
    
    public void set_panning_envelope(final Envelope envelope) {
        if (envelope != null) {
            this.panning_envelope = envelope;
        }
    }
    
    public Sample get_sample_from_key(final int key) {
        int sample_idx = 0;
        if (key > 0 && key <= this.key_to_sample.length) {
            sample_idx = this.key_to_sample[key - 1];
        }
        return this.get_sample(sample_idx);
    }
    
    public void set_key_to_sample(final int key, final int sample) {
        if (key > 0 && key <= this.key_to_sample.length) {
            this.key_to_sample[key - 1] = sample;
        }
    }
    
    public int get_num_samples() {
        return this.samples.length;
    }
    
    public void set_num_samples(int num_samples) {
        if (num_samples < 1) {
            num_samples = 1;
        }
        this.samples = new Sample[num_samples];
        this.set_sample(0, null);
    }
    
    public Sample get_sample(final int sample_index) {
        Sample sample = null;
        if (sample_index >= 0 && sample_index < this.samples.length) {
            sample = this.samples[sample_index];
        }
        if (sample == null) {
            sample = this.samples[0];
        }
        return sample;
    }
    
    public void set_sample(final int sample_index, final Sample sample) {
        if (sample_index >= 0 && sample_index < this.samples.length) {
            this.samples[sample_index] = sample;
        }
        if (this.samples[0] == null) {
            this.samples[0] = new Sample();
        }
    }
}



================================================
FILE: ibxm/LogTable.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package ibxm;

public class LogTable
{
    private static final int TABLE_SHIFT = 7;
    private static final int INTERP_SHIFT = 8;
    private static final int INTERP_MASK = 255;
    private static final int[] exp_2_table;
    private static final int[] log_2_table;
    
    public static int log_2(int x) {
        int shift;
        for (shift = 15; x < 32768; x <<= 1, --shift) {}
        while (x >= 65536) {
            x >>= 1;
            ++shift;
        }
        return 32768 * shift + eval_table(LogTable.log_2_table, x - 32768);
    }
    
    public static int raise_2(final int x) {
        final int y = eval_table(LogTable.exp_2_table, x & 0x7FFF) << 15;
        return y >> 15 - (x >> 15);
    }
    
    private static int eval_table(final int[] table, final int x) {
        final int table_idx = x >> 8;
        final int table_frac = x & 0xFF;
        final int c = table[table_idx];
        final int m = table[table_idx + 1] - c;
        final int y = (m * table_frac >> 8) + c;
        return y >> 0;
    }
    
    static {
        exp_2_table = new int[] { 32768, 32945, 33124, 33304, 33485, 33667, 33850, 34033, 34218, 34404, 34591, 34779, 34968, 35157, 35348, 35540, 35733, 35927, 36122, 36319, 36516, 36714, 36913, 37114, 37315, 37518, 37722, 37926, 38132, 38339, 38548, 38757, 38967, 39179, 39392, 39606, 39821, 40037, 40254, 40473, 40693, 40914, 41136, 41359, 41584, 41810, 42037, 42265, 42494, 42725, 42957, 43190, 43425, 43661, 43898, 44136, 44376, 44617, 44859, 45103, 45347, 45594, 45841, 46090, 46340, 46592, 46845, 47099, 47355, 47612, 47871, 48131, 48392, 48655, 48919, 49185, 49452, 49720, 49990, 50262, 50535, 50809, 51085, 51362, 51641, 51922, 52204, 52487, 52772, 53059, 53347, 53636, 53928, 54220, 54515, 54811, 55108, 55408, 55709, 56011, 56315, 56621, 56928, 57238, 57548, 57861, 58175, 58491, 58809, 59128, 59449, 59772, 60096, 60423, 60751, 61081, 61412, 61746, 62081, 62418, 62757, 63098, 63440, 63785, 64131, 64479, 64830, 65182, 65536 };
        log_2_table = new int[] { 0, 367, 732, 1095, 1454, 1811, 2165, 2517, 2865, 3212, 3556, 3897, 4236, 4572, 4906, 5238, 5568, 5895, 6220, 6542, 6863, 7181, 7497, 7812, 8124, 8434, 8742, 9048, 9352, 9654, 9954, 10252, 10548, 10843, 11136, 11427, 11716, 12003, 12289, 12573, 12855, 13136, 13414, 13692, 13967, 14241, 14514, 14785, 15054, 15322, 15588, 15853, 16117, 16378, 16639, 16898, 17156, 17412, 17667, 17920, 18172, 18423, 18673, 18921, 19168, 19413, 19657, 19900, 20142, 20383, 20622, 20860, 21097, 21333, 21568, 21801, 22034, 22265, 22495, 22724, 22952, 23178, 23404, 23628, 23852, 24074, 24296, 24516, 24736, 24954, 25171, 25388, 25603, 25817, 26031, 26243, 26455, 26665, 26875, 27084, 27292, 27499, 27705, 27910, 28114, 28317, 28520, 28721, 28922, 29122, 29321, 29519, 29716, 29913, 30109, 30304, 30498, 30691, 30884, 31076, 31267, 31457, 31646, 31835, 32023, 32210, 32397, 32582, 32768 };
    }
}



================================================
FILE: ibxm/Module.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package ibxm;

public class Module
{
    public String song_title;
    public boolean linear_periods;
    public boolean fast_volume_slides;
    public boolean pal;
    public int global_volume;
    public int channel_gain;
    public int default_speed;
    public int default_tempo;
    public int restart_sequence_index;
    private int[] initial_panning;
    private int[] sequence;
    private Pattern[] patterns;
    private Instrument[] instruments;
    private Pattern default_pattern;
    private Instrument default_instrument;
    
    public Module() {
        this.song_title = "ibxm alpha 51 (c)2008 mumart@gmail.com";
        this.set_num_channels(1);
        this.set_sequence_length(1);
        this.set_num_patterns(0);
        this.set_num_instruments(0);
        this.default_pattern = new Pattern();
        this.default_instrument = new Instrument();
    }
    
    public int get_num_channels() {
        return this.initial_panning.length;
    }
    
    public void set_num_channels(int num_channels) {
        if (num_channels < 1) {
            num_channels = 1;
        }
        this.initial_panning = new int[num_channels];
    }
    
    public int get_initial_panning(final int channel) {
        int panning = 128;
        if (channel >= 0 && channel < this.initial_panning.length) {
            panning = this.initial_panning[channel];
        }
        return panning;
    }
    
    public void set_initial_panning(final int channel, final int panning) {
        if (channel >= 0 && channel < this.initial_panning.length) {
            this.initial_panning[channel] = panning;
        }
    }
    
    public int get_sequence_length() {
        return this.sequence.length;
    }
    
    public void set_sequence_length(int sequence_length) {
        if (sequence_length < 0) {
            sequence_length = 0;
        }
        this.sequence = new int[sequence_length];
    }
    
    public void set_sequence(final int sequence_index, final int pattern_index) {
        if (sequence_index >= 0 && sequence_index < this.sequence.length) {
            this.sequence[sequence_index] = pattern_index;
        }
    }
    
    public int get_num_patterns() {
        return this.patterns.length;
    }
    
    public void set_num_patterns(int num_patterns) {
        if (num_patterns < 0) {
            num_patterns = 0;
        }
        this.patterns = new Pattern[num_patterns];
    }
    
    public Pattern get_pattern_from_sequence(final int sequence_index) {
        Pattern pattern = this.default_pattern;
        if (sequence_index >= 0 && sequence_index < this.sequence.length) {
            pattern = this.get_pattern(this.sequence[sequence_index]);
        }
        return pattern;
    }
    
    public Pattern get_pattern(final int pattern_index) {
        Pattern pattern = null;
        if (pattern_index >= 0 && pattern_index < this.patterns.length) {
            pattern = this.patterns[pattern_index];
        }
        if (pattern == null) {
            pattern = this.default_pattern;
        }
        return pattern;
    }
    
    public void set_pattern(final int pattern_index, final Pattern pattern) {
        if (pattern_index >= 0 && pattern_index < this.patterns.length) {
            this.patterns[pattern_index] = pattern;
        }
    }
    
    public int get_num_instruments() {
        return this.instruments.length;
    }
    
    public void set_num_instruments(int num_instruments) {
        if (num_instruments < 0) {
            num_instruments = 0;
        }
        this.instruments = new Instrument[num_instruments];
    }
    
    public Instrument get_instrument(final int instrument_index) {
        Instrument instrument = null;
        if (instrument_index > 0 && instrument_index <= this.instruments.length) {
            instrument = this.instruments[instrument_index - 1];
        }
        if (instrument == null) {
            instrument = this.default_instrument;
        }
        return instrument;
    }
    
    public void set_instrument(final int instrument_index, final Instrument instrument) {
        if (instrument_index > 0 && instrument_index <= this.instruments.length) {
            this.instruments[instrument_index - 1] = instrument;
        }
    }
}



================================================
FILE: ibxm/Pattern.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package ibxm;

public class Pattern
{
    public int num_rows;
    private int data_offset;
    private int note_index;
    private byte[] pattern_data;
    
    public Pattern() {
        this.num_rows = 1;
        this.set_pattern_data(new byte[0]);
    }
    
    public void set_pattern_data(final byte[] data) {
        if (data != null) {
            this.pattern_data = data;
        }
        this.data_offset = 0;
        this.note_index = 0;
    }
    
    public void get_note(final int[] note, final int index) {
        if (index < this.note_index) {
            this.note_index = 0;
            this.data_offset = 0;
        }
        while (this.note_index <= index) {
            this.data_offset = this.next_note(this.data_offset, note);
            ++this.note_index;
        }
    }
    
    public int next_note(int data_offset, final int[] note) {
        if (data_offset < 0) {
            data_offset = this.pattern_data.length;
        }
        int bitmask = 128;
        if (data_offset < this.pattern_data.length) {
            bitmask = (this.pattern_data[data_offset] & 0xFF);
        }
        if ((bitmask & 0x80) == 0x80) {
            ++data_offset;
        }
        else {
            bitmask = 31;
        }
        for (int field = 0; field < 5; ++field) {
            note[field] = 0;
            if ((bitmask & 0x1) == 0x1 && data_offset < this.pattern_data.length) {
                note[field] = (this.pattern_data[data_offset] & 0xFF);
                ++data_offset;
            }
            bitmask >>= 1;
        }
        return data_offset;
    }
}



================================================
FILE: ibxm/Player.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package ibxm;

import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.AudioFormat;
import java.io.IOException;
import java.io.DataInput;
import java.io.DataInputStream;
import java.io.InputStream;
import java.io.FileInputStream;
import javax.sound.sampled.SourceDataLine;

public class Player
{
    private Thread play_thread;
    private IBXM ibxm;
    private Module module;
    private int song_duration;
    private int play_position;
    private boolean running;
    private boolean loop;
    private byte[] output_buffer;
    private SourceDataLine output_line;
    
    public static void main(final String[] args) throws Exception {
        if (args.length < 1) {
            System.err.println("Usage: java ibxm.Player <module file>");
            System.exit(0);
        }
        final FileInputStream file_input_stream = new FileInputStream(args[0]);
        final Player player = new Player();
        player.set_module(load_module(file_input_stream));
        file_input_stream.close();
        player.play();
    }
    
    public static Module load_module(final InputStream input) throws IllegalArgumentException, IOException {
        final DataInputStream data_input_stream = new DataInputStream(input);
        final byte[] xm_header = new byte[60];
        data_input_stream.readFully(xm_header);
        if (FastTracker2.is_xm(xm_header)) {
            return FastTracker2.load_xm(xm_header, data_input_stream);
        }
        final byte[] s3m_header = new byte[96];
        System.arraycopy(xm_header, 0, s3m_header, 0, 60);
        data_input_stream.readFully(s3m_header, 60, 36);
        if (ScreamTracker3.is_s3m(s3m_header)) {
            return ScreamTracker3.load_s3m(s3m_header, data_input_stream);
        }
        final byte[] mod_header = new byte[1084];
        System.arraycopy(s3m_header, 0, mod_header, 0, 96);
        data_input_stream.readFully(mod_header, 96, 988);
        return ProTracker.load_mod(mod_header, data_input_stream);
    }
    
    public Player() throws LineUnavailableException {
        this.ibxm = new IBXM(48000);
        this.set_loop(true);
        this.output_line = AudioSystem.getSourceDataLine(new AudioFormat(48000.0f, 16, 2, true, true));
        this.output_buffer = new byte[4096];
    }
    
    public void set_module(final Module m) {
        if (m != null) {
            this.module = m;
        }
        this.stop();
        this.ibxm.set_module(this.module);
        this.song_duration = this.ibxm.calculate_song_duration();
    }
    
    public void set_loop(final boolean loop) {
        this.loop = loop;
    }
    
    public void play() {
        this.stop();
        (this.play_thread = new Thread(new Driver())).start();
    }
    
    public void stop() {
        this.running = false;
        if (this.play_thread != null) {
            try {
                this.play_thread.join();
            }
            catch (final InterruptedException ex) {}
        }
    }
    
    private class Driver implements Runnable
    {
        @Override
        public void run() {
            if (Player.this.running) {
                return;
            }
            try {
                Player.this.output_line.open();
                Player.this.output_line.start();
                Player.this.play_position = 0;
                Player.this.running = true;
                while (Player.this.running) {
                    int frames = Player.this.song_duration - Player.this.play_position;
                    if (frames > 1024) {
                        frames = 1024;
                    }
                    Player.this.ibxm.get_audio(Player.this.output_buffer, frames);
                    Player.this.output_line.write(Player.this.output_buffer, 0, frames * 4);
                    Player.this.play_position += frames;
                    if (Player.this.play_position >= Player.this.song_duration) {
                        Player.this.play_position = 0;
                        if (Player.this.loop) {
                            continue;
                        }
                        Player.this.running = false;
                    }
                }
                Player.this.output_line.drain();
                Player.this.output_line.close();
            }
            catch (final LineUnavailableException lue) {
                lue.printStackTrace();
            }
        }
    }
}



================================================
FILE: ibxm/ProTracker.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package ibxm;

import java.io.UnsupportedEncodingException;
import java.io.EOFException;
import java.io.IOException;
import java.io.DataInput;

public class ProTracker
{
    public static boolean is_mod(final byte[] header_1084_bytes) {
        boolean is_mod = false;
        if (calculate_num_channels(header_1084_bytes) > 0) {
            is_mod = true;
        }
        return is_mod;
    }
    
    public static Module load_mod(final byte[] header_1084_bytes, final DataInput data_input) throws IOException {
        final int num_channels = calculate_num_channels(header_1084_bytes);
        if (num_channels < 1) {
            throw new IllegalArgumentException("ProTracker: Unrecognised module format!");
        }
        final Module module = new Module();
        module.song_title = ascii_text(header_1084_bytes, 0, 20);
        module.pal = (num_channels == 4);
        module.global_volume = 64;
        module.channel_gain = 12288;
        module.default_speed = 6;
        module.default_tempo = 125;
        module.set_num_channels(num_channels);
        for (int channel_idx = 0; channel_idx < num_channels; ++channel_idx) {
            int panning = 64;
            if ((channel_idx & 0x3) == 0x1 || (channel_idx & 0x3) == 0x2) {
                panning = 192;
            }
            module.set_initial_panning(channel_idx, panning);
        }
        final int sequence_length = header_1084_bytes[950] & 0x7F;
        int restart_idx = header_1084_bytes[951] & 0x7F;
        if (restart_idx >= sequence_length) {
            restart_idx = 0;
        }
        module.restart_sequence_index = restart_idx;
        module.set_sequence_length(sequence_length);
        for (int sequence_idx = 0; sequence_idx < sequence_length; ++sequence_idx) {
            module.set_sequence(sequence_idx, header_1084_bytes[952 + sequence_idx] & 0x7F);
        }
        final int num_patterns = calculate_num_patterns(header_1084_bytes);
        module.set_num_patterns(num_patterns);
        for (int pattern_idx = 0; pattern_idx < num_patterns; ++pattern_idx) {
            module.set_pattern(pattern_idx, read_mod_pattern(data_input, num_channels));
        }
        module.set_num_instruments(31);
        for (int instrument_idx = 1; instrument_idx <= 31; ++instrument_idx) {
            module.set_instrument(instrument_idx, read_mod_instrument(header_1084_bytes, instrument_idx, data_input));
        }
        return module;
    }
    
    private static int calculate_num_patterns(final byte[] module_header) {
        int num_patterns = 0;
        for (int pattern_idx = 0; pattern_idx < 128; ++pattern_idx) {
            final int order_entry = module_header[952 + pattern_idx] & 0x7F;
            if (order_entry >= num_patterns) {
                num_patterns = order_entry + 1;
            }
        }
        return num_patterns;
    }
    
    private static int calculate_num_channels(final byte[] module_header) {
        int num_channels = 0;
        switch (module_header[1082] << 8 | module_header[1083]) {
            case 19233:
            case 19246:
            case 21550:
            case 21556: {
                num_channels = 4;
                break;
            }
            case 18510: {
                num_channels = module_header[1080] - 48;
                break;
            }
            case 17224: {
                num_channels = (module_header[1080] - 48) * 10 + (module_header[1081] - 48);
                break;
            }
            default: {
                num_channels = 0;
                break;
            }
        }
        return num_channels;
    }
    
    private static Pattern read_mod_pattern(final DataInput data_input, final int num_channels) throws IOException {
        final Pattern pattern = new Pattern();
        pattern.num_rows = 64;
        final byte[] input_pattern_data = new byte[64 * num_channels * 4];
        final byte[] output_pattern_data = new byte[64 * num_channels * 5];
        data_input.readFully(input_pattern_data);
        for (int input_idx = 0, output_idx = 0; input_idx < input_pattern_data.length; input_idx += 4, output_idx += 5) {
            int period = (input_pattern_data[input_idx] & 0xF) << 8;
            period |= (input_pattern_data[input_idx + 1] & 0xFF);
            output_pattern_data[output_idx] = to_key(period);
            int instrument = input_pattern_data[input_idx] & 0x10;
            instrument |= (input_pattern_data[input_idx + 2] & 0xF0) >> 4;
            output_pattern_data[output_idx + 1] = (byte)instrument;
            int effect = input_pattern_data[input_idx + 2] & 0xF;
            int effect_param = input_pattern_data[input_idx + 3] & 0xFF;
            if (effect == 1 && effect_param == 0) {
                effect = 0;
            }
            if (effect == 2 && effect_param == 0) {
                effect = 0;
            }
            if (effect == 8 && num_channels == 4) {
                effect = 0;
                effect_param = 0;
            }
            if (effect == 10 && effect_param == 0) {
                effect = 0;
            }
            if (effect == 5 && effect_param == 0) {
                effect = 3;
            }
            if (effect == 6 && effect_param == 0) {
                effect = 4;
            }
            output_pattern_data[output_idx + 3] = (byte)effect;
            output_pattern_data[output_idx + 4] = (byte)effect_param;
        }
        pattern.set_pattern_data(output_pattern_data);
        return pattern;
    }
    
    private static Instrument read_mod_instrument(final byte[] mod_header, final int idx, final DataInput data_input) throws IOException {
        final int header_offset = (idx - 1) * 30 + 20;
        final Instrument instrument = new Instrument();
        instrument.name = ascii_text(mod_header, header_offset, 22);
        final Sample sample = new Sample();
        final int sample_data_length = unsigned_short_be(mod_header, header_offset + 22) << 1;
        int fine_tune = mod_header[header_offset + 24] & 0xF;
        if (fine_tune > 7) {
            fine_tune -= 16;
        }
        sample.transpose = (fine_tune << 15) / 96;
        sample.volume = (mod_header[header_offset + 25] & 0x7F);
        final int loop_start = unsigned_short_be(mod_header, header_offset + 26) << 1;
        int loop_length = unsigned_short_be(mod_header, header_offset + 28) << 1;
        if (loop_length < 4) {
            loop_length = 0;
        }
        final byte[] raw_sample_data = new byte[sample_data_length];
        final short[] sample_data = new short[sample_data_length];
        try {
            data_input.readFully(raw_sample_data);
        }
        catch (final EOFException e) {
            System.out.println("ProTracker: Instrument " + idx + " has samples missing.");
        }
        for (int sample_idx = 0; sample_idx < raw_sample_data.length; ++sample_idx) {
            sample_data[sample_idx] = (short)(raw_sample_data[sample_idx] << 8);
        }
        sample.set_sample_data(sample_data, loop_start, loop_length, false);
        instrument.set_num_samples(1);
        instrument.set_sample(0, sample);
        return instrument;
    }
    
    private static byte to_key(final int period) {
        int key;
        if (period < 32) {
            key = 0;
        }
        else {
            final int oct = LogTable.log_2(7256) - LogTable.log_2(period);
            if (oct < 0) {
                key = 0;
            }
            else {
                key = oct * 12;
                key >>= 14;
                key = (key >> 1) + (key & 0x1);
            }
        }
        return (byte)key;
    }
    
    private static int unsigned_short_be(final byte[] buf, final int offset) {
        int value = (buf[offset] & 0xFF) << 8;
        value |= (buf[offset + 1] & 0xFF);
        return value;
    }
    
    private static String ascii_text(final byte[] buffer, final int offset, final int length) {
        final byte[] string_buffer = new byte[length];
        for (int idx = 0; idx < length; ++idx) {
            int chr = buffer[offset + idx];
            if (chr < 32) {
                chr = 32;
            }
            string_buffer[idx] = (byte)chr;
        }
        String string;
        try {
            string = new String(string_buffer, 0, length, "ISO-8859-1");
        }
        catch (final UnsupportedEncodingException e) {
            string = "";
        }
        return string;
    }
}



================================================
FILE: ibxm/Sample.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package ibxm;

public class Sample
{
    public String name;
    public boolean set_panning;
    public int volume;
    public int panning;
    public int transpose;
    private int loop_start;
    private int loop_length;
    private short[] sample_data;
    private static final int POINT_SHIFT = 4;
    private static final int POINTS = 16;
    private static final int OVERLAP = 8;
    private static final int INTERP_SHIFT = 11;
    private static final int INTERP_BITMASK = 2047;
    private static final short[] sinc_table;
    
    public Sample() {
        this.name = "";
        this.set_sample_data(new short[0], 0, 0, false);
    }
    
    public void set_sample_data(final short[] data, int loop_start, int loop_length, final boolean ping_pong) {
        if (loop_start < 0) {
            loop_start = 0;
        }
        if (loop_start >= data.length) {
            loop_start = data.length - 1;
        }
        if (loop_start + loop_length > data.length) {
            loop_length = data.length - loop_start;
        }
        if (loop_length <= 1) {
            System.arraycopy(data, 0, this.sample_data = new short[8 + data.length + 24], 8, data.length);
            for (int offset = 0; offset < 8; ++offset) {
                short sample = this.sample_data[8 + data.length - 1];
                sample = (short)(sample * (8 - offset) / 8);
                this.sample_data[8 + data.length + offset] = sample;
            }
            loop_start = 8 + data.length + 8;
            loop_length = 1;
        }
        else {
            if (ping_pong) {
                System.arraycopy(data, 0, this.sample_data = new short[8 + loop_start + loop_length * 2 + 16], 8, loop_start + loop_length);
                for (int offset = 0; offset < loop_length; ++offset) {
                    final short sample = data[loop_start + loop_length - offset - 1];
                    this.sample_data[8 + loop_start + loop_length + offset] = sample;
                }
                loop_start += 8;
                loop_length *= 2;
            }
            else {
                System.arraycopy(data, 0, this.sample_data = new short[8 + loop_start + loop_length + 16], 8, loop_start + loop_length);
                loop_start += 8;
            }
            for (int offset = 0; offset < 16; ++offset) {
                final short sample = this.sample_data[loop_start + offset];
                this.sample_data[loop_start + loop_length + offset] = sample;
            }
        }
        this.loop_start = loop_start;
        this.loop_length = loop_length;
    }
    
    public void resample_nearest(int sample_idx, int sample_frac, final int step, final int left_gain, final int right_gain, final int[] mix_buffer, final int frame_offset, int frames) {
        sample_idx += 8;
        final int loop_end = this.loop_start + this.loop_length - 1;
        for (int offset = frame_offset << 1, end = frame_offset + frames - 1 << 1; frames > 0; frames = end - offset + 2 >> 1) {
            if (sample_idx > loop_end) {
                if (this.loop_length <= 1) {
                    break;
                }
                sample_idx = this.loop_start + (sample_idx - this.loop_start) % this.loop_length;
            }
            final int max_sample_idx = sample_idx + (sample_frac + (frames - 1) * step >> 15);
            if (max_sample_idx > loop_end) {
                while (sample_idx <= loop_end) {
                    final int n = offset++;
                    mix_buffer[n] += this.sample_data[sample_idx] * left_gain >> 15;
                    final int n2 = offset++;
                    mix_buffer[n2] += this.sample_data[sample_idx] * right_gain >> 15;
                    sample_frac += step;
                    sample_idx += sample_frac >> 15;
                    sample_frac &= 0x7FFF;
                }
            }
            else {
                while (offset <= end) {
                    final int n3 = offset++;
                    mix_buffer[n3] += this.sample_data[sample_idx] * left_gain >> 15;
                    final int n4 = offset++;
                    mix_buffer[n4] += this.sample_data[sample_idx] * right_gain >> 15;
                    sample_frac += step;
                    sample_idx += sample_frac >> 15;
                    sample_frac &= 0x7FFF;
                }
            }
        }
    }
    
    public void resample_linear(int sample_idx, int sample_frac, final int step, final int left_gain, final int right_gain, final int[] mix_buffer, final int frame_offset, int frames) {
        sample_idx += 8;
        final int loop_end = this.loop_start + this.loop_length - 1;
        for (int offset = frame_offset << 1, end = frame_offset + frames - 1 << 1; frames > 0; frames = end - offset + 2 >> 1) {
            if (sample_idx > loop_end) {
                if (this.loop_length <= 1) {
                    break;
                }
                sample_idx = this.loop_start + (sample_idx - this.loop_start) % this.loop_length;
            }
            final int max_sample_idx = sample_idx + (sample_frac + (frames - 1) * step >> 15);
            if (max_sample_idx > loop_end) {
                while (sample_idx <= loop_end) {
                    int amplitude = this.sample_data[sample_idx];
                    amplitude += (this.sample_data[sample_idx + 1] - amplitude) * sample_frac >> 15;
                    final int n = offset++;
                    mix_buffer[n] += amplitude * left_gain >> 15;
                    final int n2 = offset++;
                    mix_buffer[n2] += amplitude * right_gain >> 15;
                    sample_frac += step;
                    sample_idx += sample_frac >> 15;
                    sample_frac &= 0x7FFF;
                }
            }
            else {
                while (offset <= end) {
                    int amplitude = this.sample_data[sample_idx];
                    amplitude += (this.sample_data[sample_idx + 1] - amplitude) * sample_frac >> 15;
                    final int n3 = offset++;
                    mix_buffer[n3] += amplitude * left_gain >> 15;
                    final int n4 = offset++;
                    mix_buffer[n4] += amplitude * right_gain >> 15;
                    sample_frac += step;
                    sample_idx += sample_frac >> 15;
                    sample_frac &= 0x7FFF;
                }
            }
        }
    }
    
    public void resample_sinc(int sample_idx, int sample_frac, final int step, final int left_gain, final int right_gain, final int[] mix_buffer, final int frame_offset, final int frames) {
        final int loop_end = this.loop_start + this.loop_length - 1;
        for (int offset = frame_offset << 1, end = frame_offset + frames - 1 << 1; offset <= end; offset += 2, sample_frac += step, sample_idx += sample_frac >> 15, sample_frac &= 0x7FFF) {
            if (sample_idx > loop_end) {
                if (this.loop_length <= 1) {
                    break;
                }
                sample_idx = this.loop_start + (sample_idx - this.loop_start) % this.loop_length;
            }
            final int table_idx = sample_frac >> 11 << 4;
            int a1 = Sample.sinc_table[table_idx + 0] * this.sample_data[sample_idx + 0] >> 15;
            a1 += Sample.sinc_table[table_idx + 1] * this.sample_data[sample_idx + 1] >> 15;
            a1 += Sample.sinc_table[table_idx + 2] * this.sample_data[sample_idx + 2] >> 15;
            a1 += Sample.sinc_table[table_idx + 3] * this.sample_data[sample_idx + 3] >> 15;
            a1 += Sample.sinc_table[table_idx + 4] * this.sample_data[sample_idx + 4] >> 15;
            a1 += Sample.sinc_table[table_idx + 5] * this.sample_data[sample_idx + 5] >> 15;
            a1 += Sample.sinc_table[table_idx + 6] * this.sample_data[sample_idx + 6] >> 15;
            a1 += Sample.sinc_table[table_idx + 7] * this.sample_data[sample_idx + 7] >> 15;
            a1 += Sample.sinc_table[table_idx + 8] * this.sample_data[sample_idx + 8] >> 15;
            a1 += Sample.sinc_table[table_idx + 9] * this.sample_data[sample_idx + 9] >> 15;
            a1 += Sample.sinc_table[table_idx + 10] * this.sample_data[sample_idx + 10] >> 15;
            a1 += Sample.sinc_table[table_idx + 11] * this.sample_data[sample_idx + 11] >> 15;
            a1 += Sample.sinc_table[table_idx + 12] * this.sample_data[sample_idx + 12] >> 15;
            a1 += Sample.sinc_table[table_idx + 13] * this.sample_data[sample_idx + 13] >> 15;
            a1 += Sample.sinc_table[table_idx + 14] * this.sample_data[sample_idx + 14] >> 15;
            a1 += Sample.sinc_table[table_idx + 15] * this.sample_data[sample_idx + 15] >> 15;
            int a2 = Sample.sinc_table[table_idx + 16] * this.sample_data[sample_idx + 0] >> 15;
            a2 += Sample.sinc_table[table_idx + 17] * this.sample_data[sample_idx + 1] >> 15;
            a2 += Sample.sinc_table[table_idx + 18] * this.sample_data[sample_idx + 2] >> 15;
            a2 += Sample.sinc_table[table_idx + 19] * this.sample_data[sample_idx + 3] >> 15;
            a2 += Sample.sinc_table[table_idx + 20] * this.sample_data[sample_idx + 4] >> 15;
            a2 += Sample.sinc_table[table_idx + 21] * this.sample_data[sample_idx + 5] >> 15;
            a2 += Sample.sinc_table[table_idx + 22] * this.sample_data[sample_idx + 6] >> 15;
            a2 += Sample.sinc_table[table_idx + 23] * this.sample_data[sample_idx + 7] >> 15;
            a2 += Sample.sinc_table[table_idx + 24] * this.sample_data[sample_idx + 8] >> 15;
            a2 += Sample.sinc_table[table_idx + 25] * this.sample_data[sample_idx + 9] >> 15;
            a2 += Sample.sinc_table[table_idx + 26] * this.sample_data[sample_idx + 10] >> 15;
            a2 += Sample.sinc_table[table_idx + 27] * this.sample_data[sample_idx + 11] >> 15;
            a2 += Sample.sinc_table[table_idx + 28] * this.sample_data[sample_idx + 12] >> 15;
            a2 += Sample.sinc_table[table_idx + 29] * this.sample_data[sample_idx + 13] >> 15;
            a2 += Sample.sinc_table[table_idx + 30] * this.sample_data[sample_idx + 14] >> 15;
            a2 += Sample.sinc_table[table_idx + 31] * this.sample_data[sample_idx + 15] >> 15;
            final int amplitude = a1 + ((a2 - a1) * (sample_frac & 0x7FF) >> 11);
            final int n = offset;
            mix_buffer[n] += amplitude * left_gain >> 15;
            final int n2 = offset + 1;
            mix_buffer[n2] += amplitude * right_gain >> 15;
        }
    }
    
    public boolean has_finished(final int sample_idx) {
        boolean finished = false;
        if (this.loop_length <= 1 && sample_idx > this.loop_start) {
            finished = true;
        }
        return finished;
    }
    
    static {
        sinc_table = new short[] { 0, -7, 27, -71, 142, -227, 299, 32439, 299, -227, 142, -71, 27, -7, 0, 0, 0, 0, -5, 36, -142, 450, -1439, 32224, 2302, -974, 455, -190, 64, -15, 2, 0, 0, 6, -33, 128, -391, 1042, -2894, 31584, 4540, -1765, 786, -318, 105, -25, 3, 0, 0, 10, -55, 204, -597, 1533, -4056, 30535, 6977, -2573, 1121, -449, 148, -36, 5, 0, -1, 13, -71, 261, -757, 1916, -4922, 29105, 9568, -3366, 1448, -578, 191, -47, 7, 0, -1, 15, -81, 300, -870, 2185, -5498, 27328, 12263, -4109, 1749, -698, 232, -58, 9, 0, -1, 15, -86, 322, -936, 2343, -5800, 25249, 15006, -4765, 2011, -802, 269, -68, 10, 0, -1, 15, -87, 328, -957, 2394, -5849, 22920, 17738, -5298, 2215, -885, 299, -77, 12, 0, 0, 14, -83, 319, -938, 2347, -5671, 20396, 20396, -5671, 2347, -938, 319, -83, 14, 0, 0, 12, -77, 299, -885, 2215, -5298, 17738, 22920, -5849, 2394, -957, 328, -87, 15, -1, 0, 10, -68, 269, -802, 2011, -4765, 15006, 25249, -5800, 2343, -936, 322, -86, 15, -1, 0, 9, -58, 232, -698, 1749, -4109, 12263, 27328, -5498, 2185, -870, 300, -81, 15, -1, 0, 7, -47, 191, -578, 1448, -3366, 9568, 29105, -4922, 1916, -757, 261, -71, 13, -1, 0, 5, -36, 148, -449, 1121, -2573, 6977, 30535, -4056, 1533, -597, 204, -55, 10, 0, 0, 3, -25, 105, -318, 786, -1765, 4540, 31584, -2894, 1042, -391, 128, -33, 6, 0, 0, 2, -15, 64, -190, 455, -974, 2302, 32224, -1439, 450, -142, 36, -5, 0, 0, 0, 0, -7, 27, -71, 142, -227, 299, 32439, 299, -227, 142, -71, 27, -7, 0 };
    }
}



================================================
FILE: ibxm/ScreamTracker3.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package ibxm;

import java.io.UnsupportedEncodingException;
import java.io.EOFException;
import java.io.IOException;
import java.io.DataInput;

public class ScreamTracker3
{
    private static final int[] effect_map;
    private static final int[] effect_s_map;
    
    public static boolean is_s3m(final byte[] header_96_bytes) {
        final String s3m_identifier = ascii_text(header_96_bytes, 44, 4);
        return s3m_identifier.equals("SCRM");
    }
    
    public static Module load_s3m(final byte[] header_96_bytes, final DataInput data_input) throws IOException {
        final byte[] s3m_file = read_s3m_file(header_96_bytes, data_input);
        final Module module = new Module();
        module.song_title = ascii_text(s3m_file, 0, 28);
        final int num_pattern_orders = get_num_pattern_orders(s3m_file);
        final int num_instruments = get_num_instruments(s3m_file);
        final int num_patterns = get_num_patterns(s3m_file);
        int flags = unsigned_short_le(s3m_file, 38);
        final int tracker_version = unsigned_short_le(s3m_file, 40);
        if ((flags & 0x40) == 0x40 || tracker_version == 4864) {
            module.fast_volume_slides = true;
        }
        boolean signed_samples = false;
        if (unsigned_short_le(s3m_file, 42) == 1) {
            signed_samples = true;
        }
        module.global_volume = (s3m_file[48] & 0xFF);
        module.default_speed = (s3m_file[49] & 0xFF);
        module.default_tempo = (s3m_file[50] & 0xFF);
        final int master_volume = s3m_file[51] & 0x7F;
        module.channel_gain = master_volume << 15 >> 7;
        final boolean stereo_mode = (s3m_file[51] & 0x80) == 0x80;
        final boolean default_panning = (s3m_file[53] & 0xFF) == 0xFC;
        final int[] channel_map = new int[32];
        int num_channels = 0;
        for (int channel_idx = 0; channel_idx < 32; ++channel_idx) {
            final int channel_config = s3m_file[64 + channel_idx] & 0xFF;
            channel_map[channel_idx] = -1;
            if (channel_config < 16) {
                channel_map[channel_idx] = num_channels;
                ++num_channels;
            }
        }
        module.set_num_channels(num_channels);
        final int panning_offset = 96 + num_pattern_orders + num_instruments * 2 + num_patterns * 2;
        for (int channel_idx = 0; channel_idx < 32; ++channel_idx) {
            if (channel_map[channel_idx] >= 0) {
                int panning = 7;
                if (stereo_mode) {
                    panning = 12;
                    if ((s3m_file[64 + channel_idx] & 0xFF) < 8) {
                        panning = 3;
                    }
                }
                if (default_panning) {
                    flags = (s3m_file[panning_offset + channel_idx] & 0xFF);
                    if ((flags & 0x20) == 0x20) {
                        panning = (flags & 0xF);
                    }
                }
                module.set_initial_panning(channel_map[channel_idx], panning * 17);
            }
        }
        final int[] sequence = read_s3m_sequence(s3m_file);
        module.set_sequence_length(sequence.length);
        for (int order_idx = 0; order_idx < sequence.length; ++order_idx) {
            module.set_sequence(order_idx, sequence[order_idx]);
        }
        module.set_num_instruments(num_instruments);
        for (int instrument_idx = 0; instrument_idx < num_instruments; ++instrument_idx) {
            final Instrument instrument = read_s3m_instrument(s3m_file, instrument_idx, signed_samples);
            module.set_instrument(instrument_idx + 1, instrument);
        }
        module.set_num_patterns(num_patterns);
        for (int pattern_idx = 0; pattern_idx < num_patterns; ++pattern_idx) {
            module.set_pattern(pattern_idx, read_s3m_pattern(s3m_file, pattern_idx, channel_map));
        }
        return module;
    }
    
    private static int[] read_s3m_sequence(final byte[] s3m_file) {
        final int num_pattern_orders = get_num_pattern_orders(s3m_file);
        int sequence_length = 0;
        for (int order_idx = 0; order_idx < num_pattern_orders; ++order_idx) {
            final int pattern_order = s3m_file[96 + order_idx] & 0xFF;
            if (pattern_order == 255) {
                break;
            }
            if (pattern_order < 254) {
                ++sequence_length;
            }
        }
        final int[] sequence = new int[sequence_length];
        int sequence_idx = 0;
        for (int order_idx = 0; order_idx < num_pattern_orders; ++order_idx) {
            final int pattern_order = s3m_file[96 + order_idx] & 0xFF;
            if (pattern_order == 255) {
                break;
            }
            if (pattern_order < 254) {
                sequence[sequence_idx] = pattern_order;
                ++sequence_idx;
            }
        }
        return sequence;
    }
    
    private static Instrument read_s3m_instrument(final byte[] s3m_file, final int instrument_idx, final boolean signed_samples) {
        final int instrument_offset = get_instrument_offset(s3m_file, instrument_idx);
        final Instrument instrument = new Instrument();
        instrument.name = ascii_text(s3m_file, instrument_offset + 48, 28);
        final Sample sample = new Sample();
        if (s3m_file[instrument_offset] == 1) {
            int sample_data_length = get_sample_data_length(s3m_file, instrument_offset);
            final int loop_start = unsigned_short_le(s3m_file, instrument_offset + 20);
            int loop_length = unsigned_short_le(s3m_file, instrument_offset + 24) - loop_start;
            sample.volume = (s3m_file[instrument_offset + 28] & 0xFF);
            if (s3m_file[instrument_offset + 30] != 0) {
                throw new IllegalArgumentException("ScreamTracker3: Packed samples not supported!");
            }
            if ((s3m_file[instrument_offset + 31] & 0x1) == 0x0) {
                loop_length = 0;
            }
            if ((s3m_file[instrument_offset + 31] & 0x2) != 0x0) {
                throw new IllegalArgumentException("ScreamTracker3: Stereo samples not supported!");
            }
            final boolean sixteen_bit = (s3m_file[instrument_offset + 31] & 0x4) != 0x0;
            final int c2_rate = unsigned_short_le(s3m_file, instrument_offset + 32);
            sample.transpose = LogTable.log_2(c2_rate) - LogTable.log_2(8363);
            final int sample_data_offset = get_sample_data_offset(s3m_file, instrument_offset);
            short[] sample_data;
            if (sixteen_bit) {
                if (signed_samples) {
                    throw new IllegalArgumentException("ScreamTracker3: Signed 16-bit samples not supported!");
                }
                sample_data_length >>= 1;
                sample_data = new short[sample_data_length];
                for (int sample_idx = 0; sample_idx < sample_data_length; ++sample_idx) {
                    int amplitude = s3m_file[sample_data_offset + sample_idx * 2] & 0xFF;
                    amplitude |= (s3m_file[sample_data_offset + sample_idx * 2 + 1] & 0xFF) << 8;
                    sample_data[sample_idx] = (short)(amplitude - 32768);
                }
            }
            else {
                sample_data = new short[sample_data_length];
                if (signed_samples) {
                    for (int sample_idx = 0; sample_idx < sample_data_length; ++sample_idx) {
                        final int amplitude = s3m_file[sample_data_offset + sample_idx] << 8;
                        sample_data[sample_idx] = (short)amplitude;
                    }
                }
                else {
                    for (int sample_idx = 0; sample_idx < sample_data_length; ++sample_idx) {
                        final int amplitude = (s3m_file[sample_data_offset + sample_idx] & 0xFF) << 8;
                        sample_data[sample_idx] = (short)(amplitude - 32768);
                    }
                }
            }
            sample.set_sample_data(sample_data, loop_start, loop_length, false);
        }
        instrument.set_num_samples(1);
        instrument.set_sample(0, sample);
        return instrument;
    }
    
    private static Pattern read_s3m_pattern(final byte[] s3m_file, final int pattern_idx, final int[] channel_map) {
        int num_channels = 0;
        for (int channel_idx = 0; channel_idx < 32; ++channel_idx) {
            if (channel_map[channel_idx] >= num_channels) {
                num_channels = channel_idx + 1;
            }
        }
        final int num_notes = num_channels * 64;
        final byte[] pattern_data = new byte[num_notes * 5];
        int row_idx = 0;
        int pattern_offset = get_pattern_offset(s3m_file, pattern_idx) + 2;
        while (row_idx < 64) {
            final int token = s3m_file[pattern_offset] & 0xFF;
            ++pattern_offset;
            if (token > 0) {
                final int channel_idx = channel_map[token & 0x1F];
                final int note_idx = (num_channels * row_idx + channel_idx) * 5;
                if ((token & 0x20) == 0x20) {
                    if (channel_idx >= 0) {
                        int key = s3m_file[pattern_offset] & 0xFF;
                        if (key == 255) {
                            key = 0;
                        }
                        else if (key == 254) {
                            key = 97;
                        }
                        else {
                            for (key = ((key & 0xF0) >> 4) * 12 + (key & 0xF) + 1; key > 96; key -= 12) {}
                        }
                        pattern_data[note_idx] = (byte)key;
                        pattern_data[note_idx + 1] = s3m_file[pattern_offset + 1];
                    }
                    pattern_offset += 2;
                }
                if ((token & 0x40) == 0x40) {
                    if (channel_idx >= 0) {
                        final int volume_column = (s3m_file[pattern_offset] & 0xFF) + 16;
                        pattern_data[note_idx + 2] = (byte)volume_column;
                    }
                    ++pattern_offset;
                }
                if ((token & 0x80) != 0x80) {
                    continue;
                }
                if (channel_idx >= 0) {
                    int effect = s3m_file[pattern_offset] & 0xFF;
                    int effect_param = s3m_file[pattern_offset + 1] & 0xFF;
                    effect = ScreamTracker3.effect_map[effect & 0x1F];
                    if (effect == 255) {
                        effect = 0;
                        effect_param = 0;
                    }
                    if (effect == 14) {
                        effect = ScreamTracker3.effect_s_map[(effect_param & 0xF0) >> 4];
                        effect_param &= 0xF;
                        switch (effect) {
                            case 8: {
                                effect = 8;
                                effect_param *= 17;
                                break;
                            }
                            case 9: {
                                effect = 8;
                                if (effect_param > 7) {
                                    effect_param -= 8;
                                }
                                else {
                                    effect_param += 8;
                                }
                                effect_param *= 17;
                                break;
                            }
                            case 255: {
                                effect = 0;
                                effect_param = 0;
                                break;
                            }
                            default: {
                                effect_param = ((effect & 0xF) << 4 | (effect_param & 0xF));
                                effect = 14;
                                break;
                            }
                        }
                    }
                    pattern_data[note_idx + 3] = (byte)effect;
                    pattern_data[note_idx + 4] = (byte)effect_param;
                }
                pattern_offset += 2;
            }
            else {
                ++row_idx;
            }
        }
        final Pattern pattern = new Pattern();
        pattern.num_rows = 64;
        pattern.set_pattern_data(pattern_data);
        return pattern;
    }
    
    private static byte[] read_s3m_file(final byte[] header_96_bytes, final DataInput data_input) throws IOException {
        if (!is_s3m(header_96_bytes)) {
            throw new IllegalArgumentException("ScreamTracker3: Not an S3M file!");
        }
        byte[] s3m_file = header_96_bytes;
        int s3m_file_length = header_96_bytes.length;
        final int num_pattern_orders = get_num_pattern_orders(s3m_file);
        final int num_instruments = get_num_instruments(s3m_file);
        final int num_patterns = get_num_patterns(s3m_file);
        s3m_file_length += num_pattern_orders;
        s3m_file_length += num_instruments * 2;
        s3m_file_length += num_patterns * 2;
        s3m_file = read_more(s3m_file, s3m_file_length, data_input);
        for (int instrument_idx = 0; instrument_idx < num_instruments; ++instrument_idx) {
            int instrument_offset = get_instrument_offset(s3m_file, instrument_idx);
            instrument_offset += 80;
            if (instrument_offset > s3m_file_length) {
                s3m_file_length = instrument_offset;
            }
        }
        for (int pattern_idx = 0; pattern_idx < num_patterns; ++pattern_idx) {
            int pattern_offset = get_pattern_offset(s3m_file, pattern_idx);
            pattern_offset += 2;
            if (pattern_offset > s3m_file_length) {
                s3m_file_length = pattern_offset;
            }
        }
        s3m_file = read_more(s3m_file, s3m_file_length, data_input);
        for (int instrument_idx = 0; instrument_idx < num_instruments; ++instrument_idx) {
            final int instrument_offset = get_instrument_offset(s3m_file, instrument_idx);
            int sample_data_offset = get_sample_data_offset(s3m_file, instrument_offset);
            sample_data_offset += get_sample_data_length(s3m_file, instrument_offset);
            if (sample_data_offset > s3m_file_length) {
                s3m_file_length = sample_data_offset;
            }
        }
        for (int pattern_idx = 0; pattern_idx < num_patterns; ++pattern_idx) {
            int pattern_offset = get_pattern_offset(s3m_file, pattern_idx);
            pattern_offset += get_pattern_length(s3m_file, pattern_offset);
            pattern_offset += 2;
            if (pattern_offset > s3m_file_length) {
                s3m_file_length = pattern_offset;
            }
        }
        s3m_file = read_more(s3m_file, s3m_file_length, data_input);
        return s3m_file;
    }
    
    private static int get_num_pattern_orders(final byte[] s3m_file) {
        final int num_pattern_orders = unsigned_short_le(s3m_file, 32);
        return num_pattern_orders;
    }
    
    private static int get_num_instruments(final byte[] s3m_file) {
        final int num_instruments = unsigned_short_le(s3m_file, 34);
        return num_instruments;
    }
    
    private static int get_num_patterns(final byte[] s3m_file) {
        final int num_patterns = unsigned_short_le(s3m_file, 36);
        return num_patterns;
    }
    
    private static int get_instrument_offset(final byte[] s3m_file, final int instrument_idx) {
        final int pointer_offset = 96 + get_num_pattern_orders(s3m_file);
        final int instrument_offset = unsigned_short_le(s3m_file, pointer_offset + instrument_idx * 2) << 4;
        return instrument_offset;
    }
    
    private static int get_sample_data_offset(final byte[] s3m_file, final int instrument_offset) {
        int sample_data_offset = 0;
        if (s3m_file[instrument_offset] == 1) {
            sample_data_offset = (s3m_file[instrument_offset + 13] & 0xFF) << 20;
            sample_data_offset |= unsigned_short_le(s3m_file, instrument_offset + 14) << 4;
        }
        return sample_data_offset;
    }
    
    private static int get_sample_data_length(final byte[] s3m_file, final int instrument_offset) {
        int sample_data_length = 0;
        if (s3m_file[instrument_offset] == 1) {
            sample_data_length = unsigned_short_le(s3m_file, instrument_offset + 16);
            final boolean sixteen_bit = (s3m_file[instrument_offset + 31] & 0x4) != 0x0;
            if (sixteen_bit) {
                sample_data_length <<= 1;
            }
        }
        return sample_data_length;
    }
    
    private static int get_pattern_offset(final byte[] s3m_file, final int pattern_idx) {
        int pointer_offset = 96 + get_num_pattern_orders(s3m_file);
        pointer_offset += get_num_instruments(s3m_file) * 2;
        final int pattern_offset = unsigned_short_le(s3m_file, pointer_offset + pattern_idx * 2) << 4;
        return pattern_offset;
    }
    
    private static int get_pattern_length(final byte[] s3m_file, final int pattern_offset) {
        final int pattern_length = unsigned_short_le(s3m_file, pattern_offset);
        return pattern_length;
    }
    
    private static byte[] read_more(final byte[] old_data, final int new_length, final DataInput data_input) throws IOException {
        byte[] new_data = old_data;
        if (new_length > old_data.length) {
            new_data = new byte[new_length];
            System.arraycopy(old_data, 0, new_data, 0, old_data.length);
            try {
                data_input.readFully(new_data, old_data.length, new_data.length - old_data.length);
            }
            catch (final EOFException e) {
                System.out.println("ScreamTracker3: Module has been truncated!");
            }
        }
        return new_data;
    }
    
    private static int unsigned_short_le(final byte[] buffer, final int offset) {
        int value = buffer[offset] & 0xFF;
        value |= (buffer[offset + 1] & 0xFF) << 8;
        return value;
    }
    
    private static String ascii_text(final byte[] buffer, final int offset, final int length) {
        final byte[] string_buffer = new byte[length];
        for (int idx = 0; idx < length; ++idx) {
            int chr = buffer[offset + idx];
            if (chr < 32) {
                chr = 32;
            }
            string_buffer[idx] = (byte)chr;
        }
        String string;
        try {
            string = new String(string_buffer, 0, length, "ISO-8859-1");
        }
        catch (final UnsupportedEncodingException e) {
            string = "";
        }
        return string;
    }
    
    static {
        effect_map = new int[] { 255, 37, 11, 13, 10, 2, 1, 3, 4, 29, 0, 6, 5, 255, 255, 9, 255, 27, 7, 14, 15, 36, 16, 255, 255, 255, 255, 255, 255, 255, 255, 255 };
        effect_s_map = new int[] { 0, 3, 5, 4, 7, 255, 255, 255, 8, 255, 9, 6, 12, 13, 14, 15 };
    }
}



================================================
FILE: net/minecraftforge/classloading/FMLForgePlugin.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.classloading;

import java.util.Map;
import java.io.File;
import cpw.mods.fml.relauncher.IFMLLoadingPlugin;

public class FMLForgePlugin implements IFMLLoadingPlugin
{
    public static boolean RUNTIME_DEOBF;
    public static File forgeLocation;
    
    @Override
    public String[] getLibraryRequestClass() {
        return null;
    }
    
    @Override
    public String[] getASMTransformerClass() {
        return new String[] { "net.minecraftforge.transformers.ForgeAccessTransformer", "net.minecraftforge.transformers.EventTransformer" };
    }
    
    @Override
    public String getModContainerClass() {
        return "net.minecraftforge.common.ForgeDummyContainer";
    }
    
    @Override
    public String getSetupClass() {
        return null;
    }
    
    @Override
    public void injectData(final Map<String, Object> data) {
        FMLForgePlugin.RUNTIME_DEOBF = data.get("runtimeDeobfuscationEnabled");
        FMLForgePlugin.forgeLocation = data.get("coremodLocation");
    }
    
    static {
        FMLForgePlugin.RUNTIME_DEOBF = false;
    }
}



================================================
FILE: net/minecraftforge/client/ClientCommandHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client;

import java.util.List;
import cpw.mods.fml.client.FMLClientHandler;
import net.minecraftforge.event.Event;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.event.CommandEvent;

public class ClientCommandHandler extends aa
{
    public static final ClientCommandHandler instance;
    public String[] latestAutoComplete;
    
    public ClientCommandHandler() {
        this.latestAutoComplete = null;
    }
    
    public int a(final ad sender, String message) {
        message = message.trim();
        if (message.startsWith("/")) {
            message = message.substring(1);
        }
        final String[] temp = message.split(" ");
        final String[] args = new String[temp.length - 1];
        final String commandName = temp[0];
        System.arraycopy(temp, 1, args, 0, args.length);
        final ab icommand = this.a().get(commandName);
        try {
            if (icommand == null) {
                return 0;
            }
            if (icommand.a(sender)) {
                final CommandEvent event = new CommandEvent(icommand, sender, args);
                if (!MinecraftForge.EVENT_BUS.post(event)) {
                    icommand.b(sender, args);
                    return 1;
                }
                if (event.exception != null) {
                    throw event.exception;
                }
                return 0;
            }
            else {
                sender.a(this.format("commands.generic.permission").a(a.m));
            }
        }
        catch (final bd wue) {
            sender.a(this.format("commands.generic.usage", this.format(wue.getMessage(), wue.a())).a(a.m));
        }
        catch (final ay ce) {
            sender.a(this.format(ce.getMessage(), ce.a()).a(a.m));
        }
        catch (final Throwable t) {
            sender.a(this.format("commands.generic.exception").a(a.m));
            t.printStackTrace();
        }
        return 0;
    }
    
    private cv format(final String str, final Object... args) {
        return cv.b(str, args);
    }
    
    private cv format(final String str) {
        return cv.e(str);
    }
    
    public void autoComplete(String leftOfCursor, final String full) {
        this.latestAutoComplete = null;
        if (leftOfCursor.charAt(0) == '/') {
            leftOfCursor = leftOfCursor.substring(1);
            final atv mc = FMLClientHandler.instance().getClient();
            if (mc.n instanceof auw) {
                final List<String> commands = this.b((ad)mc.h, leftOfCursor);
                if (commands != null && !commands.isEmpty()) {
                    if (leftOfCursor.indexOf(32) == -1) {
                        for (int i = 0; i < commands.size(); ++i) {
                            commands.set(i, a.h + "/" + commands.get(i) + a.v);
                        }
                    }
                    else {
                        for (int i = 0; i < commands.size(); ++i) {
                            commands.set(i, a.h + commands.get(i) + a.v);
                        }
                    }
                    this.latestAutoComplete = commands.toArray(new String[commands.size()]);
                }
            }
        }
    }
    
    static {
        instance = new ClientCommandHandler();
    }
}



================================================
FILE: net/minecraftforge/client/EnumHelperClient.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client;

import net.minecraftforge.common.EnumHelper;

public class EnumHelperClient extends EnumHelper
{
    private static Class[][] clentTypes;
    
    public static ace addGameType(final String name, final int id, final String displayName) {
        return addEnum(ace.class, name, id, displayName);
    }
    
    public static aun addOptions(final String name, final String langName, final boolean isSlider, final boolean isToggle) {
        return addEnum(aun.class, name, langName, isSlider, isToggle);
    }
    
    public static x addOS2(final String name) {
        return addEnum(x.class, name, new Object[0]);
    }
    
    public static yq addRarity(final String name, final int color, final String displayName) {
        return addEnum(yq.class, name, color, displayName);
    }
    
    public static <T extends Enum<?>> T addEnum(final Class<T> enumType, final String enumName, final Object... paramValues) {
        return EnumHelper.addEnum(EnumHelperClient.clentTypes, enumType, enumName, paramValues);
    }
    
    static {
        EnumHelperClient.clentTypes = new Class[][] { { ace.class, Integer.TYPE, String.class }, { aun.class, String.class, Boolean.TYPE, Boolean.TYPE }, { x.class }, { yq.class, Integer.TYPE, String.class } };
    }
}



================================================
FILE: net/minecraftforge/client/ForgeHooksClient.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client;

import cpw.mods.fml.client.registry.ISimpleBlockRenderingHandler;
import net.minecraftforge.fluids.RenderBlockFluid;
import cpw.mods.fml.client.registry.RenderingRegistry;
import net.minecraftforge.common.ForgeDummyContainer;
import net.minecraftforge.client.event.FOVUpdateEvent;
import net.minecraftforge.client.event.MouseEvent;
import org.lwjgl.LWJGLException;
import org.lwjgl.opengl.Display;
import org.lwjgl.opengl.PixelFormat;
import javax.imageio.ImageIO;
import net.minecraftforge.fluids.FluidRegistry;
import net.minecraftforge.client.event.TextureStitchEvent;
import net.minecraftforge.client.event.RenderWorldLastEvent;
import net.minecraftforge.event.Event;
import net.minecraftforge.client.event.DrawBlockHighlightEvent;
import net.minecraftforge.common.MinecraftForge;
import org.lwjgl.opengl.GL11;
import java.util.Random;
import cpw.mods.fml.client.FMLClientHandler;

public class ForgeHooksClient
{
    private static final bjo ITEM_GLINT;
    static int renderPass;
    static int stencilBits;
    private static int skyX;
    private static int skyZ;
    private static boolean skyInit;
    private static int skyRGBMultiplier;
    
    static bim engine() {
        return FMLClientHandler.instance().getClient().N;
    }
    
    @Deprecated
    public static String getArmorTexture(final nn entity, final ye armor, final String _default, final int slot, final int layer, final String type) {
        return getArmorTexture(entity, armor, _default, slot, type);
    }
    
    public static String getArmorTexture(final nn entity, final ye armor, final String _default, final int slot, final String type) {
        final String result = armor.b().getArmorTexture(armor, entity, slot, type);
        return (result != null) ? result : _default;
    }
    
    public static boolean renderEntityItem(final ss entity, final ye item, final float bobing, final float rotation, final Random random, final bim engine, final bfr renderBlocks) {
        final IItemRenderer customRenderer = MinecraftForgeClient.getItemRenderer(item, IItemRenderer.ItemRenderType.ENTITY);
        if (customRenderer == null) {
            return false;
        }
        if (customRenderer.shouldUseRenderHelper(IItemRenderer.ItemRenderType.ENTITY, item, IItemRenderer.ItemRendererHelper.ENTITY_ROTATION)) {
            GL11.glRotatef(rotation, 0.0f, 1.0f, 0.0f);
        }
        if (!customRenderer.shouldUseRenderHelper(IItemRenderer.ItemRenderType.ENTITY, item, IItemRenderer.ItemRendererHelper.ENTITY_BOBBING)) {
            GL11.glTranslatef(0.0f, -bobing, 0.0f);
        }
        final boolean is3D = customRenderer.shouldUseRenderHelper(IItemRenderer.ItemRenderType.ENTITY, item, IItemRenderer.ItemRendererHelper.BLOCK_3D);
        engine.a((item.d() == 0) ? bik.b : bik.c);
        final aqz block = (item.d < aqz.s.length) ? aqz.s[item.d] : null;
        if (is3D || (block != null && bfr.a(block.d()))) {
            final int renderType = (block != null) ? block.d() : 1;
            final float scale = (renderType == 1 || renderType == 19 || renderType == 12 || renderType == 2) ? 0.5f : 0.25f;
            if (bgw.g) {
                GL11.glScalef(1.25f, 1.25f, 1.25f);
                GL11.glTranslatef(0.0f, 0.05f, 0.0f);
                GL11.glRotatef(-90.0f, 0.0f, 1.0f, 0.0f);
            }
            GL11.glScalef(scale, scale, scale);
            final int size = item.b;
            for (int count = (size > 40) ? 5 : ((size > 20) ? 4 : ((size > 5) ? 3 : ((size > 1) ? 2 : 1))), j = 0; j < count; ++j) {
                GL11.glPushMatrix();
                if (j > 0) {
                    GL11.glTranslatef((random.nextFloat() * 2.0f - 1.0f) * 0.2f / scale, (random.nextFloat() * 2.0f - 1.0f) * 0.2f / scale, (random.nextFloat() * 2.0f - 1.0f) * 0.2f / scale);
                }
                customRenderer.renderItem(IItemRenderer.ItemRenderType.ENTITY, item, renderBlocks, entity);
                GL11.glPopMatrix();
            }
        }
        else {
            GL11.glScalef(0.5f, 0.5f, 0.5f);
            customRenderer.renderItem(IItemRenderer.ItemRenderType.ENTITY, item, renderBlocks, entity);
        }
        return true;
    }
    
    public static boolean renderInventoryItem(final bfr renderBlocks, final bim engine, final ye item, final boolean inColor, final float zLevel, final float x, final float y) {
        final IItemRenderer customRenderer = MinecraftForgeClient.getItemRenderer(item, IItemRenderer.ItemRenderType.INVENTORY);
        if (customRenderer == null) {
            return false;
        }
        engine.a((item.d() == 0) ? bik.b : bik.c);
        if (customRenderer.shouldUseRenderHelper(IItemRenderer.ItemRenderType.INVENTORY, item, IItemRenderer.ItemRendererHelper.INVENTORY_BLOCK)) {
            GL11.glPushMatrix();
            GL11.glTranslatef(x - 2.0f, y + 3.0f, -3.0f + zLevel);
            GL11.glScalef(10.0f, 10.0f, 10.0f);
            GL11.glTranslatef(1.0f, 0.5f, 1.0f);
            GL11.glScalef(1.0f, 1.0f, -1.0f);
            GL11.glRotatef(210.0f, 1.0f, 0.0f, 0.0f);
            GL11.glRotatef(45.0f, 0.0f, 1.0f, 0.0f);
            if (inColor) {
                final int color = yc.g[item.d].a(item, 0);
                final float r = (color >> 16 & 0xFF) / 255.0f;
                final float g = (color >> 8 & 0xFF) / 255.0f;
                final float b = (color & 0xFF) / 255.0f;
                GL11.glColor4f(r, g, b, 1.0f);
            }
            GL11.glRotatef(-90.0f, 0.0f, 1.0f, 0.0f);
            renderBlocks.c = inColor;
            customRenderer.renderItem(IItemRenderer.ItemRenderType.INVENTORY, item, renderBlocks);
            renderBlocks.c = true;
            GL11.glPopMatrix();
        }
        else {
            GL11.glDisable(2896);
            GL11.glPushMatrix();
            GL11.glTranslatef(x, y, -3.0f + zLevel);
            if (inColor) {
                final int color = yc.g[item.d].a(item, 0);
                final float r = (color >> 16 & 0xFF) / 255.0f;
                final float g = (color >> 8 & 0xFF) / 255.0f;
                final float b = (color & 0xFF) / 255.0f;
                GL11.glColor4f(r, g, b, 1.0f);
            }
            customRenderer.renderItem(IItemRenderer.ItemRenderType.INVENTORY, item, renderBlocks);
            GL11.glPopMatrix();
            GL11.glEnable(2896);
        }
        return true;
    }
    
    public static void renderEffectOverlay(final bim manager, final bgw render) {
    }
    
    public static void renderEquippedItem(final IItemRenderer.ItemRenderType type, final IItemRenderer customRenderer, final bfr renderBlocks, final of entity, final ye item) {
        if (customRenderer.shouldUseRenderHelper(type, item, IItemRenderer.ItemRendererHelper.EQUIPPED_BLOCK)) {
            GL11.glPushMatrix();
            GL11.glTranslatef(-0.5f, -0.5f, -0.5f);
            customRenderer.renderItem(type, item, renderBlocks, entity);
            GL11.glPopMatrix();
        }
        else {
            GL11.glPushMatrix();
            GL11.glEnable(32826);
            GL11.glTranslatef(0.0f, -0.3f, 0.0f);
            GL11.glScalef(1.5f, 1.5f, 1.5f);
            GL11.glRotatef(50.0f, 0.0f, 1.0f, 0.0f);
            GL11.glRotatef(335.0f, 0.0f, 0.0f, 1.0f);
            GL11.glTranslatef(-0.9375f, -0.0625f, 0.0f);
            customRenderer.renderItem(type, item, renderBlocks, entity);
            GL11.glDisable(32826);
            GL11.glPopMatrix();
        }
    }
    
    public static void orientBedCamera(final atv mc, final of entity) {
        final int x = ls.c(entity.u);
        final int y = ls.c(entity.v);
        final int z = ls.c(entity.w);
        final aqz block = aqz.s[mc.f.a(x, y, z)];
        if (block != null && block.isBed((abw)mc.f, x, y, z, entity)) {
            final int var12 = block.getBedDirection((acf)mc.f, x, y, z);
            GL11.glRotatef((float)(var12 * 90), 0.0f, 1.0f, 0.0f);
        }
    }
    
    public static boolean onDrawBlockHighlight(final bfl context, final uf player, final ata target, final int subID, final ye currentItem, final float partialTicks) {
        return MinecraftForge.EVENT_BUS.post(new DrawBlockHighlightEvent(context, player, target, subID, currentItem, partialTicks));
    }
    
    public static void dispatchRenderLast(final bfl context, final float partialTicks) {
        MinecraftForge.EVENT_BUS.post(new RenderWorldLastEvent(context, partialTicks));
    }
    
    public static void onTextureStitchedPre(final bik map) {
        MinecraftForge.EVENT_BUS.post(new TextureStitchEvent.Pre(map));
    }
    
    public static void onTextureStitchedPost(final bik map) {
        MinecraftForge.EVENT_BUS.post(new TextureStitchEvent.Post(map));
        FluidRegistry.WATER.setIcons(apc.b("water_still"), apc.b("water_flow"));
        FluidRegistry.LAVA.setIcons(apc.b("lava_still"), apc.b("lava_flow"));
    }
    
    public static void onTextureLoadPre(final String texture) {
        if (bfq.renderingWorldRenderer) {
            final String msg = String.format("Warning: Texture %s not preloaded, will cause render glitches!", texture);
            System.out.println(msg);
            if (bfq.class.getPackage() != null && bfq.class.getPackage().getName().startsWith("net.minecraft.")) {
                final atv mc = FMLClientHandler.instance().getClient();
                if (mc.r != null) {
                    mc.r.b().a(msg);
                }
            }
        }
    }
    
    public static void setRenderPass(final int pass) {
        ForgeHooksClient.renderPass = pass;
    }
    
    public static bbj getArmorModel(final of entityLiving, final ye itemStack, final int slotID, final bbj _default) {
        final bbj modelbiped = itemStack.b().getArmorModel(entityLiving, itemStack, slotID);
        return (modelbiped == null) ? _default : modelbiped;
    }
    
    public static void createDisplay() throws LWJGLException {
        ImageIO.setUseCache(false);
        final PixelFormat format = new PixelFormat().withDepthBits(24);
        try {
            Display.create(format.withStencilBits(8));
            ForgeHooksClient.stencilBits = 8;
        }
        catch (final LWJGLException e) {
            Display.create(format);
            ForgeHooksClient.stencilBits = 0;
        }
    }
    
    public static String fixDomain(final String base, final String complex) {
        final int idx = complex.indexOf(58);
        if (idx == -1) {
            return base + complex;
        }
        final String name = complex.substring(idx + 1, complex.length());
        if (idx > 1) {
            final String domain = complex.substring(0, idx);
            return domain + ':' + base + name;
        }
        return base + name;
    }
    
    public static boolean postMouseEvent() {
        return MinecraftForge.EVENT_BUS.post(new MouseEvent());
    }
    
    public static float getOffsetFOV(final bex entity, final float fov) {
        final FOVUpdateEvent fovUpdateEvent = new FOVUpdateEvent(entity, fov);
        MinecraftForge.EVENT_BUS.post(fovUpdateEvent);
        return fovUpdateEvent.newfov;
    }
    
    public static int getSkyBlendColour(final abw world, final int playerX, final int playerZ) {
        if (playerX == ForgeHooksClient.skyX && playerZ == ForgeHooksClient.skyZ && ForgeHooksClient.skyInit) {
            return ForgeHooksClient.skyRGBMultiplier;
        }
        ForgeHooksClient.skyInit = true;
        final int distance = atv.w().u.j ? ForgeDummyContainer.blendRanges[atv.w().u.e] : 0;
        int r = 0;
        int g = 0;
        int b = 0;
        int divider = 0;
        for (int x = -distance; x <= distance; ++x) {
            for (int z = -distance; z <= distance; ++z) {
                final acq biome = world.a(playerX + x, playerZ + z);
                final int colour = biome.a(biome.j());
                r += (colour & 0xFF0000) >> 16;
                g += (colour & 0xFF00) >> 8;
                b += (colour & 0xFF);
                ++divider;
            }
        }
        final int multiplier = (r / divider & 0xFF) << 16 | (g / divider & 0xFF) << 8 | (b / divider & 0xFF);
        ForgeHooksClient.skyX = playerX;
        ForgeHooksClient.skyZ = playerZ;
        return ForgeHooksClient.skyRGBMultiplier = multiplier;
    }
    
    static {
        ITEM_GLINT = new bjo("textures/misc/enchanted_item_glint.png");
        ForgeHooksClient.renderPass = -1;
        ForgeHooksClient.stencilBits = 0;
        FluidRegistry.renderIdFluid = RenderingRegistry.getNextAvailableRenderId();
        RenderingRegistry.registerBlockHandler(RenderBlockFluid.instance);
    }
}



================================================
FILE: net/minecraftforge/client/GuiControlsScrollPanel.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client;

import org.lwjgl.opengl.GL11;
import org.lwjgl.input.Mouse;

public class GuiControlsScrollPanel extends awg
{
    protected static final bjo WIDGITS;
    private auy controls;
    private aul options;
    private atv a;
    private String[] message;
    private int _mouseX;
    private int _mouseY;
    private int selected;
    
    public GuiControlsScrollPanel(final auy controls, final aul options, final atv mc) {
        super(mc, controls.g, controls.h, 16, controls.h - 32 + 4, 25);
        this.selected = -1;
        this.controls = controls;
        this.options = options;
        this.a = mc;
    }
    
    protected int a() {
        return this.options.W.length;
    }
    
    protected void a(final int i, final boolean flag) {
        if (!flag) {
            if (this.selected == -1) {
                this.selected = i;
            }
            else {
                this.options.a(this.selected, -100);
                this.selected = -1;
                ats.b();
            }
        }
    }
    
    protected boolean a(final int i) {
        return false;
    }
    
    protected void b() {
    }
    
    public void a(final int mX, final int mY, final float f) {
        this._mouseX = mX;
        this._mouseY = mY;
        if (this.selected != -1 && !Mouse.isButtonDown(0) && Mouse.getDWheel() == 0 && Mouse.next() && Mouse.getEventButtonState()) {
            this.options.a(this.selected, -100 + Mouse.getEventButton());
            this.selected = -1;
            ats.b();
        }
        super.a(mX, mY, f);
    }
    
    protected void a(final int index, int xPosition, final int yPosition, final int l, final bfq tessellator) {
        final int width = 70;
        final int height = 20;
        xPosition -= 20;
        final boolean flag = this._mouseX >= xPosition && this._mouseY >= yPosition && this._mouseX < xPosition + width && this._mouseY < yPosition + height;
        final int k = flag ? 2 : 1;
        this.a.N.a(GuiControlsScrollPanel.WIDGITS);
        GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
        this.controls.b(xPosition, yPosition, 0, 46 + k * 20, width / 2, height);
        this.controls.b(xPosition + width / 2, yPosition, 200 - width / 2, 46 + k * 20, width / 2, height);
        this.controls.b(this.a.l, this.options.a(index), xPosition + width + 4, yPosition + 6, -1);
        boolean conflict = false;
        for (int x = 0; x < this.options.W.length; ++x) {
            if (x != index && this.options.W[x].d == this.options.W[index].d) {
                conflict = true;
                break;
            }
        }
        String str = (conflict ? a.m : "") + this.options.b(index);
        str = ((index == this.selected) ? (a.p + "> " + a.o + "??? " + a.p + "<") : str);
        this.controls.a(this.a.l, str, xPosition + width / 2, yPosition + (height - 8) / 2, -1);
    }
    
    public boolean keyTyped(final char c, final int i) {
        if (this.selected != -1) {
            this.options.a(this.selected, i);
            this.selected = -1;
            ats.b();
            return false;
        }
        return true;
    }
    
    static {
        WIDGITS = new bjo("textures/gui/widgets.png");
    }
}



================================================
FILE: net/minecraftforge/client/GuiIngameForge.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client;

import java.util.List;
import java.awt.Color;
import java.util.Iterator;
import net.minecraftforge.event.Event;
import net.minecraftforge.common.MinecraftForge;
import cpw.mods.fml.common.FMLCommonHandler;
import java.util.ArrayList;
import net.minecraftforge.common.ForgeHooks;
import org.lwjgl.opengl.GL11;
import net.minecraftforge.client.event.RenderGameOverlayEvent;

public class GuiIngameForge extends avj
{
    private static final bjo VIGNETTE;
    private static final bjo WIDGITS;
    private static final bjo PUMPKIN_BLUR;
    private static final int WHITE = 16777215;
    public static boolean renderHelmet;
    public static boolean renderPortal;
    public static boolean renderHotbar;
    public static boolean renderCrosshairs;
    public static boolean renderBossHealth;
    public static boolean renderHealth;
    public static boolean renderArmor;
    public static boolean renderFood;
    public static boolean renderHealthMount;
    public static boolean renderAir;
    public static boolean renderExperiance;
    public static boolean renderJumpBar;
    public static boolean renderObjective;
    public static int left_height;
    public static int right_height;
    private awf res;
    private avi fontrenderer;
    private RenderGameOverlayEvent eventParent;
    private static final String MC_VERSION;
    
    public GuiIngameForge(final atv mc) {
        super(mc);
        this.res = null;
        this.fontrenderer = null;
    }
    
    public void a(final float partialTicks, final boolean hasScreen, final int mouseX, final int mouseY) {
        this.res = new awf(this.g.u, this.g.d, this.g.e);
        this.eventParent = new RenderGameOverlayEvent(partialTicks, this.res, mouseX, mouseY);
        final int width = this.res.a();
        final int height = this.res.b();
        GuiIngameForge.renderHealthMount = (this.g.h.o instanceof of);
        GuiIngameForge.renderFood = (this.g.h.o == null);
        GuiIngameForge.renderJumpBar = this.g.h.u();
        GuiIngameForge.right_height = 39;
        GuiIngameForge.left_height = 39;
        if (this.pre(RenderGameOverlayEvent.ElementType.ALL)) {
            return;
        }
        this.fontrenderer = this.g.l;
        this.g.p.c();
        GL11.glEnable(3042);
        if (atv.s()) {
            this.a(this.g.h.d(partialTicks), width, height);
        }
        else {
            GL11.glBlendFunc(770, 771);
        }
        if (GuiIngameForge.renderHelmet) {
            this.renderHelmet(this.res, partialTicks, hasScreen, mouseX, mouseY);
        }
        if (GuiIngameForge.renderPortal && !this.g.h.a(ni.k)) {
            this.renderPortal(width, height, partialTicks);
        }
        if (!this.g.c.a()) {
            GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
            this.n = -90.0f;
            this.f.setSeed(this.i * 312871);
            if (GuiIngameForge.renderCrosshairs) {
                this.renderCrosshairs(width, height);
            }
            if (GuiIngameForge.renderBossHealth) {
                this.d();
            }
            if (this.g.c.b()) {
                if (GuiIngameForge.renderHealth) {
                    this.renderHealth(width, height);
                }
                if (GuiIngameForge.renderArmor) {
                    this.renderArmor(width, height);
                }
                if (GuiIngameForge.renderFood) {
                    this.renderFood(width, height);
                }
                if (GuiIngameForge.renderHealthMount) {
                    this.renderHealthMount(width, height);
                }
                if (GuiIngameForge.renderAir) {
                    this.renderAir(width, height);
                }
            }
            if (GuiIngameForge.renderHotbar) {
                this.renderHotbar(width, height, partialTicks);
            }
        }
        if (GuiIngameForge.renderJumpBar) {
            this.renderJumpBar(width, height);
        }
        else if (GuiIngameForge.renderExperiance) {
            this.renderExperience(width, height);
        }
        this.renderSleepFade(width, height);
        this.renderToolHightlight(width, height);
        this.renderHUDText(width, height);
        this.renderRecordOverlay(width, height, partialTicks);
        final ate objective = this.g.f.X().a(1);
        if (GuiIngameForge.renderObjective && objective != null) {
            this.a(objective, height, width, this.fontrenderer);
        }
        GL11.glEnable(3042);
        GL11.glBlendFunc(770, 771);
        GL11.glDisable(3008);
        this.renderChat(width, height);
        this.renderPlayerList(width, height);
        GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
        GL11.glDisable(2896);
        GL11.glEnable(3008);
        this.post(RenderGameOverlayEvent.ElementType.ALL);
    }
    
    public awf getResolution() {
        return this.res;
    }
    
    protected void renderHotbar(final int width, final int height, final float partialTicks) {
        if (this.pre(RenderGameOverlayEvent.ElementType.HOTBAR)) {
            return;
        }
        this.g.C.a("actionBar");
        GL11.glEnable(3042);
        GL11.glBlendFunc(770, 771);
        GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
        this.g.N.a(GuiIngameForge.WIDGITS);
        final ud inv = this.g.h.bn;
        this.b(width / 2 - 91, height - 22, 0, 0, 182, 22);
        this.b(width / 2 - 91 - 1 + inv.c * 20, height - 22 - 1, 0, 22, 24, 22);
        GL11.glDisable(3042);
        GL11.glEnable(32826);
        att.c();
        for (int i = 0; i < 9; ++i) {
            final int x = width / 2 - 90 + i * 20 + 2;
            final int z = height - 16 - 3;
            this.a(i, x, z, partialTicks);
        }
        att.a();
        GL11.glDisable(32826);
        this.g.C.b();
        this.post(RenderGameOverlayEvent.ElementType.HOTBAR);
    }
    
    protected void renderCrosshairs(final int width, final int height) {
        if (this.pre(RenderGameOverlayEvent.ElementType.CROSSHAIRS)) {
            return;
        }
        this.bind(avk.m);
        GL11.glEnable(3042);
        GL11.glBlendFunc(775, 769);
        this.b(width / 2 - 7, height / 2 - 7, 0, 0, 16, 16);
        GL11.glDisable(3042);
        this.post(RenderGameOverlayEvent.ElementType.CROSSHAIRS);
    }
    
    protected void d() {
        if (this.pre(RenderGameOverlayEvent.ElementType.BOSSHEALTH)) {
            return;
        }
        this.g.C.a("bossHealth");
        super.d();
        this.g.C.b();
        this.post(RenderGameOverlayEvent.ElementType.BOSSHEALTH);
    }
    
    private void renderHelmet(final awf res, final float partialTicks, final boolean hasScreen, final int mouseX, final int mouseY) {
        if (this.pre(RenderGameOverlayEvent.ElementType.HELMET)) {
            return;
        }
        final ye itemstack = this.g.h.bn.f(3);
        if (this.g.u.aa == 0 && itemstack != null && itemstack.b() != null) {
            if (itemstack.d == aqz.bf.cF) {
                this.b(res.a(), res.b());
            }
            else {
                itemstack.b().renderHelmetOverlay(itemstack, (uf)this.g.h, res, partialTicks, hasScreen, mouseX, mouseY);
            }
        }
        this.post(RenderGameOverlayEvent.ElementType.HELMET);
    }
    
    protected void renderArmor(final int width, final int height) {
        if (this.pre(RenderGameOverlayEvent.ElementType.ARMOR)) {
            return;
        }
        this.g.C.a("armor");
        int left = width / 2 - 91;
        final int top = height - GuiIngameForge.left_height;
        for (int level = ForgeHooks.getTotalArmorValue((uf)this.g.h), i = 1; level > 0 && i < 20; i += 2) {
            if (i < level) {
                this.b(left, top, 34, 9, 9, 9);
            }
            else if (i == level) {
                this.b(left, top, 25, 9, 9, 9);
            }
            else if (i > level) {
                this.b(left, top, 16, 9, 9, 9);
            }
            left += 8;
        }
        GuiIngameForge.left_height += 10;
        this.g.C.b();
        this.post(RenderGameOverlayEvent.ElementType.ARMOR);
    }
    
    protected void renderPortal(final int width, final int height, final float partialTicks) {
        if (this.pre(RenderGameOverlayEvent.ElementType.PORTAL)) {
            return;
        }
        final float f1 = this.g.h.bO + (this.g.h.bN - this.g.h.bO) * partialTicks;
        if (f1 > 0.0f) {
            this.b(f1, width, height);
        }
        this.post(RenderGameOverlayEvent.ElementType.PORTAL);
    }
    
    protected void renderAir(final int width, final int height) {
        if (this.pre(RenderGameOverlayEvent.ElementType.AIR)) {
            return;
        }
        this.g.C.a("air");
        final int left = width / 2 + 91;
        final int top = height - GuiIngameForge.right_height;
        if (this.g.h.a(akc.h)) {
            final int air = this.g.h.al();
            for (int full = ls.f((air - 2) * 10.0 / 300.0), partial = ls.f(air * 10.0 / 300.0) - full, i = 0; i < full + partial; ++i) {
                this.b(left - i * 8 - 9, top, (i < full) ? 16 : 25, 18, 9, 9);
            }
            GuiIngameForge.right_height += 10;
        }
        this.g.C.b();
        this.post(RenderGameOverlayEvent.ElementType.AIR);
    }
    
    public void renderHealth(final int width, final int height) {
        this.bind(GuiIngameForge.m);
        if (this.pre(RenderGameOverlayEvent.ElementType.HEALTH)) {
            return;
        }
        this.g.C.a("health");
        boolean highlight = this.g.h.af / 3 % 2 == 1;
        if (this.g.h.af < 10) {
            highlight = false;
        }
        final os attrMaxHealth = this.g.h.a(tp.a);
        final int health = ls.f(this.g.h.aN());
        final int healthLast = ls.f(this.g.h.ax);
        final float healthMax = (float)attrMaxHealth.e();
        final float absorb = this.g.h.bn();
        final int healthRows = ls.f((healthMax + absorb) / 2.0f / 10.0f);
        final int rowHeight = Math.max(10 - (healthRows - 2), 3);
        this.f.setSeed(this.i * 312871);
        final int left = width / 2 - 91;
        final int top = height - GuiIngameForge.left_height;
        GuiIngameForge.left_height += healthRows * rowHeight;
        if (rowHeight != 10) {
            GuiIngameForge.left_height += 10 - rowHeight;
        }
        int regen = -1;
        if (this.g.h.a(ni.l)) {
            regen = this.i % 25;
        }
        final int TOP = 9 * (this.g.f.N().t() ? 5 : 0);
        final int BACKGROUND = highlight ? 25 : 16;
        int MARGIN = 16;
        if (this.g.h.a(ni.u)) {
            MARGIN += 36;
        }
        else if (this.g.h.a(ni.v)) {
            MARGIN += 72;
        }
        float absorbRemaining = absorb;
        for (int i = ls.f((healthMax + absorb) / 2.0f) - 1; i >= 0; --i) {
            final int b0 = highlight ? 1 : 0;
            final int row = ls.f((i + 1) / 10.0f) - 1;
            final int x = left + i % 10 * 8;
            int y = top - row * rowHeight;
            if (health <= 4) {
                y += this.f.nextInt(2);
            }
            if (i == regen) {
                y -= 2;
            }
            this.b(x, y, BACKGROUND, TOP, 9, 9);
            if (highlight) {
                if (i * 2 + 1 < healthLast) {
                    this.b(x, y, MARGIN + 54, TOP, 9, 9);
                }
                else if (i * 2 + 1 == healthLast) {
                    this.b(x, y, MARGIN + 63, TOP, 9, 9);
                }
            }
            if (absorbRemaining > 0.0f) {
                if (absorbRemaining == absorb && absorb % 2.0f == 1.0f) {
                    this.b(x, y, MARGIN + 153, TOP, 9, 9);
                }
                else {
                    this.b(x, y, MARGIN + 144, TOP, 9, 9);
                }
                absorbRemaining -= 2.0f;
            }
            else if (i * 2 + 1 < health) {
                this.b(x, y, MARGIN + 36, TOP, 9, 9);
            }
            else if (i * 2 + 1 == health) {
                this.b(x, y, MARGIN + 45, TOP, 9, 9);
            }
        }
        this.g.C.b();
        this.post(RenderGameOverlayEvent.ElementType.HEALTH);
    }
    
    public void renderFood(final int width, final int height) {
        if (this.pre(RenderGameOverlayEvent.ElementType.FOOD)) {
            return;
        }
        this.g.C.a("food");
        final int left = width / 2 + 91;
        final int top = height - GuiIngameForge.right_height;
        GuiIngameForge.right_height += 10;
        final boolean unused = false;
        final ux stats = this.g.h.bI();
        final int level = stats.a();
        final int levelLast = stats.b();
        for (int i = 0; i < 10; ++i) {
            final int idx = i * 2 + 1;
            final int x = left - i * 8 - 9;
            int y = top;
            int icon = 16;
            byte backgound = 0;
            if (this.g.h.a(ni.s)) {
                icon += 36;
                backgound = 13;
            }
            if (unused) {
                backgound = 1;
            }
            if (this.g.h.bI().e() <= 0.0f && this.i % (level * 3 + 1) == 0) {
                y = top + (this.f.nextInt(3) - 1);
            }
            this.b(x, y, 16 + backgound * 9, 27, 9, 9);
            if (unused) {
                if (idx < levelLast) {
                    this.b(x, y, icon + 54, 27, 9, 9);
                }
                else if (idx == levelLast) {
                    this.b(x, y, icon + 63, 27, 9, 9);
                }
            }
            if (idx < level) {
                this.b(x, y, icon + 36, 27, 9, 9);
            }
            else if (idx == level) {
                this.b(x, y, icon + 45, 27, 9, 9);
            }
        }
        this.g.C.b();
        this.post(RenderGameOverlayEvent.ElementType.FOOD);
    }
    
    protected void renderSleepFade(final int width, final int height) {
        if (this.g.h.bE() > 0) {
            this.g.C.a("sleep");
            GL11.glDisable(2929);
            GL11.glDisable(3008);
            final int sleepTime = this.g.h.bE();
            float opacity = sleepTime / 100.0f;
            if (opacity > 1.0f) {
                opacity = 1.0f - (sleepTime - 100) / 10.0f;
            }
            final int color = (int)(220.0f * opacity) << 24 | 0x101020;
            a(0, 0, width, height, color);
            GL11.glEnable(3008);
            GL11.glEnable(2929);
            this.g.C.b();
        }
    }
    
    protected void renderExperience(final int width, final int height) {
        this.bind(GuiIngameForge.m);
        if (this.pre(RenderGameOverlayEvent.ElementType.EXPERIENCE)) {
            return;
        }
        GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
        if (this.g.c.f()) {
            this.g.C.a("expBar");
            final int cap = this.g.h.bH();
            final int left = width / 2 - 91;
            if (cap > 0) {
                final short barWidth = 182;
                final int filled = (int)(this.g.h.bJ * (barWidth + 1));
                final int top = height - 32 + 3;
                this.b(left, top, 0, 64, (int)barWidth, 5);
                if (filled > 0) {
                    this.b(left, top, 0, 69, filled, 5);
                }
            }
            this.g.C.b();
            if (this.g.c.f() && this.g.h.bH > 0) {
                this.g.C.a("expLevel");
                final boolean flag1 = false;
                final int color = flag1 ? 16777215 : 8453920;
                final String text = "" + this.g.h.bH;
                final int x = (width - this.fontrenderer.a(text)) / 2;
                final int y = height - 31 - 4;
                this.fontrenderer.b(text, x + 1, y, 0);
                this.fontrenderer.b(text, x - 1, y, 0);
                this.fontrenderer.b(text, x, y + 1, 0);
                this.fontrenderer.b(text, x, y - 1, 0);
                this.fontrenderer.b(text, x, y, color);
                this.g.C.b();
            }
        }
        GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
        this.post(RenderGameOverlayEvent.ElementType.EXPERIENCE);
    }
    
    protected void renderJumpBar(final int width, final int height) {
        this.bind(GuiIngameForge.m);
        if (this.pre(RenderGameOverlayEvent.ElementType.JUMPBAR)) {
            return;
        }
        GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
        this.g.C.a("jumpBar");
        final float charge = this.g.h.bN();
        final int barWidth = 182;
        final int x = width / 2 - 91;
        final int filled = (int)(charge * 183.0f);
        final int top = height - 32 + 3;
        this.b(x, top, 0, 84, 182, 5);
        if (filled > 0) {
            this.b(x, top, 0, 89, filled, 5);
        }
        this.g.C.b();
        GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
        this.post(RenderGameOverlayEvent.ElementType.JUMPBAR);
    }
    
    protected void renderToolHightlight(final int width, final int height) {
        if (this.g.u.D) {
            this.g.C.a("toolHighlight");
            if (this.q > 0 && this.r != null) {
                final String name = this.r.s();
                int opacity = (int)(this.q * 256.0f / 10.0f);
                if (opacity > 255) {
                    opacity = 255;
                }
                if (opacity > 0) {
                    int y = height - 59;
                    if (!this.g.c.b()) {
                        y += 14;
                    }
                    GL11.glPushMatrix();
                    GL11.glEnable(3042);
                    GL11.glBlendFunc(770, 771);
                    final avi font = this.r.b().getFontRenderer(this.r);
                    if (font != null) {
                        final int x = (width - font.a(name)) / 2;
                        font.a(name, x, y, 0xFFFFFF | opacity << 24);
                    }
                    else {
                        final int x = (width - this.fontrenderer.a(name)) / 2;
                        this.fontrenderer.a(name, x, y, 0xFFFFFF | opacity << 24);
                    }
                    GL11.glDisable(3042);
                    GL11.glPopMatrix();
                }
            }
            this.g.C.b();
        }
    }
    
    protected void renderHUDText(final int width, final int height) {
        this.g.C.a("forgeHudText");
        final ArrayList<String> left = new ArrayList<String>();
        final ArrayList<String> right = new ArrayList<String>();
        if (this.g.p()) {
            final long time = this.g.f.I();
            if (time >= 120500L) {
                right.add(bu.a("demo.demoExpired"));
            }
            else {
                right.add(String.format(bu.a("demo.remainingTime"), ma.a((int)(120500L - time))));
            }
        }
        if (this.g.u.ab) {
            this.g.C.a("debug");
            GL11.glPushMatrix();
            left.add("Minecraft " + GuiIngameForge.MC_VERSION + " (" + this.g.E + ")");
            left.add(this.g.l());
            left.add(this.g.m());
            left.add(this.g.o());
            left.add(this.g.n());
            left.add(null);
            final long max = Runtime.getRuntime().maxMemory();
            final long total = Runtime.getRuntime().totalMemory();
            final long free = Runtime.getRuntime().freeMemory();
            final long used = total - free;
            right.add("Used memory: " + used * 100L / max + "% (" + used / 1024L / 1024L + "MB) of " + max / 1024L / 1024L + "MB");
            right.add("Allocated memory: " + total * 100L / max + "% (" + total / 1024L / 1024L + "MB)");
            final int x = ls.c(this.g.h.u);
            final int y = ls.c(this.g.h.v);
            final int z = ls.c(this.g.h.w);
            final float yaw = this.g.h.A;
            final int heading = ls.c(this.g.h.A * 4.0f / 360.0f + 0.5) & 0x3;
            left.add(String.format("x: %.5f (%d) // c: %d (%d)", this.g.h.u, x, x >> 4, x & 0xF));
            left.add(String.format("y: %.3f (feet pos, %.3f eyes pos)", this.g.h.E.b, this.g.h.v));
            left.add(String.format("z: %.5f (%d) // c: %d (%d)", this.g.h.w, z, z >> 4, z & 0xF));
            left.add(String.format("f: %d (%s) / %f", heading, r.c[heading], ls.g(yaw)));
            if (this.g.f != null && this.g.f.f(x, y, z)) {
                final adr chunk = this.g.f.d(x, z);
                left.add(String.format("lc: %d b: %s bl: %d sl: %d rl: %d", chunk.h() + 15, chunk.a(x & 0xF, z & 0xF, this.g.f.u()).y, chunk.a(ach.b, x & 0xF, y, z & 0xF), chunk.a(ach.a, x & 0xF, y, z & 0xF), chunk.c(x & 0xF, y, z & 0xF, 0)));
            }
            else {
                left.add(null);
            }
            left.add(String.format("ws: %.3f, fs: %.3f, g: %b, fl: %d", this.g.h.bG.b(), this.g.h.bG.a(), this.g.h.F, this.g.f.f(x, z)));
            right.add(null);
            for (final String s : FMLCommonHandler.instance().getBrandings().subList(1, FMLCommonHandler.instance().getBrandings().size())) {
                right.add(s);
            }
            GL11.glPopMatrix();
            this.g.C.b();
        }
        final RenderGameOverlayEvent.Text event = new RenderGameOverlayEvent.Text(this.eventParent, left, right);
        if (!MinecraftForge.EVENT_BUS.post(event)) {
            for (int x2 = 0; x2 < left.size(); ++x2) {
                final String msg = left.get(x2);
                if (msg != null) {
                    this.fontrenderer.a(msg, 2, 2 + x2 * 10, 16777215);
                }
            }
            for (int x2 = 0; x2 < right.size(); ++x2) {
                final String msg = right.get(x2);
                if (msg != null) {
                    final int w = this.fontrenderer.a(msg);
                    this.fontrenderer.a(msg, width - w - 10, 2 + x2 * 10, 16777215);
                }
            }
        }
        this.g.C.b();
        this.post(RenderGameOverlayEvent.ElementType.TEXT);
    }
    
    protected void renderRecordOverlay(final int width, final int height, final float partialTicks) {
        if (this.o > 0) {
            this.g.C.a("overlayMessage");
            final float hue = this.o - partialTicks;
            int opacity = (int)(hue * 256.0f / 20.0f);
            if (opacity > 255) {
                opacity = 255;
            }
            if (opacity > 0) {
                GL11.glPushMatrix();
                GL11.glTranslatef((float)(width / 2), (float)(height - 48), 0.0f);
                GL11.glEnable(3042);
                GL11.glBlendFunc(770, 771);
                final int color = this.p ? (Color.HSBtoRGB(hue / 50.0f, 0.7f, 0.6f) & 0xFFFFFF) : 16777215;
                this.fontrenderer.b(this.j, -this.fontrenderer.a(this.j) / 2, -4, color | opacity << 24);
                GL11.glDisable(3042);
                GL11.glPopMatrix();
            }
            this.g.C.b();
        }
    }
    
    protected void renderChat(final int width, final int height) {
        this.g.C.a("chat");
        final RenderGameOverlayEvent.Chat event = new RenderGameOverlayEvent.Chat(this.eventParent, 0, height - 48);
        if (MinecraftForge.EVENT_BUS.post(event)) {
            return;
        }
        GL11.glPushMatrix();
        GL11.glTranslatef((float)event.posX, (float)event.posY, 0.0f);
        this.h.a(this.i);
        GL11.glPopMatrix();
        this.post(RenderGameOverlayEvent.ElementType.CHAT);
        this.g.C.b();
    }
    
    protected void renderPlayerList(final int width, final int height) {
        final ate scoreobjective = this.g.f.X().a(0);
        final bcw handler = this.g.h.a;
        if (this.g.u.T.e && (!this.g.A() || handler.c.size() > 1 || scoreobjective != null)) {
            if (this.pre(RenderGameOverlayEvent.ElementType.PLAYER_LIST)) {
                return;
            }
            this.g.C.a("playerList");
            final List players = handler.c;
            int rows;
            int maxPlayers;
            int columns;
            for (maxPlayers = (rows = handler.d), columns = 1, columns = 1; rows > 20; rows = (maxPlayers + columns - 1) / columns) {
                ++columns;
            }
            int columnWidth = 300 / columns;
            if (columnWidth > 150) {
                columnWidth = 150;
            }
            final int left = (width - columns * columnWidth) / 2;
            final byte border = 10;
            a(left - 1, border - 1, left + columnWidth * columns, border + 9 * rows, Integer.MIN_VALUE);
            for (int i = 0; i < maxPlayers; ++i) {
                final int xPos = left + i % columns * columnWidth;
                final int yPos = border + i / columns * 9;
                a(xPos, yPos, xPos + columnWidth - 1, yPos + 8, 553648127);
                GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
                GL11.glEnable(3008);
                if (i < players.size()) {
                    final bdj player = players.get(i);
                    final atf team = this.g.f.X().i(player.a);
                    final String displayName = atf.a((atl)team, player.a);
                    this.fontrenderer.a(displayName, xPos, yPos, 16777215);
                    if (scoreobjective != null) {
                        final int endX = xPos + this.fontrenderer.a(displayName) + 5;
                        final int maxX = xPos + columnWidth - 12 - 5;
                        if (maxX - endX > 5) {
                            final atg score = scoreobjective.a().a(player.a, scoreobjective);
                            final String scoreDisplay = a.o + "" + score.c();
                            this.fontrenderer.a(scoreDisplay, maxX - this.fontrenderer.a(scoreDisplay), yPos, 16777215);
                        }
                    }
                    GL11.glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
                    this.g.J().a(avk.m);
                    int pingIndex = 4;
                    final int ping = player.b;
                    if (ping < 0) {
                        pingIndex = 5;
                    }
                    else if (ping < 150) {
                        pingIndex = 0;
                    }
                    else if (ping < 300) {
                        pingIndex = 1;
                    }
                    else if (ping < 600) {
                        pingIndex = 2;
                    }
                    else if (ping < 1000) {
                        pingIndex = 3;
                    }
                    this.n += 100.0f;
                    this.b(xPos + columnWidth - 12, yPos, 0, 176 + pingIndex * 8, 10, 8);
                    this.n -= 100.0f;
                }
            }
            this.post(RenderGameOverlayEvent.ElementType.PLAYER_LIST);
        }
    }
    
    protected void renderHealthMount(final int width, final int height) {
        final nn tmp = this.g.h.o;
        if (!(tmp instanceof of)) {
            return;
        }
        this.bind(GuiIngameForge.m);
        if (this.pre(RenderGameOverlayEvent.ElementType.HEALTHMOUNT)) {
            return;
        }
        final boolean unused = false;
        final int left_align = width / 2 + 91;
        this.g.C.c("mountHealth");
        final of mount = (of)tmp;
        final int health = (int)Math.ceil(mount.aN());
        final float healthMax = mount.aT();
        int hearts = (int)(healthMax + 0.5f) / 2;
        if (hearts > 30) {
            hearts = 30;
        }
        final int MARGIN = 52;
        final int BACKGROUND = 52 + (unused ? 1 : 0);
        final int HALF = 97;
        final int FULL = 88;
        int heart = 0;
        while (hearts > 0) {
            final int top = height - GuiIngameForge.right_height;
            final int rowCount = Math.min(hearts, 10);
            hearts -= rowCount;
            for (int i = 0; i < rowCount; ++i) {
                final int x = left_align - i * 8 - 9;
                this.b(x, top, BACKGROUND, 9, 9, 9);
                if (i * 2 + 1 + heart < health) {
                    this.b(x, top, 88, 9, 9, 9);
                }
                else if (i * 2 + 1 + heart == health) {
                    this.b(x, top, 97, 9, 9, 9);
                }
            }
            GuiIngameForge.right_height += 10;
            heart += 20;
        }
        this.post(RenderGameOverlayEvent.ElementType.HEALTHMOUNT);
    }
    
    private boolean pre(final RenderGameOverlayEvent.ElementType type) {
        return MinecraftForge.EVENT_BUS.post(new RenderGameOverlayEvent.Pre(this.eventParent, type));
    }
    
    private void post(final RenderGameOverlayEvent.ElementType type) {
        MinecraftForge.EVENT_BUS.post(new RenderGameOverlayEvent.Post(this.eventParent, type));
    }
    
    private void bind(final bjo res) {
        this.g.J().a(res);
    }
    
    static {
        VIGNETTE = new bjo("textures/misc/vignette.png");
        WIDGITS = new bjo("textures/gui/widgets.png");
        PUMPKIN_BLUR = new bjo("textures/misc/pumpkinblur.png");
        GuiIngameForge.renderHelmet = true;
        GuiIngameForge.renderPortal = true;
        GuiIngameForge.renderHotbar = true;
        GuiIngameForge.renderCrosshairs = true;
        GuiIngameForge.renderBossHealth = true;
        GuiIngameForge.renderHealth = true;
        GuiIngameForge.renderArmor = true;
        GuiIngameForge.renderFood = true;
        GuiIngameForge.renderHealthMount = true;
        GuiIngameForge.renderAir = true;
        GuiIngameForge.renderExperiance = true;
        GuiIngameForge.renderJumpBar = true;
        GuiIngameForge.renderObjective = true;
        GuiIngameForge.left_height = 39;
        GuiIngameForge.right_height = 39;
        MC_VERSION = new c((b)null).a();
    }
}



================================================
FILE: net/minecraftforge/client/IItemRenderer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client;

public interface IItemRenderer
{
    boolean handleRenderType(final ye p0, final ItemRenderType p1);
    
    boolean shouldUseRenderHelper(final ItemRenderType p0, final ye p1, final ItemRendererHelper p2);
    
    void renderItem(final ItemRenderType p0, final ye p1, final Object... p2);
    
    public enum ItemRenderType
    {
        ENTITY, 
        EQUIPPED, 
        EQUIPPED_FIRST_PERSON, 
        INVENTORY, 
        FIRST_PERSON_MAP;
    }
    
    public enum ItemRendererHelper
    {
        ENTITY_ROTATION, 
        ENTITY_BOBBING, 
        EQUIPPED_BLOCK, 
        BLOCK_3D, 
        INVENTORY_BLOCK;
    }
}



================================================
FILE: net/minecraftforge/client/IRenderContextHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client;

public interface IRenderContextHandler
{
    void beforeRenderContext();
    
    void afterRenderContext();
}



================================================
FILE: net/minecraftforge/client/IRenderHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client;

import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;

public abstract class IRenderHandler
{
    @SideOnly(Side.CLIENT)
    public abstract void render(final float p0, final bdd p1, final atv p2);
}



================================================
FILE: net/minecraftforge/client/MinecraftForgeClient.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client;

import java.util.BitSet;

public class MinecraftForgeClient
{
    private static IItemRenderer[] customItemRenderers;
    private static BitSet stencilBits;
    
    public static void registerItemRenderer(final int itemID, final IItemRenderer renderer) {
        MinecraftForgeClient.customItemRenderers[itemID] = renderer;
    }
    
    public static IItemRenderer getItemRenderer(final ye item, final IItemRenderer.ItemRenderType type) {
        final IItemRenderer renderer = MinecraftForgeClient.customItemRenderers[item.d];
        if (renderer != null && renderer.handleRenderType(item, type)) {
            return MinecraftForgeClient.customItemRenderers[item.d];
        }
        return null;
    }
    
    public static int getRenderPass() {
        return ForgeHooksClient.renderPass;
    }
    
    public static int getStencilBits() {
        return ForgeHooksClient.stencilBits;
    }
    
    public static int reserveStencilBit() {
        final int bit = MinecraftForgeClient.stencilBits.nextSetBit(0);
        if (bit >= 0) {
            MinecraftForgeClient.stencilBits.clear(bit);
        }
        return bit;
    }
    
    public static void releaseStencilBit(final int bit) {
        if (bit >= 0 && bit < getStencilBits()) {
            MinecraftForgeClient.stencilBits.set(bit);
        }
    }
    
    static {
        MinecraftForgeClient.customItemRenderers = new IItemRenderer[yc.g.length];
        (MinecraftForgeClient.stencilBits = new BitSet(getStencilBits())).set(0, getStencilBits());
    }
}



================================================
FILE: net/minecraftforge/client/event/ClientChatReceivedEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event;

import net.minecraftforge.event.Cancelable;
import net.minecraftforge.event.Event;

@Cancelable
public class ClientChatReceivedEvent extends Event
{
    public String message;
    
    public ClientChatReceivedEvent(final String message) {
        this.message = message;
    }
}



================================================
FILE: net/minecraftforge/client/event/DrawBlockHighlightEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event;

import net.minecraftforge.event.Cancelable;
import net.minecraftforge.event.Event;

@Cancelable
public class DrawBlockHighlightEvent extends Event
{
    public final bfl context;
    public final uf player;
    public final ata target;
    public final int subID;
    public final ye currentItem;
    public final float partialTicks;
    
    public DrawBlockHighlightEvent(final bfl context, final uf player, final ata target, final int subID, final ye currentItem, final float partialTicks) {
        this.context = context;
        this.player = player;
        this.target = target;
        this.subID = subID;
        this.currentItem = currentItem;
        this.partialTicks = partialTicks;
    }
}



================================================
FILE: net/minecraftforge/client/event/FOVUpdateEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event;

import net.minecraftforge.event.Event;

public class FOVUpdateEvent extends Event
{
    public final bex entity;
    public final float fov;
    public float newfov;
    
    public FOVUpdateEvent(final bex entity, final float fov) {
        this.entity = entity;
        this.fov = fov;
        this.newfov = fov;
    }
}



================================================
FILE: net/minecraftforge/client/event/GuiOpenEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event;

import net.minecraftforge.event.Cancelable;
import net.minecraftforge.event.Event;

@Cancelable
public class GuiOpenEvent extends Event
{
    public awe gui;
    
    public GuiOpenEvent(final awe gui) {
        this.gui = gui;
    }
}



================================================
FILE: net/minecraftforge/client/event/MouseEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event;

import org.lwjgl.input.Mouse;
import net.minecraftforge.event.Cancelable;
import net.minecraftforge.event.Event;

@Cancelable
public class MouseEvent extends Event
{
    public final int x;
    public final int y;
    public final int dx;
    public final int dy;
    public final int dwheel;
    public final int button;
    public final boolean buttonstate;
    public final long nanoseconds;
    
    public MouseEvent() {
        this.x = Mouse.getEventX();
        this.y = Mouse.getEventY();
        this.dx = Mouse.getEventDX();
        this.dy = Mouse.getEventDY();
        this.dwheel = Mouse.getEventDWheel();
        this.button = Mouse.getEventButton();
        this.buttonstate = Mouse.getEventButtonState();
        this.nanoseconds = Mouse.getEventNanoseconds();
    }
}



================================================
FILE: net/minecraftforge/client/event/RenderGameOverlayEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event;

import java.util.ArrayList;
import net.minecraftforge.event.Cancelable;
import net.minecraftforge.event.Event;

@Cancelable
public class RenderGameOverlayEvent extends Event
{
    public final float partialTicks;
    public final awf resolution;
    public final int mouseX;
    public final int mouseY;
    public final ElementType type;
    
    public RenderGameOverlayEvent(final float partialTicks, final awf resolution, final int mouseX, final int mouseY) {
        this.partialTicks = partialTicks;
        this.resolution = resolution;
        this.mouseX = mouseX;
        this.mouseY = mouseY;
        this.type = null;
    }
    
    private RenderGameOverlayEvent(final RenderGameOverlayEvent parent, final ElementType type) {
        this.partialTicks = parent.partialTicks;
        this.resolution = parent.resolution;
        this.mouseX = parent.mouseX;
        this.mouseY = parent.mouseY;
        this.type = type;
    }
    
    public enum ElementType
    {
        ALL, 
        HELMET, 
        PORTAL, 
        CROSSHAIRS, 
        BOSSHEALTH, 
        ARMOR, 
        HEALTH, 
        FOOD, 
        AIR, 
        HOTBAR, 
        EXPERIENCE, 
        TEXT, 
        HEALTHMOUNT, 
        JUMPBAR, 
        CHAT, 
        PLAYER_LIST;
    }
    
    public static class Pre extends RenderGameOverlayEvent
    {
        public Pre(final RenderGameOverlayEvent parent, final ElementType type) {
            super(parent, type, null);
        }
    }
    
    public static class Post extends RenderGameOverlayEvent
    {
        public Post(final RenderGameOverlayEvent parent, final ElementType type) {
            super(parent, type, null);
        }
        
        @Override
        public boolean isCancelable() {
            return false;
        }
    }
    
    public static class Text extends Pre
    {
        public final ArrayList<String> left;
        public final ArrayList<String> right;
        
        public Text(final RenderGameOverlayEvent parent, final ArrayList<String> left, final ArrayList<String> right) {
            super(parent, ElementType.TEXT);
            this.left = left;
            this.right = right;
        }
    }
    
    public static class Chat extends Pre
    {
        public int posX;
        public int posY;
        
        public Chat(final RenderGameOverlayEvent parent, final int posX, final int posY) {
            super(parent, ElementType.CHAT);
            this.posX = posX;
            this.posY = posY;
        }
    }
}



================================================
FILE: net/minecraftforge/client/event/RenderLivingEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event;

import net.minecraftforge.event.Cancelable;
import net.minecraftforge.event.Event;

public abstract class RenderLivingEvent extends Event
{
    public final of entity;
    public final bhb renderer;
    
    public RenderLivingEvent(final of entity, final bhb renderer) {
        this.entity = entity;
        this.renderer = renderer;
    }
    
    @Cancelable
    public static class Pre extends RenderLivingEvent
    {
        public Pre(final of entity, final bhb renderer) {
            super(entity, renderer);
        }
    }
    
    public static class Post extends RenderLivingEvent
    {
        public Post(final of entity, final bhb renderer) {
            super(entity, renderer);
        }
    }
    
    public abstract static class Specials extends RenderLivingEvent
    {
        public Specials(final of entity, final bhb renderer) {
            super(entity, renderer);
        }
        
        @Cancelable
        public static class Pre extends Specials
        {
            public Pre(final of entity, final bhb renderer) {
                super(entity, renderer);
            }
        }
        
        public static class Post extends Specials
        {
            public Post(final of entity, final bhb renderer) {
                super(entity, renderer);
            }
        }
    }
}



================================================
FILE: net/minecraftforge/client/event/RenderPlayerEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event;

import net.minecraftforge.event.Cancelable;
import net.minecraftforge.event.entity.player.PlayerEvent;

public abstract class RenderPlayerEvent extends PlayerEvent
{
    public final bhj renderer;
    public final float partialRenderTick;
    
    public RenderPlayerEvent(final uf player, final bhj renderer, final float partialRenderTick) {
        super(player);
        this.renderer = renderer;
        this.partialRenderTick = partialRenderTick;
    }
    
    @Cancelable
    public static class Pre extends RenderPlayerEvent
    {
        public Pre(final uf player, final bhj renderer, final float tick) {
            super(player, renderer, tick);
        }
    }
    
    public static class Post extends RenderPlayerEvent
    {
        public Post(final uf player, final bhj renderer, final float tick) {
            super(player, renderer, tick);
        }
    }
    
    public abstract static class Specials extends RenderPlayerEvent
    {
        @Deprecated
        public final float partialTicks;
        
        public Specials(final uf player, final bhj renderer, final float partialTicks) {
            super(player, renderer, partialTicks);
            this.partialTicks = partialTicks;
        }
        
        @Cancelable
        public static class Pre extends Specials
        {
            public boolean renderHelmet;
            public boolean renderCape;
            public boolean renderItem;
            
            public Pre(final uf player, final bhj renderer, final float partialTicks) {
                super(player, renderer, partialTicks);
                this.renderHelmet = true;
                this.renderCape = true;
                this.renderItem = true;
            }
        }
        
        public static class Post extends Specials
        {
            public Post(final uf player, final bhj renderer, final float partialTicks) {
                super(player, renderer, partialTicks);
            }
        }
    }
    
    public static class SetArmorModel extends RenderPlayerEvent
    {
        public int result;
        public final int slot;
        @Deprecated
        public final float partialTick;
        public final ye stack;
        
        public SetArmorModel(final uf player, final bhj renderer, final int slot, final float partialTick, final ye stack) {
            super(player, renderer, partialTick);
            this.result = -1;
            this.slot = slot;
            this.partialTick = partialTick;
            this.stack = stack;
        }
    }
}



================================================
FILE: net/minecraftforge/client/event/RenderWorldLastEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event;

import net.minecraftforge.event.Event;

public class RenderWorldLastEvent extends Event
{
    public final bfl context;
    public final float partialTicks;
    
    public RenderWorldLastEvent(final bfl context, final float partialTicks) {
        this.context = context;
        this.partialTicks = partialTicks;
    }
}



================================================
FILE: net/minecraftforge/client/event/TextureStitchEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event;

import net.minecraftforge.event.Event;

public class TextureStitchEvent extends Event
{
    public final bik map;
    
    public TextureStitchEvent(final bik map) {
        this.map = map;
    }
    
    public static class Pre extends TextureStitchEvent
    {
        public Pre(final bik map) {
            super(map);
        }
    }
    
    public static class Post extends TextureStitchEvent
    {
        public Post(final bik map) {
            super(map);
        }
    }
}



================================================
FILE: net/minecraftforge/client/event/sound/PlayBackgroundMusicEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event.sound;

public class PlayBackgroundMusicEvent extends SoundResultEvent
{
    public PlayBackgroundMusicEvent(final bln manager, final blm entry) {
        super(manager, entry, null, 0.0f, 0.0f);
    }
}



================================================
FILE: net/minecraftforge/client/event/sound/PlaySoundEffectEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event.sound;

public class PlaySoundEffectEvent extends SoundResultEvent
{
    public PlaySoundEffectEvent(final bln manager, final blm source, final String name, final float volume, final float pitch) {
        super(manager, source, name, volume, pitch);
    }
}



================================================
FILE: net/minecraftforge/client/event/sound/PlaySoundEffectSourceEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event.sound;

public class PlaySoundEffectSourceEvent extends SoundEvent
{
    public final bln manager;
    public final String name;
    
    public PlaySoundEffectSourceEvent(final bln manager, final String name) {
        this.manager = manager;
        this.name = name;
    }
}



================================================
FILE: net/minecraftforge/client/event/sound/PlaySoundEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event.sound;

public class PlaySoundEvent extends SoundResultEvent
{
    public final float x;
    public final float y;
    public final float z;
    
    public PlaySoundEvent(final bln manager, final blm source, final String name, final float x, final float y, final float z, final float volume, final float pitch) {
        super(manager, source, name, volume, pitch);
        this.x = x;
        this.y = y;
        this.z = z;
    }
}



================================================
FILE: net/minecraftforge/client/event/sound/PlaySoundSourceEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event.sound;

public class PlaySoundSourceEvent extends SoundEvent
{
    public final bln manager;
    public final String name;
    public final float x;
    public final float y;
    public final float z;
    
    public PlaySoundSourceEvent(final bln manager, final String name, final float x, final float y, final float z) {
        this.manager = manager;
        this.name = name;
        this.x = x;
        this.y = y;
        this.z = z;
    }
}



================================================
FILE: net/minecraftforge/client/event/sound/PlayStreamingEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event.sound;

public class PlayStreamingEvent extends SoundResultEvent
{
    public final float x;
    public final float y;
    public final float z;
    
    public PlayStreamingEvent(final bln manager, final blm source, final String name, final float x, final float y, final float z) {
        super(manager, source, name, 0.0f, 0.0f);
        this.x = x;
        this.y = y;
        this.z = z;
    }
}



================================================
FILE: net/minecraftforge/client/event/sound/PlayStreamingSourceEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event.sound;

public class PlayStreamingSourceEvent extends SoundEvent
{
    public final bln manager;
    public final String name;
    public final float x;
    public final float y;
    public final float z;
    
    public PlayStreamingSourceEvent(final bln manager, final String name, final float x, final float y, final float z) {
        this.manager = manager;
        this.name = name;
        this.x = x;
        this.y = y;
        this.z = z;
    }
}



================================================
FILE: net/minecraftforge/client/event/sound/SoundEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event.sound;

import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.event.Event;

public class SoundEvent extends Event
{
    public static blm getResult(final SoundResultEvent event) {
        MinecraftForge.EVENT_BUS.post(event);
        return event.result;
    }
}



================================================
FILE: net/minecraftforge/client/event/sound/SoundLoadEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event.sound;

public class SoundLoadEvent extends SoundEvent
{
    public final bln manager;
    
    public SoundLoadEvent(final bln manager) {
        this.manager = manager;
    }
}



================================================
FILE: net/minecraftforge/client/event/sound/SoundResultEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event.sound;

public abstract class SoundResultEvent extends SoundEvent
{
    public final bln manager;
    public final blm source;
    public final String name;
    public final float volume;
    public final float pitch;
    public blm result;
    
    public SoundResultEvent(final bln manager, final blm source, final String name, final float volume, final float pitch) {
        this.manager = manager;
        this.source = source;
        this.name = name;
        this.volume = volume;
        this.pitch = pitch;
        this.result = source;
    }
}



================================================
FILE: net/minecraftforge/client/event/sound/SoundSetupEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.event.sound;

public class SoundSetupEvent extends SoundEvent
{
    public final bln manager;
    
    public SoundSetupEvent(final bln manager) {
        this.manager = manager;
    }
}



================================================
FILE: net/minecraftforge/client/model/AdvancedModelLoader.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.model;

import net.minecraftforge.client.model.techne.TechneModelLoader;
import net.minecraftforge.client.model.obj.ObjModelLoader;
import com.google.common.collect.Maps;
import java.util.Collection;
import java.net.URL;
import cpw.mods.fml.common.FMLLog;
import java.util.Map;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class AdvancedModelLoader
{
    private static Map<String, IModelCustomLoader> instances;
    
    public static void registerModelHandler(final IModelCustomLoader modelHandler) {
        for (final String suffix : modelHandler.getSuffixes()) {
            AdvancedModelLoader.instances.put(suffix, modelHandler);
        }
    }
    
    public static IModelCustom loadModel(final String resourceName) throws IllegalArgumentException, ModelFormatException {
        final int i = resourceName.lastIndexOf(46);
        if (i == -1) {
            FMLLog.severe("The resource name %s is not valid", resourceName);
            throw new IllegalArgumentException("The resource name is not valid");
        }
        final String suffix = resourceName.substring(i + 1);
        final IModelCustomLoader loader = AdvancedModelLoader.instances.get(suffix);
        if (loader == null) {
            FMLLog.severe("The resource name %s is not supported", resourceName);
            throw new IllegalArgumentException("The resource name is not supported");
        }
        final URL resource = AdvancedModelLoader.class.getResource(resourceName);
        if (resource == null) {
            FMLLog.severe("The resource name %s could not be found", resourceName);
            throw new IllegalArgumentException("The resource name could not be found");
        }
        return loader.loadInstance(resourceName, resource);
    }
    
    public static Collection<String> getSupportedSuffixes() {
        return AdvancedModelLoader.instances.keySet();
    }
    
    static {
        AdvancedModelLoader.instances = Maps.newHashMap();
        registerModelHandler(new ObjModelLoader());
        registerModelHandler(new TechneModelLoader());
    }
}



================================================
FILE: net/minecraftforge/client/model/IModelCustom.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.model;

public interface IModelCustom
{
    String getType();
    
    void renderAll();
    
    void renderOnly(final String... p0);
    
    void renderPart(final String p0);
    
    void renderAllExcept(final String... p0);
}



================================================
FILE: net/minecraftforge/client/model/IModelCustomLoader.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.model;

import java.net.URL;

public interface IModelCustomLoader
{
    String getType();
    
    String[] getSuffixes();
    
    IModelCustom loadInstance(final String p0, final URL p1) throws ModelFormatException;
}



================================================
FILE: net/minecraftforge/client/model/ModelFormatException.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.model;

public class ModelFormatException extends RuntimeException
{
    public ModelFormatException() {
    }
    
    public ModelFormatException(final String message, final Throwable cause) {
        super(message, cause);
    }
    
    public ModelFormatException(final String message) {
        super(message);
    }
    
    public ModelFormatException(final Throwable cause) {
        super(cause);
    }
}



================================================
FILE: net/minecraftforge/client/model/obj/Face.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.model.obj;

import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class Face
{
    public Vertex[] vertices;
    public Vertex[] vertexNormals;
    public Vertex faceNormal;
    public TextureCoordinate[] textureCoordinates;
    
    public void addFaceForRender(final bfq tessellator) {
        this.addFaceForRender(tessellator, 5.0E-4f);
    }
    
    public void addFaceForRender(final bfq tessellator, final float textureOffset) {
        if (this.faceNormal == null) {
            this.faceNormal = this.calculateFaceNormal();
        }
        tessellator.b(this.faceNormal.x, this.faceNormal.y, this.faceNormal.z);
        float averageU = 0.0f;
        float averageV = 0.0f;
        if (this.textureCoordinates != null && this.textureCoordinates.length > 0) {
            for (int i = 0; i < this.textureCoordinates.length; ++i) {
                averageU += this.textureCoordinates[i].u;
                averageV += this.textureCoordinates[i].v;
            }
            averageU /= this.textureCoordinates.length;
            averageV /= this.textureCoordinates.length;
        }
        for (int j = 0; j < this.vertices.length; ++j) {
            if (this.textureCoordinates != null && this.textureCoordinates.length > 0) {
                float offsetU = textureOffset;
                float offsetV = textureOffset;
                if (this.textureCoordinates[j].u > averageU) {
                    offsetU = -offsetU;
                }
                if (this.textureCoordinates[j].v > averageV) {
                    offsetV = -offsetV;
                }
                tessellator.a((double)this.vertices[j].x, (double)this.vertices[j].y, (double)this.vertices[j].z, (double)(this.textureCoordinates[j].u + offsetU), (double)(this.textureCoordinates[j].v + offsetV));
            }
            else {
                tessellator.a((double)this.vertices[j].x, (double)this.vertices[j].y, (double)this.vertices[j].z);
            }
        }
    }
    
    public Vertex calculateFaceNormal() {
        final atc v1 = atc.a((double)(this.vertices[1].x - this.vertices[0].x), (double)(this.vertices[1].y - this.vertices[0].y), (double)(this.vertices[1].z - this.vertices[0].z));
        final atc v2 = atc.a((double)(this.vertices[2].x - this.vertices[0].x), (double)(this.vertices[2].y - this.vertices[0].y), (double)(this.vertices[2].z - this.vertices[0].z));
        atc normalVector = null;
        normalVector = v1.c(v2).a();
        return new Vertex((float)normalVector.c, (float)normalVector.d, (float)normalVector.e);
    }
}



================================================
FILE: net/minecraftforge/client/model/obj/GroupObject.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.model.obj;

import java.util.Iterator;
import java.util.ArrayList;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class GroupObject
{
    public String name;
    public ArrayList<Face> faces;
    public int glDrawingMode;
    
    public GroupObject() {
        this("");
    }
    
    public GroupObject(final String name) {
        this(name, -1);
    }
    
    public GroupObject(final String name, final int glDrawingMode) {
        this.faces = new ArrayList<Face>();
        this.name = name;
        this.glDrawingMode = glDrawingMode;
    }
    
    public void render() {
        if (this.faces.size() > 0) {
            final bfq tessellator = bfq.a;
            tessellator.b(this.glDrawingMode);
            this.render(tessellator);
            tessellator.a();
        }
    }
    
    public void render(final bfq tessellator) {
        if (this.faces.size() > 0) {
            for (final Face face : this.faces) {
                face.addFaceForRender(tessellator);
            }
        }
    }
}



================================================
FILE: net/minecraftforge/client/model/obj/ObjModelLoader.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.model.obj;

import net.minecraftforge.client.model.ModelFormatException;
import net.minecraftforge.client.model.IModelCustom;
import java.net.URL;
import net.minecraftforge.client.model.IModelCustomLoader;

public class ObjModelLoader implements IModelCustomLoader
{
    private static final String[] types;
    
    @Override
    public String getType() {
        return "OBJ model";
    }
    
    @Override
    public String[] getSuffixes() {
        return ObjModelLoader.types;
    }
    
    @Override
    public IModelCustom loadInstance(final String resourceName, final URL resource) throws ModelFormatException {
        return new WavefrontObject(resourceName, resource);
    }
    
    static {
        types = new String[] { "obj" };
    }
}



================================================
FILE: net/minecraftforge/client/model/obj/TextureCoordinate.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.model.obj;

import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class TextureCoordinate
{
    public float u;
    public float v;
    public float w;
    
    public TextureCoordinate(final float u, final float v) {
        this(u, v, 0.0f);
    }
    
    public TextureCoordinate(final float u, final float v, final float w) {
        this.u = u;
        this.v = v;
        this.w = w;
    }
}



================================================
FILE: net/minecraftforge/client/model/obj/Vertex.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.model.obj;

import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class Vertex
{
    public float x;
    public float y;
    public float z;
    
    public Vertex(final float x, final float y) {
        this(x, y, 0.0f);
    }
    
    public Vertex(final float x, final float y, final float z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
}



================================================
FILE: net/minecraftforge/client/model/obj/WavefrontObject.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.model.obj;

import java.util.Iterator;
import java.io.Reader;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.InputStream;
import java.io.IOException;
import net.minecraftforge.client.model.ModelFormatException;
import java.net.URL;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;
import net.minecraftforge.client.model.IModelCustom;

@SideOnly(Side.CLIENT)
public class WavefrontObject implements IModelCustom
{
    private static Pattern vertexPattern;
    private static Pattern vertexNormalPattern;
    private static Pattern textureCoordinatePattern;
    private static Pattern face_V_VT_VN_Pattern;
    private static Pattern face_V_VT_Pattern;
    private static Pattern face_V_VN_Pattern;
    private static Pattern face_V_Pattern;
    private static Pattern groupObjectPattern;
    private static Matcher vertexMatcher;
    private static Matcher vertexNormalMatcher;
    private static Matcher textureCoordinateMatcher;
    private static Matcher face_V_VT_VN_Matcher;
    private static Matcher face_V_VT_Matcher;
    private static Matcher face_V_VN_Matcher;
    private static Matcher face_V_Matcher;
    private static Matcher groupObjectMatcher;
    public ArrayList<Vertex> vertices;
    public ArrayList<Vertex> vertexNormals;
    public ArrayList<TextureCoordinate> textureCoordinates;
    public ArrayList<GroupObject> groupObjects;
    private GroupObject currentGroupObject;
    private String fileName;
    
    public WavefrontObject(final String fileName, final URL resource) throws ModelFormatException {
        this.vertices = new ArrayList<Vertex>();
        this.vertexNormals = new ArrayList<Vertex>();
        this.textureCoordinates = new ArrayList<TextureCoordinate>();
        this.groupObjects = new ArrayList<GroupObject>();
        this.fileName = fileName;
        try {
            this.loadObjModel(resource.openStream());
        }
        catch (final IOException e) {
            throw new ModelFormatException("IO Exception reading model format", e);
        }
    }
    
    public WavefrontObject(final String filename, final InputStream inputStream) throws ModelFormatException {
        this.vertices = new ArrayList<Vertex>();
        this.vertexNormals = new ArrayList<Vertex>();
        this.textureCoordinates = new ArrayList<TextureCoordinate>();
        this.groupObjects = new ArrayList<GroupObject>();
        this.fileName = filename;
        this.loadObjModel(inputStream);
    }
    
    private void loadObjModel(final InputStream inputStream) throws ModelFormatException {
        BufferedReader reader = null;
        String currentLine = null;
        int lineCount = 0;
        try {
            reader = new BufferedReader(new InputStreamReader(inputStream));
            while ((currentLine = reader.readLine()) != null) {
                ++lineCount;
                currentLine = currentLine.replaceAll("\\s+", " ").trim();
                if (!currentLine.startsWith("#")) {
                    if (currentLine.length() == 0) {
                        continue;
                    }
                    if (currentLine.startsWith("v ")) {
                        final Vertex vertex = this.parseVertex(currentLine, lineCount);
                        if (vertex == null) {
                            continue;
                        }
                        this.vertices.add(vertex);
                    }
                    else if (currentLine.startsWith("vn ")) {
                        final Vertex vertex = this.parseVertexNormal(currentLine, lineCount);
                        if (vertex == null) {
                            continue;
                        }
                        this.vertexNormals.add(vertex);
                    }
                    else if (currentLine.startsWith("vt ")) {
                        final TextureCoordinate textureCoordinate = this.parseTextureCoordinate(currentLine, lineCount);
                        if (textureCoordinate == null) {
                            continue;
                        }
                        this.textureCoordinates.add(textureCoordinate);
                    }
                    else if (currentLine.startsWith("f ")) {
                        if (this.currentGroupObject == null) {
                            this.currentGroupObject = new GroupObject("Default");
                        }
                        final Face face = this.parseFace(currentLine, lineCount);
                        if (face == null) {
                            continue;
                        }
                        this.currentGroupObject.faces.add(face);
                    }
                    else {
                        if (!(currentLine.startsWith("g ") | currentLine.startsWith("o "))) {
                            continue;
                        }
                        final GroupObject group = this.parseGroupObject(currentLine, lineCount);
                        if (group != null && this.currentGroupObject != null) {
                            this.groupObjects.add(this.currentGroupObject);
                        }
                        this.currentGroupObject = group;
                    }
                }
            }
            this.groupObjects.add(this.currentGroupObject);
        }
        catch (final IOException e) {
            throw new ModelFormatException("IO Exception reading model format", e);
        }
        finally {
            try {
                reader.close();
            }
            catch (final IOException ex) {}
            try {
                inputStream.close();
            }
            catch (final IOException ex2) {}
        }
    }
    
    @Override
    public void renderAll() {
        final bfq tessellator = bfq.a;
        if (this.currentGroupObject != null) {
            tessellator.b(this.currentGroupObject.glDrawingMode);
        }
        else {
            tessellator.b(4);
        }
        this.tessellateAll(tessellator);
        tessellator.a();
    }
    
    public void tessellateAll(final bfq tessellator) {
        for (final GroupObject groupObject : this.groupObjects) {
            groupObject.render(tessellator);
        }
    }
    
    @Override
    public void renderOnly(final String... groupNames) {
        for (final GroupObject groupObject : this.groupObjects) {
            for (final String groupName : groupNames) {
                if (groupName.equalsIgnoreCase(groupObject.name)) {
                    groupObject.render();
                }
            }
        }
    }
    
    public void tessellateOnly(final bfq tessellator, final String... groupNames) {
        for (final GroupObject groupObject : this.groupObjects) {
            for (final String groupName : groupNames) {
                if (groupName.equalsIgnoreCase(groupObject.name)) {
                    groupObject.render(tessellator);
                }
            }
        }
    }
    
    @Override
    public void renderPart(final String partName) {
        for (final GroupObject groupObject : this.groupObjects) {
            if (partName.equalsIgnoreCase(groupObject.name)) {
                groupObject.render();
            }
        }
    }
    
    public void tessellatePart(final bfq tessellator, final String partName) {
        for (final GroupObject groupObject : this.groupObjects) {
            if (partName.equalsIgnoreCase(groupObject.name)) {
                groupObject.render(tessellator);
            }
        }
    }
    
    @Override
    public void renderAllExcept(final String... excludedGroupNames) {
        for (final GroupObject groupObject : this.groupObjects) {
            boolean skipPart = false;
            for (final String excludedGroupName : excludedGroupNames) {
                if (excludedGroupName.equalsIgnoreCase(groupObject.name)) {
                    skipPart = true;
                }
            }
            if (!skipPart) {
                groupObject.render();
            }
        }
    }
    
    public void tessellateAllExcept(final bfq tessellator, final String... excludedGroupNames) {
        for (final GroupObject groupObject : this.groupObjects) {
            boolean exclude = false;
            for (final String excludedGroupName : excludedGroupNames) {
                if (excludedGroupName.equalsIgnoreCase(groupObject.name)) {
                    exclude = true;
                }
            }
            if (!exclude) {
                groupObject.render(tessellator);
            }
        }
    }
    
    private Vertex parseVertex(String line, final int lineCount) throws ModelFormatException {
        final Vertex vertex = null;
        if (isValidVertexLine(line)) {
            line = line.substring(line.indexOf(" ") + 1);
            final String[] tokens = line.split(" ");
            try {
                if (tokens.length == 2) {
                    return new Vertex(Float.parseFloat(tokens[0]), Float.parseFloat(tokens[1]));
                }
                if (tokens.length == 3) {
                    return new Vertex(Float.parseFloat(tokens[0]), Float.parseFloat(tokens[1]), Float.parseFloat(tokens[2]));
                }
            }
            catch (final NumberFormatException e) {
                throw new ModelFormatException(String.format("Number formatting error at line %d", lineCount), e);
            }
            return vertex;
        }
        throw new ModelFormatException("Error parsing entry ('" + line + "'" + ", line " + lineCount + ") in file '" + this.fileName + "' - Incorrect format");
    }
    
    private Vertex parseVertexNormal(String line, final int lineCount) throws ModelFormatException {
        final Vertex vertexNormal = null;
        if (isValidVertexNormalLine(line)) {
            line = line.substring(line.indexOf(" ") + 1);
            final String[] tokens = line.split(" ");
            try {
                if (tokens.length == 3) {
                    return new Vertex(Float.parseFloat(tokens[0]), Float.parseFloat(tokens[1]), Float.parseFloat(tokens[2]));
                }
            }
            catch (final NumberFormatException e) {
                throw new ModelFormatException(String.format("Number formatting error at line %d", lineCount), e);
            }
            return vertexNormal;
        }
        throw new ModelFormatException("Error parsing entry ('" + line + "'" + ", line " + lineCount + ") in file '" + this.fileName + "' - Incorrect format");
    }
    
    private TextureCoordinate parseTextureCoordinate(String line, final int lineCount) throws ModelFormatException {
        final TextureCoordinate textureCoordinate = null;
        if (isValidTextureCoordinateLine(line)) {
            line = line.substring(line.indexOf(" ") + 1);
            final String[] tokens = line.split(" ");
            try {
                if (tokens.length == 2) {
                    return new TextureCoordinate(Float.parseFloat(tokens[0]), 1.0f - Float.parseFloat(tokens[1]));
                }
                if (tokens.length == 3) {
                    return new TextureCoordinate(Float.parseFloat(tokens[0]), 1.0f - Float.parseFloat(tokens[1]), Float.parseFloat(tokens[2]));
                }
            }
            catch (final NumberFormatException e) {
                throw new ModelFormatException(String.format("Number formatting error at line %d", lineCount), e);
            }
            return textureCoordinate;
        }
        throw new ModelFormatException("Error parsing entry ('" + line + "'" + ", line " + lineCount + ") in file '" + this.fileName + "' - Incorrect format");
    }
    
    private Face parseFace(final String line, final int lineCount) throws ModelFormatException {
        Face face = null;
        if (isValidFaceLine(line)) {
            face = new Face();
            final String trimmedLine = line.substring(line.indexOf(" ") + 1);
            final String[] tokens = trimmedLine.split(" ");
            String[] subTokens = null;
            if (tokens.length == 3) {
                if (this.currentGroupObject.glDrawingMode == -1) {
                    this.currentGroupObject.glDrawingMode = 4;
                }
                else if (this.currentGroupObject.glDrawingMode != 4) {
                    throw new ModelFormatException("Error parsing entry ('" + line + "'" + ", line " + lineCount + ") in file '" + this.fileName + "' - Invalid number of points for face (expected 4, found " + tokens.length + ")");
                }
            }
            else if (tokens.length == 4) {
                if (this.currentGroupObject.glDrawingMode == -1) {
                    this.currentGroupObject.glDrawingMode = 7;
                }
                else if (this.currentGroupObject.glDrawingMode != 7) {
                    throw new ModelFormatException("Error parsing entry ('" + line + "'" + ", line " + lineCount + ") in file '" + this.fileName + "' - Invalid number of points for face (expected 3, found " + tokens.length + ")");
                }
            }
            if (isValidFace_V_VT_VN_Line(line)) {
                face.vertices = new Vertex[tokens.length];
                face.textureCoordinates = new TextureCoordinate[tokens.length];
                face.vertexNormals = new Vertex[tokens.length];
                for (int i = 0; i < tokens.length; ++i) {
                    subTokens = tokens[i].split("/");
                    face.vertices[i] = this.vertices.get(Integer.parseInt(subTokens[0]) - 1);
                    face.textureCoordinates[i] = this.textureCoordinates.get(Integer.parseInt(subTokens[1]) - 1);
                    face.vertexNormals[i] = this.vertexNormals.get(Integer.parseInt(subTokens[2]) - 1);
                }
                face.faceNormal = face.calculateFaceNormal();
            }
            else if (isValidFace_V_VT_Line(line)) {
                face.vertices = new Vertex[tokens.length];
                face.textureCoordinates = new TextureCoordinate[tokens.length];
                for (int i = 0; i < tokens.length; ++i) {
                    subTokens = tokens[i].split("/");
                    face.vertices[i] = this.vertices.get(Integer.parseInt(subTokens[0]) - 1);
                    face.textureCoordinates[i] = this.textureCoordinates.get(Integer.parseInt(subTokens[1]) - 1);
                }
                face.faceNormal = face.calculateFaceNormal();
            }
            else if (isValidFace_V_VN_Line(line)) {
                face.vertices = new Vertex[tokens.length];
                face.vertexNormals = new Vertex[tokens.length];
                for (int i = 0; i < tokens.length; ++i) {
                    subTokens = tokens[i].split("//");
                    face.vertices[i] = this.vertices.get(Integer.parseInt(subTokens[0]) - 1);
                    face.vertexNormals[i] = this.vertexNormals.get(Integer.parseInt(subTokens[1]) - 1);
                }
                face.faceNormal = face.calculateFaceNormal();
            }
            else {
                if (!isValidFace_V_Line(line)) {
                    throw new ModelFormatException("Error parsing entry ('" + line + "'" + ", line " + lineCount + ") in file '" + this.fileName + "' - Incorrect format");
                }
                face.vertices = new Vertex[tokens.length];
                for (int i = 0; i < tokens.length; ++i) {
                    face.vertices[i] = this.vertices.get(Integer.parseInt(tokens[i]) - 1);
                }
                face.faceNormal = face.calculateFaceNormal();
            }
            return face;
        }
        throw new ModelFormatException("Error parsing entry ('" + line + "'" + ", line " + lineCount + ") in file '" + this.fileName + "' - Incorrect format");
    }
    
    private GroupObject parseGroupObject(final String line, final int lineCount) throws ModelFormatException {
        GroupObject group = null;
        if (isValidGroupObjectLine(line)) {
            final String trimmedLine = line.substring(line.indexOf(" ") + 1);
            if (trimmedLine.length() > 0) {
                group = new GroupObject(trimmedLine);
            }
            return group;
        }
        throw new ModelFormatException("Error parsing entry ('" + line + "'" + ", line " + lineCount + ") in file '" + this.fileName + "' - Incorrect format");
    }
    
    private static boolean isValidVertexLine(final String line) {
        if (WavefrontObject.vertexMatcher != null) {
            WavefrontObject.vertexMatcher.reset();
        }
        WavefrontObject.vertexMatcher = WavefrontObject.vertexPattern.matcher(line);
        return WavefrontObject.vertexMatcher.matches();
    }
    
    private static boolean isValidVertexNormalLine(final String line) {
        if (WavefrontObject.vertexNormalMatcher != null) {
            WavefrontObject.vertexNormalMatcher.reset();
        }
        WavefrontObject.vertexNormalMatcher = WavefrontObject.vertexNormalPattern.matcher(line);
        return WavefrontObject.vertexNormalMatcher.matches();
    }
    
    private static boolean isValidTextureCoordinateLine(final String line) {
        if (WavefrontObject.textureCoordinateMatcher != null) {
            WavefrontObject.textureCoordinateMatcher.reset();
        }
        WavefrontObject.textureCoordinateMatcher = WavefrontObject.textureCoordinatePattern.matcher(line);
        return WavefrontObject.textureCoordinateMatcher.matches();
    }
    
    private static boolean isValidFace_V_VT_VN_Line(final String line) {
        if (WavefrontObject.face_V_VT_VN_Matcher != null) {
            WavefrontObject.face_V_VT_VN_Matcher.reset();
        }
        WavefrontObject.face_V_VT_VN_Matcher = WavefrontObject.face_V_VT_VN_Pattern.matcher(line);
        return WavefrontObject.face_V_VT_VN_Matcher.matches();
    }
    
    private static boolean isValidFace_V_VT_Line(final String line) {
        if (WavefrontObject.face_V_VT_Matcher != null) {
            WavefrontObject.face_V_VT_Matcher.reset();
        }
        WavefrontObject.face_V_VT_Matcher = WavefrontObject.face_V_VT_Pattern.matcher(line);
        return WavefrontObject.face_V_VT_Matcher.matches();
    }
    
    private static boolean isValidFace_V_VN_Line(final String line) {
        if (WavefrontObject.face_V_VN_Matcher != null) {
            WavefrontObject.face_V_VN_Matcher.reset();
        }
        WavefrontObject.face_V_VN_Matcher = WavefrontObject.face_V_VN_Pattern.matcher(line);
        return WavefrontObject.face_V_VN_Matcher.matches();
    }
    
    private static boolean isValidFace_V_Line(final String line) {
        if (WavefrontObject.face_V_Matcher != null) {
            WavefrontObject.face_V_Matcher.reset();
        }
        WavefrontObject.face_V_Matcher = WavefrontObject.face_V_Pattern.matcher(line);
        return WavefrontObject.face_V_Matcher.matches();
    }
    
    private static boolean isValidFaceLine(final String line) {
        return isValidFace_V_VT_VN_Line(line) || isValidFace_V_VT_Line(line) || isValidFace_V_VN_Line(line) || isValidFace_V_Line(line);
    }
    
    private static boolean isValidGroupObjectLine(final String line) {
        if (WavefrontObject.groupObjectMatcher != null) {
            WavefrontObject.groupObjectMatcher.reset();
        }
        WavefrontObject.groupObjectMatcher = WavefrontObject.groupObjectPattern.matcher(line);
        return WavefrontObject.groupObjectMatcher.matches();
    }
    
    @Override
    public String getType() {
        return "obj";
    }
    
    static {
        WavefrontObject.vertexPattern = Pattern.compile("(v( (\\-){0,1}\\d+\\.\\d+){3,4} *\\n)|(v( (\\-){0,1}\\d+\\.\\d+){3,4} *$)");
        WavefrontObject.vertexNormalPattern = Pattern.compile("(vn( (\\-){0,1}\\d+\\.\\d+){3,4} *\\n)|(vn( (\\-){0,1}\\d+\\.\\d+){3,4} *$)");
        WavefrontObject.textureCoordinatePattern = Pattern.compile("(vt( (\\-){0,1}\\d+\\.\\d+){2,3} *\\n)|(vt( (\\-){0,1}\\d+\\.\\d+){2,3} *$)");
        WavefrontObject.face_V_VT_VN_Pattern = Pattern.compile("(f( \\d+/\\d+/\\d+){3,4} *\\n)|(f( \\d+/\\d+/\\d+){3,4} *$)");
        WavefrontObject.face_V_VT_Pattern = Pattern.compile("(f( \\d+/\\d+){3,4} *\\n)|(f( \\d+/\\d+){3,4} *$)");
        WavefrontObject.face_V_VN_Pattern = Pattern.compile("(f( \\d+//\\d+){3,4} *\\n)|(f( \\d+//\\d+){3,4} *$)");
        WavefrontObject.face_V_Pattern = Pattern.compile("(f( \\d+){3,4} *\\n)|(f( \\d+){3,4} *$)");
        WavefrontObject.groupObjectPattern = Pattern.compile("([go]( [\\w\\d]+) *\\n)|([go]( [\\w\\d]+) *$)");
    }
}



================================================
FILE: net/minecraftforge/client/model/techne/TechneModel.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.model.techne;

import java.util.Arrays;
import java.util.Iterator;
import org.w3c.dom.Node;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.NodeList;
import org.w3c.dom.Document;
import javax.xml.parsers.DocumentBuilder;
import java.util.zip.ZipEntry;
import org.xml.sax.SAXException;
import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;
import java.util.zip.ZipException;
import cpw.mods.fml.common.FMLLog;
import java.io.InputStream;
import java.io.ByteArrayInputStream;
import javax.xml.parsers.DocumentBuilderFactory;
import java.util.zip.ZipInputStream;
import net.minecraftforge.client.model.ModelFormatException;
import java.util.LinkedHashMap;
import java.util.HashMap;
import java.net.URL;
import java.util.Map;
import java.util.List;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;
import net.minecraftforge.client.model.IModelCustom;

@SideOnly(Side.CLIENT)
public class TechneModel extends bbo implements IModelCustom
{
    public static final List<String> cubeTypes;
    private String fileName;
    private Map<String, byte[]> zipContents;
    private Map<String, bcu> parts;
    private String texture;
    private int textureName;
    private boolean textureNameSet;
    
    public TechneModel(final String fileName, final URL resource) throws ModelFormatException {
        this.zipContents = new HashMap<String, byte[]>();
        this.parts = new LinkedHashMap<String, bcu>();
        this.texture = null;
        this.textureNameSet = false;
        this.fileName = fileName;
        this.loadTechneModel(resource);
    }
    
    private void loadTechneModel(final URL fileURL) throws ModelFormatException {
        try {
            final ZipInputStream zipInput = new ZipInputStream(fileURL.openStream());
            ZipEntry entry;
            while ((entry = zipInput.getNextEntry()) != null) {
                final byte[] data = new byte[(int)entry.getSize()];
                for (int i = 0; zipInput.available() > 0 && i < data.length; data[i++] = (byte)zipInput.read()) {}
                this.zipContents.put(entry.getName(), data);
            }
            final byte[] modelXml = this.zipContents.get("model.xml");
            if (modelXml == null) {
                throw new ModelFormatException("Model " + this.fileName + " contains no model.xml file");
            }
            final DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
            final DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
            final Document document = documentBuilder.parse(new ByteArrayInputStream(modelXml));
            final NodeList nodeListTechne = document.getElementsByTagName("Techne");
            if (nodeListTechne.getLength() < 1) {
                throw new ModelFormatException("Model " + this.fileName + " contains no Techne tag");
            }
            final NodeList nodeListModel = document.getElementsByTagName("Model");
            if (nodeListModel.getLength() < 1) {
                throw new ModelFormatException("Model " + this.fileName + " contains no Model tag");
            }
            final NamedNodeMap modelAttributes = nodeListModel.item(0).getAttributes();
            if (modelAttributes == null) {
                throw new ModelFormatException("Model " + this.fileName + " contains a Model tag with no attributes");
            }
            final Node modelTexture = modelAttributes.getNamedItem("texture");
            if (modelTexture != null) {
                this.texture = modelTexture.getTextContent();
            }
            final NodeList shapes = document.getElementsByTagName("Shape");
            for (int j = 0; j < shapes.getLength(); ++j) {
                final Node shape = shapes.item(j);
                final NamedNodeMap shapeAttributes = shape.getAttributes();
                if (shapeAttributes == null) {
                    throw new ModelFormatException("Shape #" + (j + 1) + " in " + this.fileName + " has no attributes");
                }
                final Node name = shapeAttributes.getNamedItem("name");
                String shapeName = null;
                if (name != null) {
                    shapeName = name.getNodeValue();
                }
                if (shapeName == null) {
                    shapeName = "Shape #" + (j + 1);
                }
                String shapeType = null;
                final Node type = shapeAttributes.getNamedItem("type");
                if (type != null) {
                    shapeType = type.getNodeValue();
                }
                if (shapeType != null && !TechneModel.cubeTypes.contains(shapeType)) {
                    FMLLog.warning("Model shape [" + shapeName + "] in " + this.fileName + " is not a cube, ignoring", new Object[0]);
                }
                else {
                    try {
                        boolean mirrored = false;
                        String[] offset = new String[3];
                        String[] position = new String[3];
                        String[] rotation = new String[3];
                        String[] size = new String[3];
                        String[] textureOffset = new String[2];
                        final NodeList shapeChildren = shape.getChildNodes();
                        for (int k = 0; k < shapeChildren.getLength(); ++k) {
                            final Node shapeChild = shapeChildren.item(k);
                            final String shapeChildName = shapeChild.getNodeName();
                            String shapeChildValue = shapeChild.getTextContent();
                            if (shapeChildValue != null) {
                                shapeChildValue = shapeChildValue.trim();
                                if (shapeChildName.equals("IsMirrored")) {
                                    mirrored = !shapeChildValue.equals("False");
                                }
                                else if (shapeChildName.equals("Offset")) {
                                    offset = shapeChildValue.split(",");
                                }
                                else if (shapeChildName.equals("Position")) {
                                    position = shapeChildValue.split(",");
                                }
                                else if (shapeChildName.equals("Rotation")) {
                                    rotation = shapeChildValue.split(",");
                                }
                                else if (shapeChildName.equals("Size")) {
                                    size = shapeChildValue.split(",");
                                }
                                else if (shapeChildName.equals("TextureOffset")) {
                                    textureOffset = shapeChildValue.split(",");
                                }
                            }
                        }
                        final bcu cube = new bcu((bbo)this, Integer.parseInt(textureOffset[0]), Integer.parseInt(textureOffset[1]));
                        cube.i = mirrored;
                        cube.a(Float.parseFloat(offset[0]), Float.parseFloat(offset[1]), Float.parseFloat(offset[2]), Integer.parseInt(size[0]), Integer.parseInt(size[1]), Integer.parseInt(size[2]));
                        cube.a(Float.parseFloat(position[0]), Float.parseFloat(position[1]) - 23.4f, Float.parseFloat(position[2]));
                        cube.f = (float)Math.toRadians(Float.parseFloat(rotation[0]));
                        cube.g = (float)Math.toRadians(Float.parseFloat(rotation[1]));
                        cube.h = (float)Math.toRadians(Float.parseFloat(rotation[2]));
                        this.parts.put(shapeName, cube);
                    }
                    catch (final NumberFormatException e) {
                        FMLLog.warning("Model shape [" + shapeName + "] in " + this.fileName + " contains malformed integers within its data, ignoring", new Object[0]);
                        e.printStackTrace();
                    }
                }
            }
        }
        catch (final ZipException e2) {
            throw new ModelFormatException("Model " + this.fileName + " is not a valid zip file");
        }
        catch (final IOException e3) {
            throw new ModelFormatException("Model " + this.fileName + " could not be read", e3);
        }
        catch (final ParserConfigurationException e4) {}
        catch (final SAXException e5) {
            throw new ModelFormatException("Model " + this.fileName + " contains invalid XML", e5);
        }
    }
    
    private void bindTexture() {
    }
    
    public String getType() {
        return "tcn";
    }
    
    public void renderAll() {
        this.bindTexture();
        for (final bcu part : this.parts.values()) {
            part.b(1.0f);
        }
    }
    
    public void renderPart(final String partName) {
        final bcu part = this.parts.get(partName);
        if (part != null) {
            this.bindTexture();
            part.b(1.0f);
        }
    }
    
    public void renderOnly(final String... groupNames) {
        this.bindTexture();
        for (final bcu part : this.parts.values()) {
            for (final String groupName : groupNames) {
                if (groupName.equalsIgnoreCase(part.n)) {
                    part.a(1.0f);
                }
            }
        }
    }
    
    public void renderAllExcept(final String... excludedGroupNames) {
        for (final bcu part : this.parts.values()) {
            boolean skipPart = false;
            for (final String excludedGroupName : excludedGroupNames) {
                if (excludedGroupName.equalsIgnoreCase(part.n)) {
                    skipPart = true;
                }
            }
            if (!skipPart) {
                part.a(1.0f);
            }
        }
    }
    
    static {
        cubeTypes = Arrays.asList("d9e621f7-957f-4b77-b1ae-20dcd0da7751", "de81aa14-bd60-4228-8d8d-5238bcd3caaa");
    }
}



================================================
FILE: net/minecraftforge/client/model/techne/TechneModelLoader.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.client.model.techne;

import net.minecraftforge.client.model.ModelFormatException;
import net.minecraftforge.client.model.IModelCustom;
import java.net.URL;
import net.minecraftforge.client.model.IModelCustomLoader;

public class TechneModelLoader implements IModelCustomLoader
{
    private static final String[] types;
    
    @Override
    public String getType() {
        return "Techne model";
    }
    
    @Override
    public String[] getSuffixes() {
        return TechneModelLoader.types;
    }
    
    @Override
    public IModelCustom loadInstance(final String resourceName, final URL resource) throws ModelFormatException {
        return new TechneModel(resourceName, resource);
    }
    
    static {
        types = new String[] { "tcn" };
    }
}



================================================
FILE: net/minecraftforge/common/AchievementPage.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import java.util.HashSet;
import java.util.Set;
import java.util.Iterator;
import java.util.List;
import java.util.Collection;
import java.util.Arrays;
import java.util.LinkedList;

public class AchievementPage
{
    private String name;
    private LinkedList<ko> achievements;
    private static LinkedList<AchievementPage> achievementPages;
    
    public AchievementPage(final String name, final ko... achievements) {
        this.name = name;
        this.achievements = new LinkedList<ko>(Arrays.asList(achievements));
    }
    
    public String getName() {
        return this.name;
    }
    
    public List<ko> getAchievements() {
        return this.achievements;
    }
    
    public static void registerAchievementPage(final AchievementPage page) {
        if (getAchievementPage(page.getName()) != null) {
            throw new RuntimeException("Duplicate achievement page name \"" + page.getName() + "\"!");
        }
        AchievementPage.achievementPages.add(page);
    }
    
    public static AchievementPage getAchievementPage(final int index) {
        return AchievementPage.achievementPages.get(index);
    }
    
    public static AchievementPage getAchievementPage(final String name) {
        for (final AchievementPage page : AchievementPage.achievementPages) {
            if (page.getName().equals(name)) {
                return page;
            }
        }
        return null;
    }
    
    public static Set<AchievementPage> getAchievementPages() {
        return new HashSet<AchievementPage>(AchievementPage.achievementPages);
    }
    
    public static boolean isAchievementInPages(final ko achievement) {
        for (final AchievementPage page : AchievementPage.achievementPages) {
            if (page.getAchievements().contains(achievement)) {
                return true;
            }
        }
        return false;
    }
    
    public static String getTitle(final int index) {
        return (index == -1) ? "Minecraft" : getAchievementPage(index).getName();
    }
    
    static {
        AchievementPage.achievementPages = new LinkedList<AchievementPage>();
    }
}



================================================
FILE: net/minecraftforge/common/BiomeDictionary.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import java.util.EnumSet;
import net.minecraftforge.event.terraingen.DeferredBiomeDecorator;
import cpw.mods.fml.common.FMLLog;
import java.util.Iterator;
import java.util.ArrayList;

public class BiomeDictionary
{
    private static final int BIOME_LIST_SIZE = 256;
    private static BiomeInfo[] biomeList;
    private static ArrayList<acq>[] typeInfoList;
    
    public static boolean registerBiomeType(final acq biome, final Type... types) {
        if (acq.a[biome.N] != null) {
            for (final Type type : types) {
                if (BiomeDictionary.typeInfoList[type.ordinal()] == null) {
                    BiomeDictionary.typeInfoList[type.ordinal()] = new ArrayList<acq>();
                }
                BiomeDictionary.typeInfoList[type.ordinal()].add(biome);
            }
            if (BiomeDictionary.biomeList[biome.N] == null) {
                BiomeDictionary.biomeList[biome.N] = new BiomeInfo(types);
            }
            else {
                for (final Type type : types) {
                    BiomeDictionary.biomeList[biome.N].typeList.add(type);
                }
            }
            return true;
        }
        return false;
    }
    
    public static acq[] getBiomesForType(final Type type) {
        if (BiomeDictionary.typeInfoList[type.ordinal()] != null) {
            return BiomeDictionary.typeInfoList[type.ordinal()].toArray(new acq[0]);
        }
        return new acq[0];
    }
    
    public static Type[] getTypesForBiome(final acq biome) {
        checkRegistration(biome);
        if (BiomeDictionary.biomeList[biome.N] != null) {
            return BiomeDictionary.biomeList[biome.N].typeList.toArray(new Type[0]);
        }
        return new Type[0];
    }
    
    public static boolean areBiomesEquivalent(final acq biomeA, final acq biomeB) {
        final int a = biomeA.N;
        final int b = biomeB.N;
        checkRegistration(biomeA);
        checkRegistration(biomeB);
        if (BiomeDictionary.biomeList[a] != null && BiomeDictionary.biomeList[b] != null) {
            for (final Type type : BiomeDictionary.biomeList[a].typeList) {
                if (containsType(BiomeDictionary.biomeList[b], type)) {
                    return true;
                }
            }
        }
        return false;
    }
    
    public static boolean isBiomeOfType(final acq biome, final Type type) {
        checkRegistration(biome);
        return BiomeDictionary.biomeList[biome.N] != null && containsType(BiomeDictionary.biomeList[biome.N], type);
    }
    
    public static boolean isBiomeRegistered(final acq biome) {
        return BiomeDictionary.biomeList[biome.N] != null;
    }
    
    public static boolean isBiomeRegistered(final int biomeID) {
        return BiomeDictionary.biomeList[biomeID] != null;
    }
    
    public static void registerAllBiomes() {
        FMLLog.warning("Redundant call to BiomeDictionary.registerAllBiomes ignored", new Object[0]);
    }
    
    public static void registerAllBiomesAndGenerateEvents() {
        for (int i = 0; i < acq.a.length; ++i) {
            final acq biome = acq.a[i];
            if (biome != null) {
                if (biome.I instanceof DeferredBiomeDecorator) {
                    final DeferredBiomeDecorator decorator = (DeferredBiomeDecorator)biome.I;
                    decorator.fireCreateEventAndReplace();
                }
                checkRegistration(biome);
            }
        }
    }
    
    public static void makeBestGuess(final acq biome) {
        if (biome.I.z >= 3) {
            if (biome.e() && biome.F >= 1.0f) {
                registerBiomeType(biome, Type.JUNGLE);
            }
            else if (!biome.e()) {
                registerBiomeType(biome, Type.FOREST);
            }
        }
        else if (biome.E <= 0.3f && biome.E >= 0.0f && (!biome.e() || biome.D >= 0.0f)) {
            registerBiomeType(biome, Type.PLAINS);
        }
        if (biome.e() && biome.D < 0.0f && biome.E <= 0.3f && biome.E >= 0.0f) {
            registerBiomeType(biome, Type.SWAMP);
        }
        if (biome.D <= -0.5f) {
            registerBiomeType(biome, Type.WATER);
        }
        if (biome.E >= 1.5f) {
            registerBiomeType(biome, Type.MOUNTAIN);
        }
        if (biome.c() || biome.F < 0.2f) {
            registerBiomeType(biome, Type.FROZEN);
        }
        if (!biome.e() && biome.F >= 1.0f) {
            registerBiomeType(biome, Type.DESERT);
        }
    }
    
    private static void checkRegistration(final acq biome) {
        if (!isBiomeRegistered(biome)) {
            makeBestGuess(biome);
        }
    }
    
    private static boolean containsType(final BiomeInfo info, final Type type) {
        return info.typeList.contains(type);
    }
    
    private static void registerVanillaBiomes() {
        registerBiomeType(acq.b, Type.WATER);
        registerBiomeType(acq.c, Type.PLAINS);
        registerBiomeType(acq.d, Type.DESERT);
        registerBiomeType(acq.e, Type.MOUNTAIN);
        registerBiomeType(acq.f, Type.FOREST);
        registerBiomeType(acq.g, Type.FOREST, Type.FROZEN);
        registerBiomeType(acq.u, Type.FOREST, Type.FROZEN);
        registerBiomeType(acq.h, Type.SWAMP);
        registerBiomeType(acq.i, Type.WATER);
        registerBiomeType(acq.l, Type.WATER, Type.FROZEN);
        registerBiomeType(acq.m, Type.WATER, Type.FROZEN);
        registerBiomeType(acq.n, Type.FROZEN);
        registerBiomeType(acq.o, Type.FROZEN);
        registerBiomeType(acq.r, Type.BEACH);
        registerBiomeType(acq.s, Type.DESERT);
        registerBiomeType(acq.w, Type.JUNGLE);
        registerBiomeType(acq.x, Type.JUNGLE);
        registerBiomeType(acq.t, Type.FOREST);
        registerBiomeType(acq.k, Type.END);
        registerBiomeType(acq.j, Type.NETHER);
        registerBiomeType(acq.p, Type.MUSHROOM);
        registerBiomeType(acq.v, Type.MOUNTAIN);
        registerBiomeType(acq.q, Type.MUSHROOM, Type.BEACH);
    }
    
    static {
        BiomeDictionary.biomeList = new BiomeInfo[256];
        BiomeDictionary.typeInfoList = new ArrayList[Type.values().length];
        registerVanillaBiomes();
    }
    
    public enum Type
    {
        FOREST, 
        PLAINS, 
        MOUNTAIN, 
        HILLS, 
        SWAMP, 
        WATER, 
        DESERT, 
        FROZEN, 
        JUNGLE, 
        WASTELAND, 
        BEACH, 
        NETHER, 
        END, 
        MUSHROOM, 
        MAGICAL;
    }
    
    private static class BiomeInfo
    {
        public EnumSet<Type> typeList;
        
        public BiomeInfo(final Type[] types) {
            this.typeList = EnumSet.noneOf(Type.class);
            for (final Type t : types) {
                this.typeList.add(t);
            }
        }
    }
}



================================================
FILE: net/minecraftforge/common/BiomeManager.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import java.util.Collection;
import java.util.ArrayList;

public class BiomeManager
{
    public static void addVillageBiome(final acq biome, final boolean canSpawn) {
        if (!aiw.e.contains(biome)) {
            final ArrayList<acq> biomes = new ArrayList<acq>(aiw.e);
            biomes.add(biome);
            aiw.e = biomes;
        }
    }
    
    public static void removeVillageBiome(final acq biome) {
        if (aiw.e.contains(biome)) {
            final ArrayList<acq> biomes = new ArrayList<acq>(aiw.e);
            biomes.remove(biome);
            aiw.e = biomes;
        }
    }
    
    public static void addStrongholdBiome(final acq biome) {
        if (!ahq.allowedBiomes.contains(biome)) {
            ahq.allowedBiomes.add(biome);
        }
    }
    
    public static void removeStrongholdBiome(final acq biome) {
        if (ahq.allowedBiomes.contains(biome)) {
            ahq.allowedBiomes.remove(biome);
        }
    }
    
    public static void addSpawnBiome(final acq biome) {
        if (!acv.allowedBiomes.contains(biome)) {
            acv.allowedBiomes.add(biome);
        }
    }
    
    public static void removeSpawnBiome(final acq biome) {
        if (acv.allowedBiomes.contains(biome)) {
            acv.allowedBiomes.remove(biome);
        }
    }
}



================================================
FILE: net/minecraftforge/common/ChestGenHooks.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import java.util.Iterator;
import java.util.Random;
import java.util.ArrayList;
import java.util.HashMap;

public class ChestGenHooks
{
    public static final String MINESHAFT_CORRIDOR = "mineshaftCorridor";
    public static final String PYRAMID_DESERT_CHEST = "pyramidDesertyChest";
    public static final String PYRAMID_JUNGLE_CHEST = "pyramidJungleChest";
    public static final String PYRAMID_JUNGLE_DISPENSER = "pyramidJungleDispenser";
    public static final String STRONGHOLD_CORRIDOR = "strongholdCorridor";
    public static final String STRONGHOLD_LIBRARY = "strongholdLibrary";
    public static final String STRONGHOLD_CROSSING = "strongholdCrossing";
    public static final String VILLAGE_BLACKSMITH = "villageBlacksmith";
    public static final String BONUS_CHEST = "bonusChest";
    public static final String DUNGEON_CHEST = "dungeonChest";
    private static final HashMap<String, ChestGenHooks> chestInfo;
    private static boolean hasInit;
    private String category;
    private int countMin;
    private int countMax;
    ArrayList<mk> contents;
    
    private static void init() {
        if (ChestGenHooks.hasInit) {
            return;
        }
        ChestGenHooks.hasInit = true;
        addInfo("mineshaftCorridor", agh.a, 3, 7);
        addInfo("pyramidDesertyChest", ahl.i, 2, 7);
        addInfo("pyramidJungleChest", ahm.l, 2, 7);
        addInfo("pyramidJungleDispenser", ahm.m, 2, 2);
        addInfo("strongholdCorridor", ahw.a, 2, 4);
        addInfo("strongholdLibrary", aia.a, 1, 5);
        addInfo("strongholdCrossing", aif.b, 1, 5);
        addInfo("villageBlacksmith", aji.a, 3, 9);
        addInfo("bonusChest", js.T, 10, 10);
        addInfo("dungeonChest", afp.a, 8, 8);
        final ye book = new ye((yc)yc.bY, 1, 0);
        final mk tmp = new mk(book, 1, 1, 1);
        getInfo("mineshaftCorridor").addItem(tmp);
        getInfo("pyramidDesertyChest").addItem(tmp);
        getInfo("pyramidJungleChest").addItem(tmp);
        getInfo("strongholdCorridor").addItem(tmp);
        getInfo("strongholdLibrary").addItem(new mk(book, 1, 5, 2));
        getInfo("strongholdCrossing").addItem(tmp);
        getInfo("dungeonChest").addItem(tmp);
    }
    
    static void addDungeonLoot(final ChestGenHooks dungeon, final ye item, final int weight, final int min, final int max) {
        dungeon.addItem(new mk(item, min, max, weight));
    }
    
    private static void addInfo(final String category, final mk[] items, final int min, final int max) {
        ChestGenHooks.chestInfo.put(category, new ChestGenHooks(category, items, min, max));
    }
    
    public static ChestGenHooks getInfo(final String category) {
        if (!ChestGenHooks.chestInfo.containsKey(category)) {
            ChestGenHooks.chestInfo.put(category, new ChestGenHooks(category));
        }
        return ChestGenHooks.chestInfo.get(category);
    }
    
    public static ye[] generateStacks(final Random rand, final ye source, final int min, final int max) {
        final int count = min + rand.nextInt(max - min + 1);
        ye[] ret;
        if (source.b() == null) {
            ret = new ye[0];
        }
        else if (count > source.e()) {
            ret = new ye[count];
            for (int x = 0; x < count; ++x) {
                ret[x] = source.m();
                ret[x].b = 1;
            }
        }
        else {
            ret = new ye[] { source.m() };
            ret[0].b = count;
        }
        return ret;
    }
    
    public static mk[] getItems(final String category, final Random rnd) {
        return getInfo(category).getItems(rnd);
    }
    
    public static int getCount(final String category, final Random rand) {
        return getInfo(category).getCount(rand);
    }
    
    public static void addItem(final String category, final mk item) {
        getInfo(category).addItem(item);
    }
    
    public static void removeItem(final String category, final ye item) {
        getInfo(category).removeItem(item);
    }
    
    public static ye getOneItem(final String category, final Random rand) {
        return getInfo(category).getOneItem(rand);
    }
    
    public ChestGenHooks(final String category) {
        this.countMin = 0;
        this.countMax = 0;
        this.contents = new ArrayList<mk>();
        this.category = category;
    }
    
    public ChestGenHooks(final String category, final mk[] items, final int min, final int max) {
        this(category);
        for (final mk item : items) {
            this.contents.add(item);
        }
        this.countMin = min;
        this.countMax = max;
    }
    
    public void addItem(final mk item) {
        this.contents.add(item);
    }
    
    public void removeItem(final ye item) {
        final Iterator<mk> itr = this.contents.iterator();
        while (itr.hasNext()) {
            final mk cont = itr.next();
            if (item.a(cont.b) || (item.k() == 32767 && item.d == cont.b.d)) {
                itr.remove();
            }
        }
    }
    
    public mk[] getItems(final Random rnd) {
        final ArrayList<mk> ret = new ArrayList<mk>();
        for (final mk orig : this.contents) {
            final yc item = orig.b.b();
            if (item != null) {
                final mk n = item.getChestGenBase(this, rnd, orig);
                if (n == null) {
                    continue;
                }
                ret.add(n);
            }
        }
        return ret.toArray(new mk[ret.size()]);
    }
    
    public int getCount(final Random rand) {
        return (this.countMin < this.countMax) ? (this.countMin + rand.nextInt(this.countMax - this.countMin)) : this.countMin;
    }
    
    public ye getOneItem(final Random rand) {
        final mk[] items = this.getItems(rand);
        final mk item = (mk)mi.a(rand, (mj[])items);
        final ye[] stacks = generateStacks(rand, item.b, item.c, item.d);
        return (stacks.length > 0) ? stacks[0] : null;
    }
    
    public int getMin() {
        return this.countMin;
    }
    
    public int getMax() {
        return this.countMax;
    }
    
    public void setMin(final int value) {
        this.countMin = value;
    }
    
    public void setMax(final int value) {
        this.countMax = value;
    }
    
    static {
        chestInfo = new HashMap<String, ChestGenHooks>();
        ChestGenHooks.hasInit = false;
        init();
    }
}



================================================
FILE: net/minecraftforge/common/ConfigCategory.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import com.google.common.collect.ImmutableSet;
import java.util.Collection;
import java.util.Set;
import java.util.Iterator;
import com.google.common.base.Splitter;
import java.io.IOException;
import java.io.BufferedWriter;
import com.google.common.collect.ImmutableMap;
import java.util.TreeMap;
import java.util.ArrayList;
import java.util.Map;

public class ConfigCategory implements Map<String, Property>
{
    private String name;
    private String comment;
    private ArrayList<ConfigCategory> children;
    private Map<String, Property> properties;
    public final ConfigCategory parent;
    private boolean changed;
    
    public ConfigCategory(final String name) {
        this(name, null);
    }
    
    public ConfigCategory(final String name, final ConfigCategory parent) {
        this.children = new ArrayList<ConfigCategory>();
        this.properties = new TreeMap<String, Property>();
        this.changed = false;
        this.name = name;
        this.parent = parent;
        if (parent != null) {
            parent.children.add(this);
        }
    }
    
    @Override
    public boolean equals(final Object obj) {
        if (obj instanceof ConfigCategory) {
            final ConfigCategory cat = (ConfigCategory)obj;
            return this.name.equals(cat.name) && this.children.equals(cat.children);
        }
        return false;
    }
    
    public String getQualifiedName() {
        return getQualifiedName(this.name, this.parent);
    }
    
    public static String getQualifiedName(final String name, final ConfigCategory parent) {
        return (parent == null) ? name : (parent.getQualifiedName() + "." + name);
    }
    
    public ConfigCategory getFirstParent() {
        return (this.parent == null) ? this : this.parent.getFirstParent();
    }
    
    public boolean isChild() {
        return this.parent != null;
    }
    
    public Map<String, Property> getValues() {
        return (Map<String, Property>)ImmutableMap.copyOf((Map)this.properties);
    }
    
    public void setComment(final String comment) {
        this.comment = comment;
    }
    
    public boolean containsKey(final String key) {
        return this.properties.containsKey(key);
    }
    
    public Property get(final String key) {
        return this.properties.get(key);
    }
    
    private void write(final BufferedWriter out, final String... data) throws IOException {
        this.write(out, true, data);
    }
    
    private void write(final BufferedWriter out, final boolean new_line, final String... data) throws IOException {
        for (int x = 0; x < data.length; ++x) {
            out.write(data[x]);
        }
        if (new_line) {
            out.write(Configuration.NEW_LINE);
        }
    }
    
    public void write(final BufferedWriter out, final int indent) throws IOException {
        final String pad0 = this.getIndent(indent);
        final String pad2 = this.getIndent(indent + 1);
        final String pad3 = this.getIndent(indent + 2);
        this.write(out, pad0, "####################");
        this.write(out, pad0, "# ", this.name);
        if (this.comment != null) {
            this.write(out, pad0, "#===================");
            final Splitter splitter = Splitter.onPattern("\r?\n");
            for (final String line : splitter.split((CharSequence)this.comment)) {
                this.write(out, pad0, "# ", line);
            }
        }
        this.write(out, pad0, "####################", Configuration.NEW_LINE);
        if (!Configuration.allowedProperties.matchesAllOf((CharSequence)this.name)) {
            this.name = '\"' + this.name + '\"';
        }
        this.write(out, pad0, this.name, " {");
        final Property[] props = this.properties.values().toArray(new Property[this.properties.size()]);
        for (int x = 0; x < props.length; ++x) {
            final Property prop = props[x];
            if (prop.comment != null) {
                if (x != 0) {
                    out.newLine();
                }
                final Splitter splitter2 = Splitter.onPattern("\r?\n");
                for (final String commentLine : splitter2.split((CharSequence)prop.comment)) {
                    this.write(out, pad2, "# ", commentLine);
                }
            }
            String propName = prop.getName();
            if (!Configuration.allowedProperties.matchesAllOf((CharSequence)propName)) {
                propName = '\"' + propName + '\"';
            }
            if (prop.isList()) {
                final char type = prop.getType().getID();
                this.write(out, pad2, String.valueOf(type), ":", propName, " <");
                for (final String line2 : prop.getStringList()) {
                    this.write(out, pad3, line2);
                }
                this.write(out, pad2, " >");
            }
            else if (prop.getType() == null) {
                this.write(out, pad2, propName, "=", prop.getString());
            }
            else {
                final char type = prop.getType().getID();
                this.write(out, pad2, String.valueOf(type), ":", propName, "=", prop.getString());
            }
        }
        for (final ConfigCategory child : this.children) {
            child.write(out, indent + 1);
        }
        this.write(out, pad0, "}", Configuration.NEW_LINE);
    }
    
    private String getIndent(final int indent) {
        final StringBuilder buf = new StringBuilder("");
        for (int x = 0; x < indent; ++x) {
            buf.append("    ");
        }
        return buf.toString();
    }
    
    public boolean hasChanged() {
        if (this.changed) {
            return true;
        }
        for (final Property prop : this.properties.values()) {
            if (prop.hasChanged()) {
                return true;
            }
        }
        return false;
    }
    
    void resetChangedState() {
        this.changed = false;
        for (final Property prop : this.properties.values()) {
            prop.resetChangedState();
        }
    }
    
    @Override
    public int size() {
        return this.properties.size();
    }
    
    @Override
    public boolean isEmpty() {
        return this.properties.isEmpty();
    }
    
    @Override
    public boolean containsKey(final Object key) {
        return this.properties.containsKey(key);
    }
    
    @Override
    public boolean containsValue(final Object value) {
        return this.properties.containsValue(value);
    }
    
    @Override
    public Property get(final Object key) {
        return this.properties.get(key);
    }
    
    @Override
    public Property put(final String key, final Property value) {
        this.changed = true;
        return this.properties.put(key, value);
    }
    
    @Override
    public Property remove(final Object key) {
        this.changed = true;
        return this.properties.remove(key);
    }
    
    @Override
    public void putAll(final Map<? extends String, ? extends Property> m) {
        this.changed = true;
        this.properties.putAll(m);
    }
    
    @Override
    public void clear() {
        this.changed = true;
        this.properties.clear();
    }
    
    @Override
    public Set<String> keySet() {
        return this.properties.keySet();
    }
    
    @Override
    public Collection<Property> values() {
        return this.properties.values();
    }
    
    @Override
    public Set<Entry<String, Property>> entrySet() {
        return (Set<Entry<String, Property>>)ImmutableSet.copyOf((Collection)this.properties.entrySet());
    }
    
    public Set<ConfigCategory> getChildren() {
        return (Set<ConfigCategory>)ImmutableSet.copyOf((Collection)this.children);
    }
    
    public void removeChild(final ConfigCategory child) {
        if (this.children.contains(child)) {
            this.children.remove(child);
            this.changed = true;
        }
    }
}



================================================
FILE: net/minecraftforge/common/Configuration.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import java.io.PushbackInputStream;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Collection;
import com.google.common.collect.ImmutableSet;
import java.util.Set;
import cpw.mods.fml.common.Loader;
import java.util.Iterator;
import java.io.Writer;
import java.io.BufferedWriter;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.FileOutputStream;
import java.util.regex.Matcher;
import java.io.IOException;
import java.util.ArrayList;
import java.io.Reader;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.FileInputStream;
import java.util.Locale;
import cpw.mods.fml.common.FMLLog;
import cpw.mods.fml.relauncher.FMLInjectionData;
import java.util.TreeMap;
import java.util.Map;
import java.io.File;
import com.google.common.base.CharMatcher;
import java.util.regex.Pattern;

public class Configuration
{
    private static boolean[] configMarkers;
    private static final int ITEM_SHIFT = 256;
    private static final int MAX_BLOCKS = 4096;
    public static final String CATEGORY_GENERAL = "general";
    public static final String CATEGORY_BLOCK = "block";
    public static final String CATEGORY_ITEM = "item";
    public static final String ALLOWED_CHARS = "._-";
    public static final String DEFAULT_ENCODING = "UTF-8";
    public static final String CATEGORY_SPLITTER = ".";
    public static final String NEW_LINE;
    private static final Pattern CONFIG_START;
    private static final Pattern CONFIG_END;
    public static final CharMatcher allowedProperties;
    private static Configuration PARENT;
    File file;
    private Map<String, ConfigCategory> categories;
    private Map<String, Configuration> children;
    private boolean caseSensitiveCustomCategories;
    public String defaultEncoding;
    private String fileName;
    public boolean isChild;
    private boolean changed;
    
    public Configuration() {
        this.categories = new TreeMap<String, ConfigCategory>();
        this.children = new TreeMap<String, Configuration>();
        this.defaultEncoding = "UTF-8";
        this.fileName = null;
        this.isChild = false;
        this.changed = false;
    }
    
    public Configuration(final File file) {
        this.categories = new TreeMap<String, ConfigCategory>();
        this.children = new TreeMap<String, Configuration>();
        this.defaultEncoding = "UTF-8";
        this.fileName = null;
        this.isChild = false;
        this.changed = false;
        this.file = file;
        final String basePath = ((File)FMLInjectionData.data()[6]).getAbsolutePath().replace(File.separatorChar, '/').replace("/.", "");
        final String path = file.getAbsolutePath().replace(File.separatorChar, '/').replace("/./", "/").replace(basePath, "");
        if (Configuration.PARENT != null) {
            Configuration.PARENT.setChild(path, this);
            this.isChild = true;
        }
        else {
            this.fileName = path;
            this.load();
        }
    }
    
    public Configuration(final File file, final boolean caseSensitiveCustomCategories) {
        this(file);
        this.caseSensitiveCustomCategories = caseSensitiveCustomCategories;
    }
    
    public Property getBlock(final String key, final int defaultID) {
        return this.getBlock("block", key, defaultID, null);
    }
    
    public Property getBlock(final String key, final int defaultID, final String comment) {
        return this.getBlock("block", key, defaultID, comment);
    }
    
    public Property getBlock(final String category, final String key, final int defaultID) {
        return this.getBlockInternal(category, key, defaultID, null, 256, aqz.s.length);
    }
    
    public Property getBlock(final String category, final String key, final int defaultID, final String comment) {
        return this.getBlockInternal(category, key, defaultID, comment, 256, aqz.s.length);
    }
    
    public Property getTerrainBlock(final String category, final String key, final int defaultID, final String comment) {
        return this.getBlockInternal(category, key, defaultID, comment, 0, 256);
    }
    
    private Property getBlockInternal(final String category, final String key, int defaultID, final String comment, final int lower, final int upper) {
        final Property prop = this.get(category, key, -1, comment);
        if (prop.getInt() != -1) {
            Configuration.configMarkers[prop.getInt()] = true;
            return prop;
        }
        if (defaultID < lower) {
            FMLLog.warning("Mod attempted to get a block ID with a default in the Terrain Generation section, mod authors should make sure there defaults are above 256 unless explicitly needed for terrain generation. Most ores do not need to be below 256.", new Object[0]);
            FMLLog.warning("Config \"%s\" Category: \"%s\" Key: \"%s\" Default: %d", this.fileName, category, key, defaultID);
            defaultID = upper - 1;
        }
        if (aqz.s[defaultID] == null && !Configuration.configMarkers[defaultID]) {
            prop.set(defaultID);
            Configuration.configMarkers[defaultID] = true;
            return prop;
        }
        for (int j = upper - 1; j > 0; --j) {
            if (aqz.s[j] == null && !Configuration.configMarkers[j]) {
                prop.set(j);
                Configuration.configMarkers[j] = true;
                return prop;
            }
        }
        throw new RuntimeException("No more block ids available for " + key);
    }
    
    public Property getItem(final String key, final int defaultID) {
        return this.getItem("item", key, defaultID, null);
    }
    
    public Property getItem(final String key, final int defaultID, final String comment) {
        return this.getItem("item", key, defaultID, comment);
    }
    
    public Property getItem(final String category, final String key, final int defaultID) {
        return this.getItem(category, key, defaultID, null);
    }
    
    public Property getItem(final String category, final String key, final int defaultID, final String comment) {
        final Property prop = this.get(category, key, -1, comment);
        final int defaultShift = defaultID + 256;
        if (prop.getInt() != -1) {
            Configuration.configMarkers[prop.getInt() + 256] = true;
            return prop;
        }
        if (defaultID < 3840) {
            FMLLog.warning("Mod attempted to get a item ID with a default value in the block ID section, mod authors should make sure there defaults are above %d unless explicitly needed so that all block ids are free to store blocks.", 3840);
            FMLLog.warning("Config \"%s\" Category: \"%s\" Key: \"%s\" Default: %d", this.fileName, category, key, defaultID);
        }
        if (yc.g[defaultShift] == null && !Configuration.configMarkers[defaultShift] && defaultShift >= aqz.s.length) {
            prop.set(defaultID);
            Configuration.configMarkers[defaultShift] = true;
            return prop;
        }
        for (int x = yc.g.length - 1; x >= 256; --x) {
            if (yc.g[x] == null && !Configuration.configMarkers[x]) {
                prop.set(x - 256);
                Configuration.configMarkers[x] = true;
                return prop;
            }
        }
        throw new RuntimeException("No more item ids available for " + key);
    }
    
    public Property get(final String category, final String key, final int defaultValue) {
        return this.get(category, key, defaultValue, null);
    }
    
    public Property get(final String category, final String key, final int defaultValue, final String comment) {
        final Property prop = this.get(category, key, Integer.toString(defaultValue), comment, Property.Type.INTEGER);
        if (!prop.isIntValue()) {
            prop.set(defaultValue);
        }
        return prop;
    }
    
    public Property get(final String category, final String key, final boolean defaultValue) {
        return this.get(category, key, defaultValue, null);
    }
    
    public Property get(final String category, final String key, final boolean defaultValue, final String comment) {
        final Property prop = this.get(category, key, Boolean.toString(defaultValue), comment, Property.Type.BOOLEAN);
        if (!prop.isBooleanValue()) {
            prop.set(defaultValue);
        }
        return prop;
    }
    
    public Property get(final String category, final String key, final double defaultValue) {
        return this.get(category, key, defaultValue, null);
    }
    
    public Property get(final String category, final String key, final double defaultValue, final String comment) {
        final Property prop = this.get(category, key, Double.toString(defaultValue), comment, Property.Type.DOUBLE);
        if (!prop.isDoubleValue()) {
            prop.set(defaultValue);
        }
        return prop;
    }
    
    public Property get(final String category, final String key, final String defaultValue) {
        return this.get(category, key, defaultValue, null);
    }
    
    public Property get(final String category, final String key, final String defaultValue, final String comment) {
        return this.get(category, key, defaultValue, comment, Property.Type.STRING);
    }
    
    public Property get(final String category, final String key, final String[] defaultValue) {
        return this.get(category, key, defaultValue, null);
    }
    
    public Property get(final String category, final String key, final String[] defaultValue, final String comment) {
        return this.get(category, key, defaultValue, comment, Property.Type.STRING);
    }
    
    public Property get(final String category, final String key, final int[] defaultValue) {
        return this.get(category, key, defaultValue, null);
    }
    
    public Property get(final String category, final String key, final int[] defaultValue, final String comment) {
        final String[] values = new String[defaultValue.length];
        for (int i = 0; i < defaultValue.length; ++i) {
            values[i] = Integer.toString(defaultValue[i]);
        }
        final Property prop = this.get(category, key, values, comment, Property.Type.INTEGER);
        if (!prop.isIntList()) {
            prop.set(values);
        }
        return prop;
    }
    
    public Property get(final String category, final String key, final double[] defaultValue) {
        return this.get(category, key, defaultValue, null);
    }
    
    public Property get(final String category, final String key, final double[] defaultValue, final String comment) {
        final String[] values = new String[defaultValue.length];
        for (int i = 0; i < defaultValue.length; ++i) {
            values[i] = Double.toString(defaultValue[i]);
        }
        final Property prop = this.get(category, key, values, comment, Property.Type.DOUBLE);
        if (!prop.isDoubleList()) {
            prop.set(values);
        }
        return prop;
    }
    
    public Property get(final String category, final String key, final boolean[] defaultValue) {
        return this.get(category, key, defaultValue, null);
    }
    
    public Property get(final String category, final String key, final boolean[] defaultValue, final String comment) {
        final String[] values = new String[defaultValue.length];
        for (int i = 0; i < defaultValue.length; ++i) {
            values[i] = Boolean.toString(defaultValue[i]);
        }
        final Property prop = this.get(category, key, values, comment, Property.Type.BOOLEAN);
        if (!prop.isBooleanList()) {
            prop.set(values);
        }
        return prop;
    }
    
    public Property get(String category, final String key, final String defaultValue, final String comment, final Property.Type type) {
        if (!this.caseSensitiveCustomCategories) {
            category = category.toLowerCase(Locale.ENGLISH);
        }
        final ConfigCategory cat = this.getCategory(category);
        if (cat.containsKey(key)) {
            Property prop = cat.get(key);
            if (prop.getType() == null) {
                prop = new Property(prop.getName(), prop.getString(), type);
                cat.put(key, prop);
            }
            prop.comment = comment;
            return prop;
        }
        if (defaultValue != null) {
            final Property prop = new Property(key, defaultValue, type);
            prop.set(defaultValue);
            cat.put(key, prop);
            prop.comment = comment;
            return prop;
        }
        return null;
    }
    
    public Property get(String category, final String key, final String[] defaultValue, final String comment, final Property.Type type) {
        if (!this.caseSensitiveCustomCategories) {
            category = category.toLowerCase(Locale.ENGLISH);
        }
        final ConfigCategory cat = this.getCategory(category);
        if (cat.containsKey(key)) {
            Property prop = cat.get(key);
            if (prop.getType() == null) {
                prop = new Property(prop.getName(), prop.getString(), type);
                cat.put(key, prop);
            }
            prop.comment = comment;
            return prop;
        }
        if (defaultValue != null) {
            final Property prop = new Property(key, defaultValue, type);
            prop.comment = comment;
            cat.put(key, prop);
            return prop;
        }
        return null;
    }
    
    public boolean hasCategory(final String category) {
        return this.categories.get(category) != null;
    }
    
    public boolean hasKey(final String category, final String key) {
        final ConfigCategory cat = this.categories.get(category);
        return cat != null && cat.containsKey(key);
    }
    
    public void load() {
        if (Configuration.PARENT != null && Configuration.PARENT != this) {
            return;
        }
        BufferedReader buffer = null;
        UnicodeInputStreamReader input = null;
        try {
            if (this.file.getParentFile() != null) {
                this.file.getParentFile().mkdirs();
            }
            if (!this.file.exists() && !this.file.createNewFile()) {
                return;
            }
            if (this.file.canRead()) {
                input = new UnicodeInputStreamReader(new FileInputStream(this.file), this.defaultEncoding);
                this.defaultEncoding = input.getEncoding();
                buffer = new BufferedReader(input);
                ConfigCategory currentCat = null;
                Property.Type type = null;
                ArrayList<String> tmpList = null;
                int lineNum = 0;
                String name = null;
                while (true) {
                    ++lineNum;
                    final String line = buffer.readLine();
                    if (line == null) {
                        break;
                    }
                    final Matcher start = Configuration.CONFIG_START.matcher(line);
                    final Matcher end = Configuration.CONFIG_END.matcher(line);
                    if (start.matches()) {
                        this.fileName = start.group(1);
                        this.categories = new TreeMap<String, ConfigCategory>();
                    }
                    else if (end.matches()) {
                        this.fileName = end.group(1);
                        final Configuration child = new Configuration();
                        child.categories = this.categories;
                        this.children.put(this.fileName, child);
                    }
                    else {
                        int nameStart = -1;
                        int nameEnd = -1;
                        boolean skip = false;
                        boolean quoted = false;
                        for (int i = 0; i < line.length() && !skip; ++i) {
                            if (Character.isLetterOrDigit(line.charAt(i)) || "._-".indexOf(line.charAt(i)) != -1 || (quoted && line.charAt(i) != '\"')) {
                                if (nameStart == -1) {
                                    nameStart = i;
                                }
                                nameEnd = i;
                            }
                            else if (!Character.isWhitespace(line.charAt(i))) {
                                switch (line.charAt(i)) {
                                    case '#': {
                                        skip = true;
                                        break;
                                    }
                                    case '\"': {
                                        if (quoted) {
                                            quoted = false;
                                        }
                                        if (!quoted && nameStart == -1) {
                                            quoted = true;
                                            break;
                                        }
                                        break;
                                    }
                                    case '{': {
                                        name = line.substring(nameStart, nameEnd + 1);
                                        final String qualifiedName = ConfigCategory.getQualifiedName(name, currentCat);
                                        final ConfigCategory cat = this.categories.get(qualifiedName);
                                        if (cat == null) {
                                            currentCat = new ConfigCategory(name, currentCat);
                                            this.categories.put(qualifiedName, currentCat);
                                        }
                                        else {
                                            currentCat = cat;
                                        }
                                        name = null;
                                        break;
                                    }
                                    case '}': {
                                        if (currentCat == null) {
                                            throw new RuntimeException(String.format("Config file corrupt, attepted to close to many categories '%s:%d'", this.fileName, lineNum));
                                        }
                                        currentCat = currentCat.parent;
                                        break;
                                    }
                                    case '=': {
                                        name = line.substring(nameStart, nameEnd + 1);
                                        if (currentCat == null) {
                                            throw new RuntimeException(String.format("'%s' has no scope in '%s:%d'", name, this.fileName, lineNum));
                                        }
                                        final Property prop = new Property(name, line.substring(i + 1), type, true);
                                        i = line.length();
                                        currentCat.put(name, prop);
                                        break;
                                    }
                                    case ':': {
                                        type = Property.Type.tryParse(line.substring(nameStart, nameEnd + 1).charAt(0));
                                        nameEnd = (nameStart = -1);
                                        break;
                                    }
                                    case '<': {
                                        if (tmpList != null) {
                                            throw new RuntimeException(String.format("Malformed list property \"%s:%d\"", this.fileName, lineNum));
                                        }
                                        name = line.substring(nameStart, nameEnd + 1);
                                        if (currentCat == null) {
                                            throw new RuntimeException(String.format("'%s' has no scope in '%s:%d'", name, this.fileName, lineNum));
                                        }
                                        tmpList = new ArrayList<String>();
                                        skip = true;
                                        break;
                                    }
                                    case '>': {
                                        if (tmpList == null) {
                                            throw new RuntimeException(String.format("Malformed list property \"%s:%d\"", this.fileName, lineNum));
                                        }
                                        currentCat.put(name, new Property(name, tmpList.toArray(new String[tmpList.size()]), type));
                                        name = null;
                                        tmpList = null;
                                        type = null;
                                        break;
                                    }
                                    default: {
                                        throw new RuntimeException(String.format("Unknown character '%s' in '%s:%d'", line.charAt(i), this.fileName, lineNum));
                                    }
                                }
                            }
                        }
                        if (quoted) {
                            throw new RuntimeException(String.format("Unmatched quote in '%s:%d'", this.fileName, lineNum));
                        }
                        if (tmpList == null || skip) {
                            continue;
                        }
                        tmpList.add(line.trim());
                    }
                }
            }
        }
        catch (final IOException e) {
            e.printStackTrace();
        }
        finally {
            if (buffer != null) {
                try {
                    buffer.close();
                }
                catch (final IOException ex) {}
            }
            if (input != null) {
                try {
                    input.close();
                }
                catch (final IOException ex2) {}
            }
        }
        this.resetChangedState();
    }
    
    public void save() {
        if (Configuration.PARENT != null && Configuration.PARENT != this) {
            Configuration.PARENT.save();
            return;
        }
        try {
            if (this.file.getParentFile() != null) {
                this.file.getParentFile().mkdirs();
            }
            if (!this.file.exists() && !this.file.createNewFile()) {
                return;
            }
            if (this.file.canWrite()) {
                final FileOutputStream fos = new FileOutputStream(this.file);
                final BufferedWriter buffer = new BufferedWriter(new OutputStreamWriter(fos, this.defaultEncoding));
                buffer.write("# Configuration file" + Configuration.NEW_LINE + Configuration.NEW_LINE);
                if (this.children.isEmpty()) {
                    this.save(buffer);
                }
                else {
                    for (final Map.Entry<String, Configuration> entry : this.children.entrySet()) {
                        buffer.write("START: \"" + entry.getKey() + "\"" + Configuration.NEW_LINE);
                        entry.getValue().save(buffer);
                        buffer.write("END: \"" + entry.getKey() + "\"" + Configuration.NEW_LINE + Configuration.NEW_LINE);
                    }
                }
                buffer.close();
                fos.close();
            }
        }
        catch (final IOException e) {
            e.printStackTrace();
        }
    }
    
    private void save(final BufferedWriter out) throws IOException {
        for (final ConfigCategory cat : this.categories.values()) {
            if (!cat.isChild()) {
                cat.write(out, 0);
                out.newLine();
            }
        }
    }
    
    public ConfigCategory getCategory(final String category) {
        ConfigCategory ret = this.categories.get(category);
        if (ret == null) {
            if (category.contains(".")) {
                final String[] hierarchy = category.split("\\.");
                ConfigCategory parent = this.categories.get(hierarchy[0]);
                if (parent == null) {
                    parent = new ConfigCategory(hierarchy[0]);
                    this.categories.put(parent.getQualifiedName(), parent);
                    this.changed = true;
                }
                for (int i = 1; i < hierarchy.length; ++i) {
                    final String name = ConfigCategory.getQualifiedName(hierarchy[i], parent);
                    ConfigCategory child = this.categories.get(name);
                    if (child == null) {
                        child = new ConfigCategory(hierarchy[i], parent);
                        this.categories.put(name, child);
                        this.changed = true;
                    }
                    ret = child;
                    parent = child;
                }
            }
            else {
                ret = new ConfigCategory(category);
                this.categories.put(category, ret);
                this.changed = true;
            }
        }
        return ret;
    }
    
    public void removeCategory(final ConfigCategory category) {
        for (final ConfigCategory child : category.getChildren()) {
            this.removeCategory(child);
        }
        if (this.categories.containsKey(category.getQualifiedName())) {
            this.categories.remove(category.getQualifiedName());
            if (category.parent != null) {
                category.parent.removeChild(category);
            }
            this.changed = true;
        }
    }
    
    public void addCustomCategoryComment(String category, final String comment) {
        if (!this.caseSensitiveCustomCategories) {
            category = category.toLowerCase(Locale.ENGLISH);
        }
        this.getCategory(category).setComment(comment);
    }
    
    private void setChild(final String name, final Configuration child) {
        if (!this.children.containsKey(name)) {
            this.children.put(name, child);
            this.changed = true;
        }
        else {
            final Configuration old = this.children.get(name);
            child.categories = old.categories;
            child.fileName = old.fileName;
            old.changed = true;
        }
    }
    
    public static void enableGlobalConfig() {
        (Configuration.PARENT = new Configuration(new File(Loader.instance().getConfigDir(), "global.cfg"))).load();
    }
    
    public boolean hasChanged() {
        if (this.changed) {
            return true;
        }
        for (final ConfigCategory cat : this.categories.values()) {
            if (cat.hasChanged()) {
                return true;
            }
        }
        for (final Configuration child : this.children.values()) {
            if (child.hasChanged()) {
                return true;
            }
        }
        return false;
    }
    
    private void resetChangedState() {
        this.changed = false;
        for (final ConfigCategory cat : this.categories.values()) {
            cat.resetChangedState();
        }
        for (final Configuration child : this.children.values()) {
            child.resetChangedState();
        }
    }
    
    public Set<String> getCategoryNames() {
        return (Set<String>)ImmutableSet.copyOf((Collection)this.categories.keySet());
    }
    
    static {
        Configuration.configMarkers = new boolean[yc.g.length];
        CONFIG_START = Pattern.compile("START: \"([^\\\"]+)\"");
        CONFIG_END = Pattern.compile("END: \"([^\\\"]+)\"");
        allowedProperties = CharMatcher.JAVA_LETTER_OR_DIGIT.or(CharMatcher.anyOf((CharSequence)"._-"));
        Configuration.PARENT = null;
        Arrays.fill(Configuration.configMarkers, false);
        NEW_LINE = System.getProperty("line.separator");
    }
    
    public static class UnicodeInputStreamReader extends Reader
    {
        private final InputStreamReader input;
        private final String defaultEnc;
        
        public UnicodeInputStreamReader(final InputStream source, final String encoding) throws IOException {
            this.defaultEnc = encoding;
            String enc = encoding;
            final byte[] data = new byte[4];
            final PushbackInputStream pbStream = new PushbackInputStream(source, data.length);
            final int read = pbStream.read(data, 0, data.length);
            int size = 0;
            final int bom16 = (data[0] & 0xFF) << 8 | (data[1] & 0xFF);
            final int bom17 = bom16 << 8 | (data[2] & 0xFF);
            final int bom18 = bom17 << 8 | (data[3] & 0xFF);
            if (bom17 == 15711167) {
                enc = "UTF-8";
                size = 3;
            }
            else if (bom16 == 65279) {
                enc = "UTF-16BE";
                size = 2;
            }
            else if (bom16 == 65534) {
                enc = "UTF-16LE";
                size = 2;
            }
            else if (bom18 == 65279) {
                enc = "UTF-32BE";
                size = 4;
            }
            else if (bom18 == -131072) {
                enc = "UTF-32LE";
                size = 4;
            }
            if (size < read) {
                pbStream.unread(data, size, read - size);
            }
            this.input = new InputStreamReader(pbStream, enc);
        }
        
        public String getEncoding() {
            return this.input.getEncoding();
        }
        
        @Override
        public int read(final char[] cbuf, final int off, final int len) throws IOException {
            return this.input.read(cbuf, off, len);
        }
        
        @Override
        public void close() throws IOException {
            this.input.close();
        }
    }
}



================================================
FILE: net/minecraftforge/common/DimensionManager.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import com.google.common.collect.HashMultiset;
import com.google.common.collect.MapMaker;
import java.io.File;
import java.util.logging.Level;
import cpw.mods.fml.common.FMLCommonHandler;
import net.minecraftforge.event.Event;
import net.minecraftforge.event.world.WorldEvent;
import net.minecraft.server.MinecraftServer;
import java.util.ListIterator;
import java.util.List;
import cpw.mods.fml.common.FMLLog;
import java.util.Collection;
import com.google.common.collect.Lists;
import java.util.Iterator;
import java.util.Arrays;
import java.util.Map;
import com.google.common.collect.Multiset;
import java.util.concurrent.ConcurrentMap;
import java.util.BitSet;
import java.util.ArrayList;
import java.util.Hashtable;

public class DimensionManager
{
    private static Hashtable<Integer, Class<? extends aei>> providers;
    private static Hashtable<Integer, Boolean> spawnSettings;
    private static Hashtable<Integer, js> worlds;
    private static boolean hasInit;
    private static Hashtable<Integer, Integer> dimensions;
    private static ArrayList<Integer> unloadQueue;
    private static BitSet dimensionMap;
    private static ConcurrentMap<abw, abw> weakWorldMap;
    private static Multiset<Integer> leakedWorlds;
    
    public static boolean registerProviderType(final int id, final Class<? extends aei> provider, final boolean keepLoaded) {
        if (DimensionManager.providers.containsKey(id)) {
            return false;
        }
        DimensionManager.providers.put(id, provider);
        DimensionManager.spawnSettings.put(id, keepLoaded);
        return true;
    }
    
    public static int[] unregisterProviderType(final int id) {
        if (!DimensionManager.providers.containsKey(id)) {
            return new int[0];
        }
        DimensionManager.providers.remove(id);
        DimensionManager.spawnSettings.remove(id);
        final int[] ret = new int[DimensionManager.dimensions.size()];
        int x = 0;
        for (final Map.Entry<Integer, Integer> ent : DimensionManager.dimensions.entrySet()) {
            if (ent.getValue() == id) {
                ret[x++] = ent.getKey();
            }
        }
        return Arrays.copyOf(ret, x);
    }
    
    public static void init() {
        if (DimensionManager.hasInit) {
            return;
        }
        registerProviderType(0, (Class<? extends aei>)aek.class, DimensionManager.hasInit = true);
        registerProviderType(-1, (Class<? extends aei>)aej.class, true);
        registerProviderType(1, (Class<? extends aei>)ael.class, false);
        registerDimension(0, 0);
        registerDimension(-1, -1);
        registerDimension(1, 1);
    }
    
    public static void registerDimension(final int id, final int providerType) {
        if (!DimensionManager.providers.containsKey(providerType)) {
            throw new IllegalArgumentException(String.format("Failed to register dimension for id %d, provider type %d does not exist", id, providerType));
        }
        if (DimensionManager.dimensions.containsKey(id)) {
            throw new IllegalArgumentException(String.format("Failed to register dimension for id %d, One is already registered", id));
        }
        DimensionManager.dimensions.put(id, providerType);
        if (id >= 0) {
            DimensionManager.dimensionMap.set(id);
        }
    }
    
    public static void unregisterDimension(final int id) {
        if (!DimensionManager.dimensions.containsKey(id)) {
            throw new IllegalArgumentException(String.format("Failed to unregister dimension for id %d; No provider registered", id));
        }
        DimensionManager.dimensions.remove(id);
    }
    
    public static boolean isDimensionRegistered(final int dim) {
        return DimensionManager.dimensions.containsKey(dim);
    }
    
    public static int getProviderType(final int dim) {
        if (!DimensionManager.dimensions.containsKey(dim)) {
            throw new IllegalArgumentException(String.format("Could not get provider type for dimension %d, does not exist", dim));
        }
        return DimensionManager.dimensions.get(dim);
    }
    
    public static aei getProvider(final int dim) {
        return getWorld(dim).t;
    }
    
    public static Integer[] getIDs(final boolean check) {
        if (check) {
            final List<abw> allWorlds = Lists.newArrayList((Iterable)DimensionManager.weakWorldMap.keySet());
            allWorlds.removeAll(DimensionManager.worlds.values());
            final ListIterator<abw> li = allWorlds.listIterator();
            while (li.hasNext()) {
                final abw w = li.next();
                DimensionManager.leakedWorlds.add((Object)System.identityHashCode(w));
            }
            final Iterator i$ = allWorlds.iterator();
            while (i$.hasNext()) {
                final abw w = i$.next();
                final int leakCount = DimensionManager.leakedWorlds.count((Object)System.identityHashCode(w));
                if (leakCount == 5) {
                    FMLLog.fine("The world %x (%s) may have leaked: first encounter (5 occurences).\n", System.identityHashCode(w), w.N().k());
                }
                else {
                    if (leakCount % 5 != 0) {
                        continue;
                    }
                    FMLLog.fine("The world %x (%s) may have leaked: seen %d times.\n", System.identityHashCode(w), w.N().k(), leakCount);
                }
            }
        }
        return getIDs();
    }
    
    public static Integer[] getIDs() {
        return DimensionManager.worlds.keySet().toArray(new Integer[DimensionManager.worlds.size()]);
    }
    
    public static void setWorld(final int id, final js world) {
        if (world != null) {
            DimensionManager.worlds.put(id, world);
            DimensionManager.weakWorldMap.put((abw)world, (abw)world);
            MinecraftServer.F().worldTickTimes.put(id, new long[100]);
            FMLLog.info("Loading dimension %d (%s) (%s)", id, world.N().k(), world.p());
        }
        else {
            DimensionManager.worlds.remove(id);
            MinecraftServer.F().worldTickTimes.remove(id);
            FMLLog.info("Unloading dimension %d", id);
        }
        final ArrayList<js> tmp = new ArrayList<js>();
        if (DimensionManager.worlds.get(0) != null) {
            tmp.add(DimensionManager.worlds.get(0));
        }
        if (DimensionManager.worlds.get(-1) != null) {
            tmp.add(DimensionManager.worlds.get(-1));
        }
        if (DimensionManager.worlds.get(1) != null) {
            tmp.add(DimensionManager.worlds.get(1));
        }
        for (final Map.Entry<Integer, js> entry : DimensionManager.worlds.entrySet()) {
            final int dim = entry.getKey();
            if (dim >= -1 && dim <= 1) {
                continue;
            }
            tmp.add(entry.getValue());
        }
        MinecraftServer.F().b = tmp.toArray(new js[tmp.size()]);
    }
    
    public static void initDimension(final int dim) {
        final js overworld = getWorld(0);
        if (overworld == null) {
            throw new RuntimeException("Cannot Hotload Dim: Overworld is not Loaded!");
        }
        try {
            getProviderType(dim);
        }
        catch (final Exception e) {
            System.err.println("Cannot Hotload Dim: " + e.getMessage());
            return;
        }
        final MinecraftServer mcServer = overworld.p();
        final amc savehandler = overworld.M();
        final acd worldSettings = new acd(overworld.N());
        final js world = (js)((dim == 0) ? overworld : new jl(mcServer, savehandler, overworld.N().k(), dim, worldSettings, overworld, mcServer.a, overworld.Y()));
        world.a((acb)new jo(mcServer, world));
        MinecraftForge.EVENT_BUS.post(new WorldEvent.Load((abw)world));
        if (!mcServer.K()) {
            world.N().a(mcServer.h());
        }
        mcServer.c(mcServer.i());
    }
    
    public static js getWorld(final int id) {
        return DimensionManager.worlds.get(id);
    }
    
    public static js[] getWorlds() {
        return DimensionManager.worlds.values().toArray(new js[DimensionManager.worlds.size()]);
    }
    
    public static boolean shouldLoadSpawn(final int dim) {
        final int id = getProviderType(dim);
        return DimensionManager.spawnSettings.containsKey(id) && DimensionManager.spawnSettings.get(id);
    }
    
    public static Integer[] getStaticDimensionIDs() {
        return DimensionManager.dimensions.keySet().toArray(new Integer[DimensionManager.dimensions.keySet().size()]);
    }
    
    public static aei createProviderFor(final int dim) {
        try {
            if (DimensionManager.dimensions.containsKey(dim)) {
                final aei provider = DimensionManager.providers.get(getProviderType(dim)).newInstance();
                provider.setDimension(dim);
                return provider;
            }
            throw new RuntimeException(String.format("No WorldProvider bound for dimension %d", dim));
        }
        catch (final Exception e) {
            FMLCommonHandler.instance().getFMLLogger().log(Level.SEVERE, String.format("An error occured trying to create an instance of WorldProvider %d (%s)", dim, DimensionManager.providers.get(getProviderType(dim)).getSimpleName()), e);
            throw new RuntimeException(e);
        }
    }
    
    public static void unloadWorld(final int id) {
        DimensionManager.unloadQueue.add(id);
    }
    
    public static void unloadWorlds(final Hashtable<Integer, long[]> worldTickTimes) {
        for (final int id : DimensionManager.unloadQueue) {
            final js w = DimensionManager.worlds.get(id);
            try {
                if (w != null) {
                    w.a(true, (lx)null);
                }
                else {
                    FMLLog.warning("Unexpected world unload - world %d is already unloaded", id);
                }
            }
            catch (final aca e) {
                e.printStackTrace();
            }
            finally {
                if (w != null) {
                    MinecraftForge.EVENT_BUS.post(new WorldEvent.Unload((abw)w));
                    w.n();
                    setWorld(id, null);
                }
            }
        }
        DimensionManager.unloadQueue.clear();
    }
    
    public static int getNextFreeDimId() {
        int next = 0;
        while (true) {
            next = DimensionManager.dimensionMap.nextClearBit(next);
            if (!DimensionManager.dimensions.containsKey(next)) {
                break;
            }
            DimensionManager.dimensionMap.set(next);
        }
        return next;
    }
    
    public static by saveDimensionDataMap() {
        final int[] data = new int[(DimensionManager.dimensionMap.length() + 32 - 1) / 32];
        final by dimMap = new by();
        for (int i = 0; i < data.length; ++i) {
            int val = 0;
            for (int j = 0; j < 32; ++j) {
                val |= (DimensionManager.dimensionMap.get(i * 32 + j) ? (1 << j) : 0);
            }
            data[i] = val;
        }
        dimMap.a("DimensionArray", data);
        return dimMap;
    }
    
    public static void loadDimensionDataMap(final by compoundTag) {
        if (compoundTag == null) {
            DimensionManager.dimensionMap.clear();
            for (final Integer id : DimensionManager.dimensions.keySet()) {
                if (id >= 0) {
                    DimensionManager.dimensionMap.set(id);
                }
            }
        }
        else {
            final int[] intArray = compoundTag.k("DimensionArray");
            for (int i = 0; i < intArray.length; ++i) {
                for (int j = 0; j < 32; ++j) {
                    DimensionManager.dimensionMap.set(i * 32 + j, (intArray[i] & 1 << j) != 0x0);
                }
            }
        }
    }
    
    public static File getCurrentSaveRootDirectory() {
        if (getWorld(0) != null) {
            return ((alq)getWorld(0).M()).b();
        }
        if (MinecraftServer.F() != null) {
            final MinecraftServer srv = MinecraftServer.F();
            final alq saveHandler = (alq)srv.P().a(srv.L(), false);
            return saveHandler.b();
        }
        return null;
    }
    
    static {
        DimensionManager.providers = new Hashtable<Integer, Class<? extends aei>>();
        DimensionManager.spawnSettings = new Hashtable<Integer, Boolean>();
        DimensionManager.worlds = new Hashtable<Integer, js>();
        DimensionManager.hasInit = false;
        DimensionManager.dimensions = new Hashtable<Integer, Integer>();
        DimensionManager.unloadQueue = new ArrayList<Integer>();
        DimensionManager.dimensionMap = new BitSet(1024);
        DimensionManager.weakWorldMap = new MapMaker().weakKeys().weakValues().makeMap();
        DimensionManager.leakedWorlds = (Multiset<Integer>)HashMultiset.create();
        init();
    }
}



================================================
FILE: net/minecraftforge/common/DungeonHooks.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import java.util.Collection;
import java.util.Random;
import java.util.Iterator;
import java.util.ArrayList;

public class DungeonHooks
{
    private static ArrayList<DungeonMob> dungeonMobs;
    
    public static float addDungeonMob(final String name, final int rarity) {
        if (rarity <= 0) {
            throw new IllegalArgumentException("Rarity must be greater then zero");
        }
        for (final DungeonMob mob : DungeonHooks.dungeonMobs) {
            if (name.equals(mob.type)) {
                final DungeonMob dungeonMob = mob;
                final int a = dungeonMob.a + rarity;
                dungeonMob.a = a;
                return (float)a;
            }
        }
        DungeonHooks.dungeonMobs.add(new DungeonMob(rarity, name));
        return (float)rarity;
    }
    
    public static int removeDungeonMob(final String name) {
        for (final DungeonMob mob : DungeonHooks.dungeonMobs) {
            if (name.equals(mob.type)) {
                DungeonHooks.dungeonMobs.remove(mob);
                return mob.a;
            }
        }
        return 0;
    }
    
    public static String getRandomDungeonMob(final Random rand) {
        final DungeonMob mob = (DungeonMob)mi.a(rand, (Collection)DungeonHooks.dungeonMobs);
        if (mob == null) {
            return "";
        }
        return mob.type;
    }
    
    static {
        DungeonHooks.dungeonMobs = new ArrayList<DungeonMob>();
        addDungeonMob("Skeleton", 100);
        addDungeonMob("Zombie", 200);
        addDungeonMob("Spider", 100);
    }
    
    public static class DungeonMob extends mj
    {
        public String type;
        
        public DungeonMob(final int weight, final String type) {
            super(weight);
            this.type = type;
        }
        
        public boolean equals(final Object target) {
            return target instanceof DungeonMob && this.type.equals(((DungeonMob)target).type);
        }
    }
}



================================================
FILE: net/minecraftforge/common/EnumHelper.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import java.util.List;
import java.lang.reflect.Array;
import java.util.Collection;
import java.util.ArrayList;
import java.util.Arrays;
import cpw.mods.fml.common.FMLLog;
import net.minecraftforge.classloading.FMLForgePlugin;
import java.lang.reflect.Field;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

public class EnumHelper
{
    private static Object reflectionFactory;
    private static Method newConstructorAccessor;
    private static Method newInstance;
    private static Method newFieldAccessor;
    private static Method fieldAccessorSet;
    private static boolean isSetup;
    private static Class[][] commonTypes;
    
    public static zj addAction(final String name) {
        return addEnum(zj.class, name, new Object[0]);
    }
    
    public static wj addArmorMaterial(final String name, final int durability, final int[] reductionAmounts, final int enchantability) {
        return addEnum(wj.class, name, durability, reductionAmounts, enchantability);
    }
    
    public static om addArt(final String name, final String tile, final int sizeX, final int sizeY, final int offsetX, final int offsetY) {
        return addEnum(om.class, name, tile, sizeX, sizeY, offsetX, offsetY);
    }
    
    public static oj addCreatureAttribute(final String name) {
        return addEnum(oj.class, name, new Object[0]);
    }
    
    public static oh addCreatureType(final String name, final Class typeClass, final int maxNumber, final akc material, final boolean peaceful) {
        return addEnum(oh.class, name, typeClass, maxNumber, material, peaceful);
    }
    
    public static aim addDoor(final String name) {
        return addEnum(aim.class, name, new Object[0]);
    }
    
    public static aav addEnchantmentType(final String name) {
        return addEnum(aav.class, name, new Object[0]);
    }
    
    public static nr addEntitySize(final String name) {
        return addEnum(nr.class, name, new Object[0]);
    }
    
    public static apx addMobType(final String name) {
        return addEnum(apx.class, name, new Object[0]);
    }
    
    public static atb addMovingObjectType(final String name) {
        if (!EnumHelper.isSetup) {
            setup();
        }
        return addEnum(atb.class, name, new Object[0]);
    }
    
    public static ach addSkyBlock(final String name, final int lightValue) {
        return addEnum(ach.class, name, lightValue);
    }
    
    public static ug addStatus(final String name) {
        return addEnum(ug.class, name, new Object[0]);
    }
    
    public static yd addToolMaterial(final String name, final int harvestLevel, final int maxUses, final float efficiency, final float damage, final int enchantability) {
        return addEnum(yd.class, name, harvestLevel, maxUses, efficiency, damage, enchantability);
    }
    
    private static void setup() {
        if (EnumHelper.isSetup) {
            return;
        }
        try {
            final Method getReflectionFactory = Class.forName("sun.reflect.ReflectionFactory").getDeclaredMethod("getReflectionFactory", (Class<?>[])new Class[0]);
            EnumHelper.reflectionFactory = getReflectionFactory.invoke(null, new Object[0]);
            EnumHelper.newConstructorAccessor = Class.forName("sun.reflect.ReflectionFactory").getDeclaredMethod("newConstructorAccessor", Constructor.class);
            EnumHelper.newInstance = Class.forName("sun.reflect.ConstructorAccessor").getDeclaredMethod("newInstance", Object[].class);
            EnumHelper.newFieldAccessor = Class.forName("sun.reflect.ReflectionFactory").getDeclaredMethod("newFieldAccessor", Field.class, Boolean.TYPE);
            EnumHelper.fieldAccessorSet = Class.forName("sun.reflect.FieldAccessor").getDeclaredMethod("set", Object.class, Object.class);
        }
        catch (final Exception e) {
            e.printStackTrace();
        }
        EnumHelper.isSetup = true;
    }
    
    private static Object getConstructorAccessor(final Class<?> enumClass, final Class<?>[] additionalParameterTypes) throws Exception {
        final Class<?>[] parameterTypes = new Class[additionalParameterTypes.length + 2];
        parameterTypes[0] = String.class;
        parameterTypes[1] = Integer.TYPE;
        System.arraycopy(additionalParameterTypes, 0, parameterTypes, 2, additionalParameterTypes.length);
        return EnumHelper.newConstructorAccessor.invoke(EnumHelper.reflectionFactory, enumClass.getDeclaredConstructor(parameterTypes));
    }
    
    private static <T extends Enum<?>> T makeEnum(final Class<T> enumClass, final String value, final int ordinal, final Class<?>[] additionalTypes, final Object[] additionalValues) throws Exception {
        final Object[] parms = new Object[additionalValues.length + 2];
        parms[0] = value;
        parms[1] = ordinal;
        System.arraycopy(additionalValues, 0, parms, 2, additionalValues.length);
        return enumClass.cast(EnumHelper.newInstance.invoke(getConstructorAccessor(enumClass, additionalTypes), parms));
    }
    
    public static void setFailsafeFieldValue(final Field field, final Object target, final Object value) throws Exception {
        field.setAccessible(true);
        final Field modifiersField = Field.class.getDeclaredField("modifiers");
        modifiersField.setAccessible(true);
        modifiersField.setInt(field, field.getModifiers() & 0xFFFFFFEF);
        final Object fieldAccessor = EnumHelper.newFieldAccessor.invoke(EnumHelper.reflectionFactory, field, false);
        EnumHelper.fieldAccessorSet.invoke(fieldAccessor, target, value);
    }
    
    private static void blankField(final Class<?> enumClass, final String fieldName) throws Exception {
        for (final Field field : Class.class.getDeclaredFields()) {
            if (field.getName().contains(fieldName)) {
                field.setAccessible(true);
                setFailsafeFieldValue(field, enumClass, null);
                break;
            }
        }
    }
    
    private static void cleanEnumCache(final Class<?> enumClass) throws Exception {
        blankField(enumClass, "enumConstantDirectory");
        blankField(enumClass, "enumConstants");
    }
    
    public static <T extends Enum<?>> T addEnum(final Class<T> enumType, final String enumName, final Object... paramValues) {
        return addEnum(EnumHelper.commonTypes, enumType, enumName, paramValues);
    }
    
    public static <T extends Enum<?>> T addEnum(final Class[][] map, final Class<T> enumType, final String enumName, final Object... paramValues) {
        for (final Class[] lookup : map) {
            if (lookup[0] == enumType) {
                final Class<?>[] paramTypes = new Class[lookup.length - 1];
                if (paramTypes.length > 0) {
                    System.arraycopy(lookup, 1, paramTypes, 0, paramTypes.length);
                }
                return addEnum(enumType, enumName, paramTypes, paramValues);
            }
        }
        return null;
    }
    
    public static <T extends Enum<?>> T addEnum(final Class<T> enumType, final String enumName, final Class<?>[] paramTypes, final Object[] paramValues) {
        if (!EnumHelper.isSetup) {
            setup();
        }
        Field valuesField = null;
        final Field[] arr$;
        final Field[] fields = arr$ = enumType.getDeclaredFields();
        for (final Field field : arr$) {
            final String name = field.getName();
            if (name.equals("$VALUES") || name.equals("ENUM$VALUES")) {
                valuesField = field;
                break;
            }
        }
        final int flags = (FMLForgePlugin.RUNTIME_DEOBF ? 1 : 2) | 0x8 | 0x10 | 0x1000;
        if (valuesField == null) {
            final String valueType = String.format("[L%s;", enumType.getName().replace('.', '/'));
            for (final Field field2 : fields) {
                if ((field2.getModifiers() & flags) == flags && field2.getType().getName().replace('.', '/').equals(valueType)) {
                    valuesField = field2;
                    break;
                }
            }
        }
        if (valuesField == null) {
            FMLLog.severe("Could not find $VALUES field for enum: %s", enumType.getName());
            FMLLog.severe("Runtime Deobf: %s", FMLForgePlugin.RUNTIME_DEOBF);
            FMLLog.severe("Flags: %s", String.format("%16s", Integer.toBinaryString(flags)).replace(' ', '0'));
            FMLLog.severe("Fields:", new Object[0]);
            for (final Field field3 : fields) {
                final String mods = String.format("%16s", Integer.toBinaryString(field3.getModifiers())).replace(' ', '0');
                FMLLog.severe("       %s %s: %s", mods, field3.getName(), field3.getType().getName());
            }
            return null;
        }
        valuesField.setAccessible(true);
        try {
            final T[] previousValues = (T[])valuesField.get(enumType);
            final List<T> values = new ArrayList<T>((Collection<? extends T>)Arrays.asList(previousValues));
            final T newValue = makeEnum(enumType, enumName, values.size(), paramTypes, paramValues);
            values.add(newValue);
            setFailsafeFieldValue(valuesField, null, values.toArray((Enum[])Array.newInstance(enumType, 0)));
            cleanEnumCache(enumType);
            return newValue;
        }
        catch (final Exception e) {
            e.printStackTrace();
            throw new RuntimeException(e.getMessage(), e);
        }
    }
    
    static {
        EnumHelper.reflectionFactory = null;
        EnumHelper.newConstructorAccessor = null;
        EnumHelper.newInstance = null;
        EnumHelper.newFieldAccessor = null;
        EnumHelper.fieldAccessorSet = null;
        EnumHelper.isSetup = false;
        EnumHelper.commonTypes = new Class[][] { { zj.class }, { wj.class, Integer.TYPE, int[].class, Integer.TYPE }, { om.class, String.class, Integer.TYPE, Integer.TYPE, Integer.TYPE, Integer.TYPE }, { oj.class }, { oh.class, Class.class, Integer.TYPE, akc.class, Boolean.TYPE }, { aim.class }, { aav.class }, { nr.class }, { apx.class }, { atb.class }, { ach.class, Integer.TYPE }, { ug.class }, { yd.class, Integer.TYPE, Integer.TYPE, Float.TYPE, Float.TYPE, Integer.TYPE } };
        if (!EnumHelper.isSetup) {
            setup();
        }
    }
}



================================================
FILE: net/minecraftforge/common/EnumPlantType.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

public enum EnumPlantType
{
    Plains, 
    Desert, 
    Beach, 
    Cave, 
    Water, 
    Nether, 
    Crop;
}



================================================
FILE: net/minecraftforge/common/FakePlayer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import cpw.mods.fml.common.FMLCommonHandler;

public class FakePlayer extends jv
{
    public FakePlayer(final abw world, final String name) {
        super(FMLCommonHandler.instance().getMinecraftServerInstance(), world, name, new jw(world));
    }
    
    public void sendChatToPlayer(final String s) {
    }
    
    public boolean a(final int i, final String s) {
        return false;
    }
    
    public t b() {
        return new t(0, 0, 0);
    }
    
    public void a(final cv chatmessagecomponent) {
    }
    
    public void a(final ku par1StatBase, final int par2) {
    }
    
    public void openGui(final Object mod, final int modGuiId, final abw world, final int x, final int y, final int z) {
    }
    
    public boolean ar() {
        return true;
    }
    
    public boolean a(final uf player) {
        return false;
    }
    
    public void a(final nb source) {
    }
    
    public void l_() {
    }
    
    public void b(final int dim) {
    }
    
    public void a(final dp pkt) {
    }
}



================================================
FILE: net/minecraftforge/common/FakePlayerFactory.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import java.util.HashMap;
import java.util.Map;

public class FakePlayerFactory
{
    private static Map<String, FakePlayer> fakePlayers;
    private static FakePlayer MINECRAFT_PLAYER;
    
    public static FakePlayer getMinecraft(final abw world) {
        if (FakePlayerFactory.MINECRAFT_PLAYER == null) {
            FakePlayerFactory.MINECRAFT_PLAYER = get(world, "[Minecraft]");
        }
        return FakePlayerFactory.MINECRAFT_PLAYER;
    }
    
    public static FakePlayer get(final abw world, final String username) {
        if (!FakePlayerFactory.fakePlayers.containsKey(username)) {
            final FakePlayer fakePlayer = new FakePlayer(world, username);
            FakePlayerFactory.fakePlayers.put(username, fakePlayer);
        }
        return FakePlayerFactory.fakePlayers.get(username);
    }
    
    static {
        FakePlayerFactory.fakePlayers = new HashMap<String, FakePlayer>();
        FakePlayerFactory.MINECRAFT_PLAYER = null;
    }
}



================================================
FILE: net/minecraftforge/common/ForgeChunkManager.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import java.util.LinkedHashSet;
import com.google.common.collect.Sets;
import com.google.common.collect.HashBiMap;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.MapMaker;
import com.google.common.collect.LinkedHashMultimap;
import net.minecraftforge.event.Event;
import cpw.mods.fml.common.ModContainer;
import net.minecraft.server.MinecraftServer;
import java.util.Iterator;
import com.google.common.collect.ImmutableListMultimap;
import java.util.List;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ListMultimap;
import cpw.mods.fml.common.Loader;
import cpw.mods.fml.common.FMLLog;
import java.util.logging.Level;
import com.google.common.collect.Maps;
import com.google.common.cache.CacheBuilder;
import com.google.common.collect.ArrayListMultimap;
import java.io.IOException;
import java.util.Set;
import java.io.File;
import com.google.common.cache.Cache;
import java.util.UUID;
import com.google.common.collect.BiMap;
import com.google.common.collect.ImmutableSetMultimap;
import com.google.common.collect.SetMultimap;
import com.google.common.collect.Multimap;
import java.util.Map;

public class ForgeChunkManager
{
    private static int defaultMaxCount;
    private static int defaultMaxChunks;
    private static boolean overridesEnabled;
    private static Map<abw, Multimap<String, Ticket>> tickets;
    private static Map<String, Integer> ticketConstraints;
    private static Map<String, Integer> chunkConstraints;
    private static SetMultimap<String, Ticket> playerTickets;
    private static Map<String, LoadingCallback> callbacks;
    private static Map<abw, ImmutableSetMultimap<abp, Ticket>> forcedChunks;
    private static BiMap<UUID, Ticket> pendingEntities;
    private static Map<abw, Cache<Long, adr>> dormantChunkCache;
    private static File cfgFile;
    private static Configuration config;
    private static int playerTicketLength;
    private static int dormantChunkCacheSize;
    private static Set<String> warnedMods;
    
    public static boolean savedWorldHasForcedChunkTickets(final File chunkDir) {
        final File chunkLoaderData = new File(chunkDir, "forcedchunks.dat");
        if (chunkLoaderData.exists() && chunkLoaderData.isFile()) {
            try {
                final by forcedChunkData = ci.a(chunkLoaderData);
                return forcedChunkData.m("TicketList").c() > 0;
            }
            catch (final IOException ex) {}
        }
        return false;
    }
    
    static void loadWorld(final abw world) {
        final ArrayListMultimap<String, Ticket> newTickets = (ArrayListMultimap<String, Ticket>)ArrayListMultimap.create();
        ForgeChunkManager.tickets.put(world, (Multimap<String, Ticket>)newTickets);
        ForgeChunkManager.forcedChunks.put(world, (ImmutableSetMultimap<abp, Ticket>)ImmutableSetMultimap.of());
        if (!(world instanceof js)) {
            return;
        }
        ForgeChunkManager.dormantChunkCache.put(world, (Cache<Long, adr>)CacheBuilder.newBuilder().maximumSize((long)ForgeChunkManager.dormantChunkCacheSize).build());
        final js worldServer = (js)world;
        final File chunkDir = worldServer.getChunkSaveLocation();
        final File chunkLoaderData = new File(chunkDir, "forcedchunks.dat");
        if (chunkLoaderData.exists() && chunkLoaderData.isFile()) {
            final ArrayListMultimap<String, Ticket> loadedTickets = (ArrayListMultimap<String, Ticket>)ArrayListMultimap.create();
            final Map<String, ListMultimap<String, Ticket>> playerLoadedTickets = Maps.newHashMap();
            by forcedChunkData;
            try {
                forcedChunkData = ci.a(chunkLoaderData);
            }
            catch (final IOException e) {
                FMLLog.log(Level.WARNING, e, "Unable to read forced chunk data at %s - it will be ignored", chunkLoaderData.getAbsolutePath());
                return;
            }
            final cg ticketList = forcedChunkData.m("TicketList");
            for (int i = 0; i < ticketList.c(); ++i) {
                final by ticketHolder = (by)ticketList.b(i);
                String modId = ticketHolder.i("Owner");
                final boolean isPlayer = "Forge".equals(modId);
                if (!isPlayer && !Loader.isModLoaded(modId)) {
                    FMLLog.warning("Found chunkloading data for mod %s which is currently not available or active - it will be removed from the world save", modId);
                }
                else if (!isPlayer && !ForgeChunkManager.callbacks.containsKey(modId)) {
                    FMLLog.warning("The mod %s has registered persistent chunkloading data but doesn't seem to want to be called back with it - it will be removed from the world save", modId);
                }
                else {
                    final cg tickets = ticketHolder.m("Tickets");
                    for (int j = 0; j < tickets.c(); ++j) {
                        final by ticket = (by)tickets.b(j);
                        modId = (ticket.b("ModId") ? ticket.i("ModId") : modId);
                        final Type type = Type.values()[ticket.c("Type")];
                        final byte ticketChunkDepth = ticket.c("ChunkListDepth");
                        final Ticket tick = new Ticket(modId, type, world);
                        if (ticket.b("ModData")) {
                            tick.modData = ticket.l("ModData");
                        }
                        if (ticket.b("Player")) {
                            tick.player = ticket.i("Player");
                            if (!playerLoadedTickets.containsKey(tick.modId)) {
                                playerLoadedTickets.put(modId, (ListMultimap<String, Ticket>)ArrayListMultimap.create());
                            }
                            playerLoadedTickets.get(tick.modId).put((Object)tick.player, (Object)tick);
                        }
                        else {
                            loadedTickets.put((Object)modId, (Object)tick);
                        }
                        if (type == Type.ENTITY) {
                            tick.entityChunkX = ticket.e("chunkX");
                            tick.entityChunkZ = ticket.e("chunkZ");
                            final UUID uuid = new UUID(ticket.f("PersistentIDMSB"), ticket.f("PersistentIDLSB"));
                            ForgeChunkManager.pendingEntities.put((Object)uuid, (Object)tick);
                        }
                    }
                }
            }
            for (final Ticket tick2 : ImmutableSet.copyOf((Collection)ForgeChunkManager.pendingEntities.values())) {
                if (tick2.ticketType == Type.ENTITY && tick2.entity == null) {
                    world.e(tick2.entityChunkX, tick2.entityChunkZ);
                }
            }
            for (final Ticket tick2 : ImmutableSet.copyOf((Collection)ForgeChunkManager.pendingEntities.values())) {
                if (tick2.ticketType == Type.ENTITY && tick2.entity == null) {
                    FMLLog.warning("Failed to load persistent chunkloading entity %s from store.", ForgeChunkManager.pendingEntities.inverse().get((Object)tick2));
                    loadedTickets.remove((Object)tick2.modId, (Object)tick2);
                }
            }
            ForgeChunkManager.pendingEntities.clear();
            for (final String modId2 : loadedTickets.keySet()) {
                final LoadingCallback loadingCallback = ForgeChunkManager.callbacks.get(modId2);
                if (loadingCallback == null) {
                    continue;
                }
                final int maxTicketLength = getMaxTicketLengthFor(modId2);
                List<Ticket> tickets2 = loadedTickets.get((Object)modId2);
                if (loadingCallback instanceof OrderedLoadingCallback) {
                    final OrderedLoadingCallback orderedLoadingCallback = (OrderedLoadingCallback)loadingCallback;
                    tickets2 = orderedLoadingCallback.ticketsLoaded((List<Ticket>)ImmutableList.copyOf((Collection)tickets2), world, maxTicketLength);
                }
                if (tickets2.size() > maxTicketLength) {
                    FMLLog.warning("The mod %s has too many open chunkloading tickets %d. Excess will be dropped", modId2, tickets2.size());
                    tickets2.subList(maxTicketLength, tickets2.size()).clear();
                }
                ForgeChunkManager.tickets.get(world).putAll((Object)modId2, (Iterable)tickets2);
                loadingCallback.ticketsLoaded((List<Ticket>)ImmutableList.copyOf((Collection)tickets2), world);
            }
            for (final String modId2 : playerLoadedTickets.keySet()) {
                final LoadingCallback loadingCallback = ForgeChunkManager.callbacks.get(modId2);
                if (loadingCallback == null) {
                    continue;
                }
                ListMultimap<String, Ticket> tickets3 = playerLoadedTickets.get(modId2);
                if (loadingCallback instanceof PlayerOrderedLoadingCallback) {
                    final PlayerOrderedLoadingCallback orderedLoadingCallback2 = (PlayerOrderedLoadingCallback)loadingCallback;
                    tickets3 = orderedLoadingCallback2.playerTicketsLoaded((ListMultimap<String, Ticket>)ImmutableListMultimap.copyOf((Multimap)tickets3), world);
                    ForgeChunkManager.playerTickets.putAll((Multimap)tickets3);
                }
                ForgeChunkManager.tickets.get(world).putAll((Object)"Forge", (Iterable)tickets3.values());
                loadingCallback.ticketsLoaded((List<Ticket>)ImmutableList.copyOf(tickets3.values()), world);
            }
        }
    }
    
    static void unloadWorld(final abw world) {
        if (!(world instanceof js)) {
            return;
        }
        ForgeChunkManager.forcedChunks.remove(world);
        ForgeChunkManager.dormantChunkCache.remove(world);
        if (!MinecraftServer.F().o()) {
            ForgeChunkManager.playerTickets.clear();
            ForgeChunkManager.tickets.clear();
        }
    }
    
    public static void setForcedChunkLoadingCallback(final Object mod, final LoadingCallback callback) {
        final ModContainer container = getContainer(mod);
        if (container == null) {
            FMLLog.warning("Unable to register a callback for an unknown mod %s (%s : %x)", mod, mod.getClass().getName(), System.identityHashCode(mod));
            return;
        }
        ForgeChunkManager.callbacks.put(container.getModId(), callback);
    }
    
    public static int ticketCountAvailableFor(final Object mod, final abw world) {
        final ModContainer container = getContainer(mod);
        if (container != null) {
            final String modId = container.getModId();
            final int allowedCount = getMaxTicketLengthFor(modId);
            return allowedCount - ForgeChunkManager.tickets.get(world).get((Object)modId).size();
        }
        return 0;
    }
    
    private static ModContainer getContainer(final Object mod) {
        final ModContainer container = (ModContainer)Loader.instance().getModObjectList().inverse().get(mod);
        return container;
    }
    
    public static int getMaxTicketLengthFor(final String modId) {
        final int allowedCount = (ForgeChunkManager.ticketConstraints.containsKey(modId) && ForgeChunkManager.overridesEnabled) ? ForgeChunkManager.ticketConstraints.get(modId) : ForgeChunkManager.defaultMaxCount;
        return allowedCount;
    }
    
    public static int getMaxChunkDepthFor(final String modId) {
        final int allowedCount = (ForgeChunkManager.chunkConstraints.containsKey(modId) && ForgeChunkManager.overridesEnabled) ? ForgeChunkManager.chunkConstraints.get(modId) : ForgeChunkManager.defaultMaxChunks;
        return allowedCount;
    }
    
    public static int ticketCountAvailableFor(final String username) {
        return ForgeChunkManager.playerTicketLength - ForgeChunkManager.playerTickets.get((Object)username).size();
    }
    
    public static Ticket requestPlayerTicket(final Object mod, final String player, final abw world, final Type type) {
        final ModContainer mc = getContainer(mod);
        if (mc == null) {
            FMLLog.log(Level.SEVERE, "Failed to locate the container for mod instance %s (%s : %x)", mod, mod.getClass().getName(), System.identityHashCode(mod));
            return null;
        }
        if (ForgeChunkManager.playerTickets.get((Object)player).size() > ForgeChunkManager.playerTicketLength) {
            FMLLog.warning("Unable to assign further chunkloading tickets to player %s (on behalf of mod %s)", player, mc.getModId());
            return null;
        }
        final Ticket ticket = new Ticket(mc.getModId(), type, world, player);
        ForgeChunkManager.playerTickets.put((Object)player, (Object)ticket);
        ForgeChunkManager.tickets.get(world).put((Object)"Forge", (Object)ticket);
        return ticket;
    }
    
    public static Ticket requestTicket(final Object mod, final abw world, final Type type) {
        final ModContainer container = getContainer(mod);
        if (container == null) {
            FMLLog.log(Level.SEVERE, "Failed to locate the container for mod instance %s (%s : %x)", mod, mod.getClass().getName(), System.identityHashCode(mod));
            return null;
        }
        final String modId = container.getModId();
        if (!ForgeChunkManager.callbacks.containsKey(modId)) {
            FMLLog.severe("The mod %s has attempted to request a ticket without a listener in place", modId);
            throw new RuntimeException("Invalid ticket request");
        }
        final int allowedCount = ForgeChunkManager.ticketConstraints.containsKey(modId) ? ForgeChunkManager.ticketConstraints.get(modId) : ForgeChunkManager.defaultMaxCount;
        if (ForgeChunkManager.tickets.get(world).get((Object)modId).size() >= allowedCount) {
            if (!ForgeChunkManager.warnedMods.contains(modId)) {
                FMLLog.info("The mod %s has attempted to allocate a chunkloading ticket beyond it's currently allocated maximum : %d", modId, allowedCount);
                ForgeChunkManager.warnedMods.add(modId);
            }
            return null;
        }
        final Ticket ticket = new Ticket(modId, type, world);
        ForgeChunkManager.tickets.get(world).put((Object)modId, (Object)ticket);
        return ticket;
    }
    
    public static void releaseTicket(final Ticket ticket) {
        if (ticket == null) {
            return;
        }
        Label_0056: {
            if (ticket.isPlayerTicket()) {
                if (ForgeChunkManager.playerTickets.containsValue((Object)ticket)) {
                    break Label_0056;
                }
            }
            else if (ForgeChunkManager.tickets.get(ticket.world).containsEntry((Object)ticket.modId, (Object)ticket)) {
                break Label_0056;
            }
            return;
        }
        if (ticket.requestedChunks != null) {
            for (final abp chunk : ImmutableSet.copyOf((Collection)ticket.requestedChunks)) {
                unforceChunk(ticket, chunk);
            }
        }
        if (ticket.isPlayerTicket()) {
            ForgeChunkManager.playerTickets.remove((Object)ticket.player, (Object)ticket);
            ForgeChunkManager.tickets.get(ticket.world).remove((Object)"Forge", (Object)ticket);
        }
        else {
            ForgeChunkManager.tickets.get(ticket.world).remove((Object)ticket.modId, (Object)ticket);
        }
    }
    
    public static void forceChunk(final Ticket ticket, final abp chunk) {
        if (ticket == null || chunk == null) {
            return;
        }
        if (ticket.ticketType == Type.ENTITY && ticket.entity == null) {
            throw new RuntimeException("Attempted to use an entity ticket to force a chunk, without an entity");
        }
        Label_0105: {
            if (ticket.isPlayerTicket()) {
                if (ForgeChunkManager.playerTickets.containsValue((Object)ticket)) {
                    break Label_0105;
                }
            }
            else if (ForgeChunkManager.tickets.get(ticket.world).containsEntry((Object)ticket.modId, (Object)ticket)) {
                break Label_0105;
            }
            FMLLog.severe("The mod %s attempted to force load a chunk with an invalid ticket. This is not permitted.", ticket.modId);
            return;
        }
        ticket.requestedChunks.add(chunk);
        MinecraftForge.EVENT_BUS.post(new ForceChunkEvent(ticket, chunk));
        final ImmutableSetMultimap<abp, Ticket> newMap = (ImmutableSetMultimap<abp, Ticket>)ImmutableSetMultimap.builder().putAll((Multimap)ForgeChunkManager.forcedChunks.get(ticket.world)).put((Object)chunk, (Object)ticket).build();
        ForgeChunkManager.forcedChunks.put(ticket.world, newMap);
        if (ticket.maxDepth > 0 && ticket.requestedChunks.size() > ticket.maxDepth) {
            final abp removed = (abp)ticket.requestedChunks.iterator().next();
            unforceChunk(ticket, removed);
        }
    }
    
    public static void reorderChunk(final Ticket ticket, final abp chunk) {
        if (ticket == null || chunk == null || !ticket.requestedChunks.contains(chunk)) {
            return;
        }
        ticket.requestedChunks.remove(chunk);
        ticket.requestedChunks.add(chunk);
    }
    
    public static void unforceChunk(final Ticket ticket, final abp chunk) {
        if (ticket == null || chunk == null) {
            return;
        }
        ticket.requestedChunks.remove(chunk);
        MinecraftForge.EVENT_BUS.post(new UnforceChunkEvent(ticket, chunk));
        final LinkedHashMultimap<abp, Ticket> copy = (LinkedHashMultimap<abp, Ticket>)LinkedHashMultimap.create((Multimap)ForgeChunkManager.forcedChunks.get(ticket.world));
        copy.remove((Object)chunk, (Object)ticket);
        final ImmutableSetMultimap<abp, Ticket> newMap = (ImmutableSetMultimap<abp, Ticket>)ImmutableSetMultimap.copyOf((Multimap)copy);
        ForgeChunkManager.forcedChunks.put(ticket.world, newMap);
    }
    
    static void loadConfiguration() {
        for (final String mod : ForgeChunkManager.config.getCategoryNames()) {
            if (!mod.equals("Forge")) {
                if (mod.equals("defaults")) {
                    continue;
                }
                final Property modTC = ForgeChunkManager.config.get(mod, "maximumTicketCount", 200);
                final Property modCPT = ForgeChunkManager.config.get(mod, "maximumChunksPerTicket", 25);
                ForgeChunkManager.ticketConstraints.put(mod, modTC.getInt(200));
                ForgeChunkManager.chunkConstraints.put(mod, modCPT.getInt(25));
            }
        }
        if (ForgeChunkManager.config.hasChanged()) {
            ForgeChunkManager.config.save();
        }
    }
    
    public static ImmutableSetMultimap<abp, Ticket> getPersistentChunksFor(final abw world) {
        return (ImmutableSetMultimap<abp, Ticket>)(ForgeChunkManager.forcedChunks.containsKey(world) ? ForgeChunkManager.forcedChunks.get(world) : ImmutableSetMultimap.of());
    }
    
    static void saveWorld(final abw world) {
        if (!(world instanceof js)) {
            return;
        }
        final js worldServer = (js)world;
        final File chunkDir = worldServer.getChunkSaveLocation();
        final File chunkLoaderData = new File(chunkDir, "forcedchunks.dat");
        final by forcedChunkData = new by();
        final cg ticketList = new cg();
        forcedChunkData.a("TicketList", (cl)ticketList);
        final Multimap<String, Ticket> ticketSet = ForgeChunkManager.tickets.get(worldServer);
        for (final String modId : ticketSet.keySet()) {
            final by ticketHolder = new by();
            ticketList.a((cl)ticketHolder);
            ticketHolder.a("Owner", modId);
            final cg tickets = new cg();
            ticketHolder.a("Tickets", (cl)tickets);
            for (final Ticket tick : ticketSet.get((Object)modId)) {
                final by ticket = new by();
                ticket.a("Type", (byte)tick.ticketType.ordinal());
                ticket.a("ChunkListDepth", (byte)tick.maxDepth);
                if (tick.isPlayerTicket()) {
                    ticket.a("ModId", tick.modId);
                    ticket.a("Player", tick.player);
                }
                if (tick.modData != null) {
                    ticket.a("ModData", tick.modData);
                }
                if (tick.ticketType == Type.ENTITY && tick.entity != null && tick.entity.d(new by())) {
                    ticket.a("chunkX", ls.c((double)tick.entity.aj));
                    ticket.a("chunkZ", ls.c((double)tick.entity.al));
                    ticket.a("PersistentIDMSB", tick.entity.getPersistentID().getMostSignificantBits());
                    ticket.a("PersistentIDLSB", tick.entity.getPersistentID().getLeastSignificantBits());
                    tickets.a((cl)ticket);
                }
                else {
                    if (tick.ticketType == Type.ENTITY) {
                        continue;
                    }
                    tickets.a((cl)ticket);
                }
            }
        }
        try {
            ci.b(forcedChunkData, chunkLoaderData);
        }
        catch (final IOException e) {
            FMLLog.log(Level.WARNING, e, "Unable to write forced chunk data to %s - chunkloading won't work", chunkLoaderData.getAbsolutePath());
        }
    }
    
    static void loadEntity(final nn entity) {
        final UUID id = entity.getPersistentID();
        final Ticket tick = (Ticket)ForgeChunkManager.pendingEntities.get((Object)id);
        if (tick != null) {
            tick.bindEntity(entity);
            ForgeChunkManager.pendingEntities.remove((Object)id);
        }
    }
    
    public static void putDormantChunk(final long coords, final adr chunk) {
        final Cache<Long, adr> cache = ForgeChunkManager.dormantChunkCache.get(chunk.e);
        if (cache != null) {
            cache.put((Object)coords, (Object)chunk);
        }
    }
    
    public static adr fetchDormantChunk(final long coords, final abw world) {
        final Cache<Long, adr> cache = ForgeChunkManager.dormantChunkCache.get(world);
        if (cache == null) {
            return null;
        }
        final adr chunk = (adr)cache.getIfPresent((Object)coords);
        if (chunk != null) {
            for (final List<nn> eList : chunk.j) {
                for (final nn e : eList) {
                    e.resetEntityId();
                }
            }
        }
        return chunk;
    }
    
    static void captureConfig(final File configDir) {
        ForgeChunkManager.cfgFile = new File(configDir, "forgeChunkLoading.cfg");
        ForgeChunkManager.config = new Configuration(ForgeChunkManager.cfgFile, true);
        try {
            ForgeChunkManager.config.load();
        }
        catch (final Exception e) {
            final File dest = new File(ForgeChunkManager.cfgFile.getParentFile(), "forgeChunkLoading.cfg.bak");
            if (dest.exists()) {
                dest.delete();
            }
            ForgeChunkManager.cfgFile.renameTo(dest);
            FMLLog.log(Level.SEVERE, e, "A critical error occured reading the forgeChunkLoading.cfg file, defaults will be used - the invalid file is backed up at forgeChunkLoading.cfg.bak", new Object[0]);
        }
        ForgeChunkManager.config.addCustomCategoryComment("defaults", "Default configuration for forge chunk loading control");
        final Property maxTicketCount = ForgeChunkManager.config.get("defaults", "maximumTicketCount", 200);
        maxTicketCount.comment = "The default maximum ticket count for a mod which does not have an override\nin this file. This is the number of chunk loading requests a mod is allowed to make.";
        ForgeChunkManager.defaultMaxCount = maxTicketCount.getInt(200);
        final Property maxChunks = ForgeChunkManager.config.get("defaults", "maximumChunksPerTicket", 25);
        maxChunks.comment = "The default maximum number of chunks a mod can force, per ticket, \nfor a mod without an override. This is the maximum number of chunks a single ticket can force.";
        ForgeChunkManager.defaultMaxChunks = maxChunks.getInt(25);
        final Property playerTicketCount = ForgeChunkManager.config.get("defaults", "playerTicketCount", 500);
        playerTicketCount.comment = "The number of tickets a player can be assigned instead of a mod. This is shared across all mods and it is up to the mods to use it.";
        ForgeChunkManager.playerTicketLength = playerTicketCount.getInt(500);
        final Property dormantChunkCacheSizeProperty = ForgeChunkManager.config.get("defaults", "dormantChunkCacheSize", 0);
        dormantChunkCacheSizeProperty.comment = "Unloaded chunks can first be kept in a dormant cache for quicker\nloading times. Specify the size (in chunks) of that cache here";
        ForgeChunkManager.dormantChunkCacheSize = dormantChunkCacheSizeProperty.getInt(0);
        FMLLog.info("Configured a dormant chunk cache size of %d", dormantChunkCacheSizeProperty.getInt(0));
        final Property modOverridesEnabled = ForgeChunkManager.config.get("defaults", "enabled", true);
        modOverridesEnabled.comment = "Are mod overrides enabled?";
        ForgeChunkManager.overridesEnabled = modOverridesEnabled.getBoolean(true);
        ForgeChunkManager.config.addCustomCategoryComment("Forge", "Sample mod specific control section.\nCopy this section and rename the with the modid for the mod you wish to override.\nA value of zero in either entry effectively disables any chunkloading capabilities\nfor that mod");
        Property sampleTC = ForgeChunkManager.config.get("Forge", "maximumTicketCount", 200);
        sampleTC.comment = "Maximum ticket count for the mod. Zero disables chunkloading capabilities.";
        sampleTC = ForgeChunkManager.config.get("Forge", "maximumChunksPerTicket", 25);
        sampleTC.comment = "Maximum chunks per ticket for the mod.";
        for (final String mod : ForgeChunkManager.config.getCategoryNames()) {
            if (!mod.equals("Forge")) {
                if (mod.equals("defaults")) {
                    continue;
                }
                final Property modTC = ForgeChunkManager.config.get(mod, "maximumTicketCount", 200);
                final Property modCPT = ForgeChunkManager.config.get(mod, "maximumChunksPerTicket", 25);
            }
        }
    }
    
    public static ConfigCategory getConfigFor(final Object mod) {
        final ModContainer container = getContainer(mod);
        if (container != null) {
            return ForgeChunkManager.config.getCategory(container.getModId());
        }
        return null;
    }
    
    public static void addConfigProperty(final Object mod, final String propertyName, final String value, final Property.Type type) {
        final ModContainer container = getContainer(mod);
        if (container != null) {
            final ConfigCategory cat = ForgeChunkManager.config.getCategory(container.getModId());
            cat.put(propertyName, new Property(propertyName, value, type));
        }
    }
    
    static {
        ForgeChunkManager.tickets = new MapMaker().weakKeys().makeMap();
        ForgeChunkManager.ticketConstraints = Maps.newHashMap();
        ForgeChunkManager.chunkConstraints = Maps.newHashMap();
        ForgeChunkManager.playerTickets = (SetMultimap<String, Ticket>)HashMultimap.create();
        ForgeChunkManager.callbacks = Maps.newHashMap();
        ForgeChunkManager.forcedChunks = new MapMaker().weakKeys().makeMap();
        ForgeChunkManager.pendingEntities = (BiMap<UUID, Ticket>)HashBiMap.create();
        ForgeChunkManager.dormantChunkCache = new MapMaker().weakKeys().makeMap();
        ForgeChunkManager.warnedMods = Sets.newHashSet();
    }
    
    public enum Type
    {
        NORMAL, 
        ENTITY;
    }
    
    public static class Ticket
    {
        private String modId;
        private Type ticketType;
        private LinkedHashSet<abp> requestedChunks;
        private by modData;
        public final abw world;
        private int maxDepth;
        private String entityClazz;
        private int entityChunkX;
        private int entityChunkZ;
        private nn entity;
        private String player;
        
        Ticket(final String modId, final Type type, final abw world) {
            this.modId = modId;
            this.ticketType = type;
            this.world = world;
            this.maxDepth = ForgeChunkManager.getMaxChunkDepthFor(modId);
            this.requestedChunks = Sets.newLinkedHashSet();
        }
        
        Ticket(final String modId, final Type type, final abw world, final String player) {
            this(modId, type, world);
            if (player != null) {
                this.player = player;
                return;
            }
            FMLLog.log(Level.SEVERE, "Attempt to create a player ticket without a valid player", new Object[0]);
            throw new RuntimeException();
        }
        
        public void setChunkListDepth(final int depth) {
            if (depth > ForgeChunkManager.getMaxChunkDepthFor(this.modId) || (depth <= 0 && ForgeChunkManager.getMaxChunkDepthFor(this.modId) > 0)) {
                FMLLog.warning("The mod %s tried to modify the chunk ticket depth to: %d, its allowed maximum is: %d", this.modId, depth, ForgeChunkManager.getMaxChunkDepthFor(this.modId));
            }
            else {
                this.maxDepth = depth;
            }
        }
        
        public int getChunkListDepth() {
            return this.maxDepth;
        }
        
        public int getMaxChunkListDepth() {
            return ForgeChunkManager.getMaxChunkDepthFor(this.modId);
        }
        
        public void bindEntity(final nn entity) {
            if (this.ticketType != Type.ENTITY) {
                throw new RuntimeException("Cannot bind an entity to a non-entity ticket");
            }
            this.entity = entity;
        }
        
        public by getModData() {
            if (this.modData == null) {
                this.modData = new by();
            }
            return this.modData;
        }
        
        public nn getEntity() {
            return this.entity;
        }
        
        public boolean isPlayerTicket() {
            return this.player != null;
        }
        
        public String getPlayerName() {
            return this.player;
        }
        
        public String getModId() {
            return this.modId;
        }
        
        public Type getType() {
            return this.ticketType;
        }
        
        public ImmutableSet getChunkList() {
            return ImmutableSet.copyOf((Collection)this.requestedChunks);
        }
    }
    
    public static class ForceChunkEvent extends Event
    {
        public final Ticket ticket;
        public final abp location;
        
        public ForceChunkEvent(final Ticket ticket, final abp location) {
            this.ticket = ticket;
            this.location = location;
        }
    }
    
    public static class UnforceChunkEvent extends Event
    {
        public final Ticket ticket;
        public final abp location;
        
        public UnforceChunkEvent(final Ticket ticket, final abp location) {
            this.ticket = ticket;
            this.location = location;
        }
    }
    
    public interface PlayerOrderedLoadingCallback extends LoadingCallback
    {
        ListMultimap<String, Ticket> playerTicketsLoaded(final ListMultimap<String, Ticket> p0, final abw p1);
    }
    
    public interface LoadingCallback
    {
        void ticketsLoaded(final List<Ticket> p0, final abw p1);
    }
    
    public interface OrderedLoadingCallback extends LoadingCallback
    {
        List<Ticket> ticketsLoaded(final List<Ticket> p0, final abw p1, final int p2);
    }
}



================================================
FILE: net/minecraftforge/common/ForgeDirection.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

public enum ForgeDirection
{
    DOWN(0, -1, 0), 
    UP(0, 1, 0), 
    NORTH(0, 0, -1), 
    SOUTH(0, 0, 1), 
    WEST(-1, 0, 0), 
    EAST(1, 0, 0), 
    UNKNOWN(0, 0, 0);
    
    public final int offsetX;
    public final int offsetY;
    public final int offsetZ;
    public final int flag;
    public static final ForgeDirection[] VALID_DIRECTIONS;
    public static final int[] OPPOSITES;
    public static final int[][] ROTATION_MATRIX;
    
    private ForgeDirection(final int x, final int y, final int z) {
        this.offsetX = x;
        this.offsetY = y;
        this.offsetZ = z;
        this.flag = 1 << this.ordinal();
    }
    
    public static ForgeDirection getOrientation(final int id) {
        if (id >= 0 && id < ForgeDirection.VALID_DIRECTIONS.length) {
            return ForgeDirection.VALID_DIRECTIONS[id];
        }
        return ForgeDirection.UNKNOWN;
    }
    
    public ForgeDirection getOpposite() {
        return getOrientation(ForgeDirection.OPPOSITES[this.ordinal()]);
    }
    
    public ForgeDirection getRotation(final ForgeDirection axis) {
        return getOrientation(ForgeDirection.ROTATION_MATRIX[axis.ordinal()][this.ordinal()]);
    }
    
    static {
        VALID_DIRECTIONS = new ForgeDirection[] { ForgeDirection.DOWN, ForgeDirection.UP, ForgeDirection.NORTH, ForgeDirection.SOUTH, ForgeDirection.WEST, ForgeDirection.EAST };
        OPPOSITES = new int[] { 1, 0, 3, 2, 5, 4, 6 };
        ROTATION_MATRIX = new int[][] { { 0, 1, 4, 5, 3, 2, 6 }, { 0, 1, 5, 4, 2, 3, 6 }, { 5, 4, 2, 3, 0, 1, 6 }, { 4, 5, 2, 3, 1, 0, 6 }, { 2, 3, 1, 0, 4, 5, 6 }, { 3, 2, 0, 1, 4, 5, 6 }, { 0, 1, 2, 3, 4, 5, 6 } };
    }
}



================================================
FILE: net/minecraftforge/common/ForgeDummyContainer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import cpw.mods.fml.client.FMLFileResourcePack;
import cpw.mods.fml.client.FMLFolderResourcePack;
import net.minecraftforge.classloading.FMLForgePlugin;
import java.util.Map;
import net.minecraftforge.server.command.ForgeCommand;
import cpw.mods.fml.common.event.FMLServerStartingEvent;
import net.minecraftforge.oredict.RecipeSorter;
import cpw.mods.fml.common.event.FMLLoadCompleteEvent;
import cpw.mods.fml.common.event.FMLPostInitializationEvent;
import cpw.mods.fml.common.event.FMLPreInitializationEvent;
import com.google.common.eventbus.Subscribe;
import java.util.logging.Level;
import cpw.mods.fml.common.network.NetworkModHandler;
import net.minecraftforge.common.network.ForgeNetworkHandler;
import cpw.mods.fml.common.network.FMLNetworkHandler;
import cpw.mods.fml.common.event.FMLConstructionEvent;
import cpw.mods.fml.common.LoadController;
import com.google.common.eventbus.EventBus;
import cpw.mods.fml.common.FMLLog;
import java.io.File;
import cpw.mods.fml.common.Loader;
import java.util.Arrays;
import cpw.mods.fml.common.ModMetadata;
import net.minecraftforge.common.network.ForgeTinyPacketHandler;
import net.minecraftforge.common.network.ForgePacketHandler;
import net.minecraftforge.common.network.ForgeConnectionHandler;
import cpw.mods.fml.common.network.NetworkMod;
import cpw.mods.fml.common.WorldAccessContainer;
import cpw.mods.fml.common.DummyModContainer;

@NetworkMod(channels = { "FORGE" }, connectionHandler = ForgeConnectionHandler.class, packetHandler = ForgePacketHandler.class, tinyPacketHandler = ForgeTinyPacketHandler.class)
public class ForgeDummyContainer extends DummyModContainer implements WorldAccessContainer
{
    public static int clumpingThreshold;
    public static boolean removeErroringEntities;
    public static boolean removeErroringTileEntities;
    public static boolean disableStitchedFileSaving;
    public static boolean forceDuplicateFluidBlockCrash;
    public static boolean fullBoundingBoxLadders;
    public static double zombieSummonBaseChance;
    public static int[] blendRanges;
    public static float zombieBabyChance;
    public static boolean shouldSortRecipies;
    
    public ForgeDummyContainer() {
        super(new ModMetadata());
        final ModMetadata meta = this.getMetadata();
        meta.modId = "Forge";
        meta.name = "Minecraft Forge";
        meta.version = String.format("%d.%d.%d.%d", 9, 11, 1, 965);
        meta.credits = "Made possible with help from many people";
        meta.authorList = Arrays.asList("LexManos", "Eloraam", "Spacetoad");
        meta.description = "Minecraft Forge is a common open source API allowing a broad range of mods to work cooperatively together. It allows many mods to be created without them editing the main Minecraft code.";
        meta.url = "http://MinecraftForge.net";
        meta.updateUrl = "http://MinecraftForge.net/forum/index.php/topic,5.0.html";
        meta.screenshots = new String[0];
        meta.logoFile = "/forge_logo.png";
        Configuration config = null;
        final File cfgFile = new File(Loader.instance().getConfigDir(), "forge.cfg");
        try {
            config = new Configuration(cfgFile);
        }
        catch (final Exception e) {
            System.out.println("Error loading forge.cfg, deleting file and resetting: ");
            e.printStackTrace();
            if (cfgFile.exists()) {
                cfgFile.delete();
            }
            config = new Configuration(cfgFile);
        }
        if (!config.isChild) {
            config.load();
            final Property enableGlobalCfg = config.get("general", "enableGlobalConfig", false);
            if (enableGlobalCfg.getBoolean(false)) {
                Configuration.enableGlobalConfig();
            }
        }
        Property prop = config.get("general", "clumpingThreshold", 64);
        prop.comment = "Controls the number threshold at which Packet51 is preferred over Packet52, default and minimum 64, maximum 1024";
        ForgeDummyContainer.clumpingThreshold = prop.getInt(64);
        if (ForgeDummyContainer.clumpingThreshold > 1024 || ForgeDummyContainer.clumpingThreshold < 64) {
            prop.set(ForgeDummyContainer.clumpingThreshold = 64);
        }
        prop = config.get("general", "removeErroringEntities", false);
        prop.comment = "Set this to just remove any TileEntity that throws a error in there update method instead of closing the server and reporting a crash log. BE WARNED THIS COULD SCREW UP EVERYTHING USE SPARINGLY WE ARE NOT RESPONSIBLE FOR DAMAGES.";
        ForgeDummyContainer.removeErroringEntities = prop.getBoolean(false);
        if (ForgeDummyContainer.removeErroringEntities) {
            FMLLog.warning("Enabling removal of erroring Entities - USE AT YOUR OWN RISK", new Object[0]);
        }
        prop = config.get("general", "removeErroringTileEntities", false);
        prop.comment = "Set this to just remove any TileEntity that throws a error in there update method instead of closing the server and reporting a crash log. BE WARNED THIS COULD SCREW UP EVERYTHING USE SPARINGLY WE ARE NOT RESPONSIBLE FOR DAMAGES.";
        ForgeDummyContainer.removeErroringTileEntities = prop.getBoolean(false);
        if (ForgeDummyContainer.removeErroringTileEntities) {
            FMLLog.warning("Enabling removal of erroring Tile Entities - USE AT YOUR OWN RISK", new Object[0]);
        }
        prop = config.get("general", "fullBoundingBoxLadders", false);
        prop.comment = "Set this to check the entire entity's collision bounding box for ladders instead of just the block they are in. Causes noticable differences in mechanics so default is vanilla behavior. Default: false";
        ForgeDummyContainer.fullBoundingBoxLadders = prop.getBoolean(false);
        prop = config.get("general", "forceDuplicateFluidBlockCrash", true);
        prop.comment = "Set this to force a crash if more than one block attempts to link back to the same Fluid. Enabled by default.";
        if (!(ForgeDummyContainer.forceDuplicateFluidBlockCrash = prop.getBoolean(true))) {
            FMLLog.warning("Disabling forced crashes on duplicate Fluid Blocks - USE AT YOUR OWN RISK", new Object[0]);
        }
        prop = config.get("general", "biomeSkyBlendRange", new int[] { 20, 15, 10, 5 });
        prop.comment = "Control the range of sky blending for colored skies in biomes.";
        ForgeDummyContainer.blendRanges = prop.getIntList();
        prop = config.get("general", "zombieBaseSummonChance", 0.1);
        prop.comment = "Base zombie summoning spawn chance. Allows changing the bonus zombie summoning mechanic.";
        ForgeDummyContainer.zombieSummonBaseChance = prop.getDouble(0.1);
        prop = config.get("general", "zombieBabyChance", 0.05);
        prop.comment = "Chance that a zombie (or subclass) is a baby. Allows changing the zombie spawning mechanic.";
        ForgeDummyContainer.zombieBabyChance = (float)prop.getDouble(0.05);
        prop = config.get("general", "sortRecipies", ForgeDummyContainer.shouldSortRecipies);
        prop.comment = "Set to true to enable the post initlization sorting of crafting recipes using Froge's sorter. May cause desyncing on conflicting recipies. ToDo: Set to true by default in 1.7";
        ForgeDummyContainer.shouldSortRecipies = prop.getBoolean(ForgeDummyContainer.shouldSortRecipies);
        if (config.hasChanged()) {
            config.save();
        }
    }
    
    @Override
    public boolean registerBus(final EventBus bus, final LoadController controller) {
        bus.register((Object)this);
        return true;
    }
    
    @Subscribe
    public void modConstruction(final FMLConstructionEvent evt) {
        FMLLog.info("Registering Forge Packet Handler", new Object[0]);
        try {
            FMLNetworkHandler.instance().registerNetworkMod(new ForgeNetworkHandler(this));
            FMLLog.info("Succeeded registering Forge Packet Handler", new Object[0]);
        }
        catch (final Exception e) {
            FMLLog.log(Level.SEVERE, e, "Failed to register packet handler for Forge", new Object[0]);
        }
    }
    
    @Subscribe
    public void preInit(final FMLPreInitializationEvent evt) {
        ForgeChunkManager.captureConfig(evt.getModConfigurationDirectory());
    }
    
    @Subscribe
    public void postInit(final FMLPostInitializationEvent evt) {
        BiomeDictionary.registerAllBiomesAndGenerateEvents();
        ForgeChunkManager.loadConfiguration();
    }
    
    @Subscribe
    public void onAvalible(final FMLLoadCompleteEvent evt) {
        if (ForgeDummyContainer.shouldSortRecipies) {
            RecipeSorter.sortCraftManager();
        }
    }
    
    @Subscribe
    public void serverStarting(final FMLServerStartingEvent evt) {
        evt.registerServerCommand((ab)new ForgeCommand(evt.getServer()));
    }
    
    @Override
    public by getDataForWriting(final alq handler, final als info) {
        final by forgeData = new by();
        final by dimData = DimensionManager.saveDimensionDataMap();
        forgeData.a("DimensionData", dimData);
        return forgeData;
    }
    
    @Override
    public void readData(final alq handler, final als info, final Map<String, cl> propertyMap, final by tag) {
        if (tag.b("DimensionData")) {
            DimensionManager.loadDimensionDataMap(tag.b("DimensionData") ? tag.l("DimensionData") : null);
        }
    }
    
    @Override
    public File getSource() {
        return FMLForgePlugin.forgeLocation;
    }
    
    @Override
    public Class<?> getCustomResourcePackClass() {
        if (this.getSource().isDirectory()) {
            return FMLFolderResourcePack.class;
        }
        return FMLFileResourcePack.class;
    }
    
    static {
        ForgeDummyContainer.clumpingThreshold = 64;
        ForgeDummyContainer.removeErroringEntities = false;
        ForgeDummyContainer.removeErroringTileEntities = false;
        ForgeDummyContainer.disableStitchedFileSaving = false;
        ForgeDummyContainer.forceDuplicateFluidBlockCrash = true;
        ForgeDummyContainer.fullBoundingBoxLadders = false;
        ForgeDummyContainer.zombieSummonBaseChance = 0.1;
        ForgeDummyContainer.blendRanges = new int[] { 20, 15, 10, 5 };
        ForgeDummyContainer.zombieBabyChance = 0.05f;
        ForgeDummyContainer.shouldSortRecipies = false;
    }
}



================================================
FILE: net/minecraftforge/common/ForgeHooks.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import net.minecraftforge.event.world.BlockEvent;
import net.minecraftforge.event.entity.player.PlayerOpenContainerEvent;
import net.minecraftforge.event.ServerChatEvent;
import net.minecraftforge.event.entity.item.ItemTossEvent;
import net.minecraftforge.event.entity.living.LivingFallEvent;
import net.minecraftforge.event.entity.living.LivingDropsEvent;
import java.util.ArrayList;
import net.minecraftforge.event.entity.living.LivingDeathEvent;
import net.minecraftforge.event.entity.living.LivingHurtEvent;
import net.minecraftforge.event.entity.living.LivingAttackEvent;
import net.minecraftforge.event.entity.living.LivingEvent;
import net.minecraftforge.event.Event;
import net.minecraftforge.event.entity.living.LivingSetAttackTargetEvent;
import net.minecraftforge.event.ForgeEventFactory;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.HashMap;
import java.util.List;

public class ForgeHooks
{
    static final List<GrassEntry> grassList;
    static final List<SeedEntry> seedList;
    private static boolean toolInit;
    static HashMap<yc, List> toolClasses;
    static HashMap<List, Integer> toolHarvestLevels;
    static HashSet<List> toolEffectiveness;
    
    public static void plantGrass(final abw world, final int x, final int y, final int z) {
        final GrassEntry grass = (GrassEntry)mi.a(world.s, (Collection)ForgeHooks.grassList);
        if (grass == null || grass.block == null || !grass.block.f(world, x, y, z)) {
            return;
        }
        world.f(x, y, z, grass.block.cF, grass.metadata, 3);
    }
    
    public static ye getGrassSeed(final abw world) {
        final SeedEntry entry = (SeedEntry)mi.a(world.s, (Collection)ForgeHooks.seedList);
        if (entry == null || entry.seed == null) {
            return null;
        }
        return entry.seed.m();
    }
    
    public static boolean canHarvestBlock(final aqz block, final uf player, final int metadata) {
        if (block.cU.l()) {
            return true;
        }
        final ye stack = player.bn.h();
        if (stack == null) {
            return player.a(block);
        }
        final List info = ForgeHooks.toolClasses.get(stack.b());
        if (info == null) {
            return player.a(block);
        }
        final Object[] tmp = info.toArray();
        final String toolClass = (String)tmp[0];
        final int harvestLevel = (int)tmp[1];
        final Integer blockHarvestLevel = ForgeHooks.toolHarvestLevels.get(Arrays.asList(block, metadata, toolClass));
        if (blockHarvestLevel == null) {
            return player.a(block);
        }
        return blockHarvestLevel <= harvestLevel;
    }
    
    public static boolean canToolHarvestBlock(final aqz block, final int metadata, final ye stack) {
        if (stack == null) {
            return false;
        }
        final List info = ForgeHooks.toolClasses.get(stack.b());
        if (info == null) {
            return false;
        }
        final Object[] tmp = info.toArray();
        final String toolClass = (String)tmp[0];
        final int harvestLevel = (int)tmp[1];
        final Integer blockHarvestLevel = ForgeHooks.toolHarvestLevels.get(Arrays.asList(block, metadata, toolClass));
        return blockHarvestLevel != null && blockHarvestLevel <= harvestLevel;
    }
    
    public static float blockStrength(final aqz block, final uf player, final abw world, final int x, final int y, final int z) {
        final int metadata = world.h(x, y, z);
        final float hardness = block.l(world, x, y, z);
        if (hardness < 0.0f) {
            return 0.0f;
        }
        if (!canHarvestBlock(block, player, metadata)) {
            final float speed = ForgeEventFactory.getBreakSpeed(player, block, metadata, 1.0f);
            return ((speed < 0.0f) ? 0.0f : speed) / hardness / 100.0f;
        }
        return player.getCurrentPlayerStrVsBlock(block, false, metadata) / hardness / 30.0f;
    }
    
    public static boolean isToolEffective(final ye stack, final aqz block, final int metadata) {
        final List toolClass = ForgeHooks.toolClasses.get(stack.b());
        return toolClass != null && ForgeHooks.toolEffectiveness.contains(Arrays.asList(block, metadata, toolClass.get(0)));
    }
    
    static void initTools() {
        if (ForgeHooks.toolInit) {
            return;
        }
        ForgeHooks.toolInit = true;
        MinecraftForge.setToolClass(yc.v, "pickaxe", 0);
        MinecraftForge.setToolClass(yc.z, "pickaxe", 1);
        MinecraftForge.setToolClass(yc.i, "pickaxe", 2);
        MinecraftForge.setToolClass(yc.K, "pickaxe", 0);
        MinecraftForge.setToolClass(yc.D, "pickaxe", 3);
        MinecraftForge.setToolClass(yc.w, "axe", 0);
        MinecraftForge.setToolClass(yc.A, "axe", 1);
        MinecraftForge.setToolClass(yc.j, "axe", 2);
        MinecraftForge.setToolClass(yc.L, "axe", 0);
        MinecraftForge.setToolClass(yc.E, "axe", 3);
        MinecraftForge.setToolClass(yc.u, "shovel", 0);
        MinecraftForge.setToolClass(yc.y, "shovel", 1);
        MinecraftForge.setToolClass(yc.h, "shovel", 2);
        MinecraftForge.setToolClass(yc.J, "shovel", 0);
        MinecraftForge.setToolClass(yc.C, "shovel", 3);
        for (final aqz block : yn.c) {
            MinecraftForge.setBlockHarvestLevel(block, "pickaxe", 0);
        }
        for (final aqz block : yy.c) {
            MinecraftForge.setBlockHarvestLevel(block, "shovel", 0);
        }
        for (final aqz block : ya.c) {
            MinecraftForge.setBlockHarvestLevel(block, "axe", 0);
        }
        MinecraftForge.setBlockHarvestLevel(aqz.au, "pickaxe", 3);
        MinecraftForge.setBlockHarvestLevel(aqz.bW, "pickaxe", 2);
        MinecraftForge.setBlockHarvestLevel(aqz.aB, "pickaxe", 2);
        MinecraftForge.setBlockHarvestLevel(aqz.aC, "pickaxe", 2);
        MinecraftForge.setBlockHarvestLevel(aqz.L, "pickaxe", 2);
        MinecraftForge.setBlockHarvestLevel(aqz.am, "pickaxe", 2);
        MinecraftForge.setBlockHarvestLevel(aqz.M, "pickaxe", 1);
        MinecraftForge.setBlockHarvestLevel(aqz.an, "pickaxe", 1);
        MinecraftForge.setBlockHarvestLevel(aqz.S, "pickaxe", 1);
        MinecraftForge.setBlockHarvestLevel(aqz.T, "pickaxe", 1);
        MinecraftForge.setBlockHarvestLevel(aqz.aS, "pickaxe", 2);
        MinecraftForge.setBlockHarvestLevel(aqz.aT, "pickaxe", 2);
        MinecraftForge.removeBlockEffectiveness(aqz.aS, "pickaxe");
        MinecraftForge.removeBlockEffectiveness(aqz.au, "pickaxe");
        MinecraftForge.removeBlockEffectiveness(aqz.aT, "pickaxe");
    }
    
    public static int getTotalArmorValue(final uf player) {
        int ret = 0;
        for (int x = 0; x < player.bn.b.length; ++x) {
            final ye stack = player.bn.b[x];
            if (stack != null && stack.b() instanceof ISpecialArmor) {
                ret += ((ISpecialArmor)stack.b()).getArmorDisplay(player, stack, x);
            }
            else if (stack != null && stack.b() instanceof wh) {
                ret += ((wh)stack.b()).c;
            }
        }
        return ret;
    }
    
    public static boolean onPickBlock(final ata target, final uf player, final abw world) {
        ye result = null;
        final boolean isCreative = player.bG.d;
        if (target.a == atb.a) {
            final int x = target.b;
            final int y = target.c;
            final int z = target.d;
            final aqz var8 = aqz.s[world.a(x, y, z)];
            if (var8 == null) {
                return false;
            }
            result = var8.getPickBlock(target, world, x, y, z);
        }
        else {
            if (target.a != atb.b || target.g == null || !isCreative) {
                return false;
            }
            result = target.g.getPickedResult(target);
        }
        if (result == null) {
            return false;
        }
        for (int x = 0; x < 9; ++x) {
            final ye stack = player.bn.a(x);
            if (stack != null && stack.a(result) && ye.a(stack, result)) {
                player.bn.c = x;
                return true;
            }
        }
        if (!isCreative) {
            return false;
        }
        int slot = player.bn.j();
        if (slot < 0 || slot >= 9) {
            slot = player.bn.c;
        }
        player.bn.a(slot, result);
        player.bn.c = slot;
        return true;
    }
    
    public static void onLivingSetAttackTarget(final of entity, final of target) {
        MinecraftForge.EVENT_BUS.post(new LivingSetAttackTargetEvent(entity, target));
    }
    
    public static boolean onLivingUpdate(final of entity) {
        return MinecraftForge.EVENT_BUS.post(new LivingEvent.LivingUpdateEvent(entity));
    }
    
    public static boolean onLivingAttack(final of entity, final nb src, final float amount) {
        return MinecraftForge.EVENT_BUS.post(new LivingAttackEvent(entity, src, amount));
    }
    
    public static float onLivingHurt(final of entity, final nb src, final float amount) {
        final LivingHurtEvent event = new LivingHurtEvent(entity, src, amount);
        return MinecraftForge.EVENT_BUS.post(event) ? 0.0f : event.ammount;
    }
    
    public static boolean onLivingDeath(final of entity, final nb src) {
        return MinecraftForge.EVENT_BUS.post(new LivingDeathEvent(entity, src));
    }
    
    public static boolean onLivingDrops(final of entity, final nb source, final ArrayList<ss> drops, final int lootingLevel, final boolean recentlyHit, final int specialDropValue) {
        return MinecraftForge.EVENT_BUS.post(new LivingDropsEvent(entity, source, drops, lootingLevel, recentlyHit, specialDropValue));
    }
    
    public static float onLivingFall(final of entity, final float distance) {
        final LivingFallEvent event = new LivingFallEvent(entity, distance);
        return MinecraftForge.EVENT_BUS.post(event) ? 0.0f : event.distance;
    }
    
    public static boolean isLivingOnLadder(aqz block, final abw world, final int x, final int y, final int z, final of entity) {
        if (!ForgeDummyContainer.fullBoundingBoxLadders) {
            return block != null && block.isLadder(world, x, y, z, entity);
        }
        final asx bb = entity.E;
        final int mX = ls.c(bb.a);
        final int mY = ls.c(bb.b);
        final int mZ = ls.c(bb.c);
        for (int y2 = mY; y2 < bb.e; ++y2) {
            for (int x2 = mX; x2 < bb.d; ++x2) {
                for (int z2 = mZ; z2 < bb.f; ++z2) {
                    block = aqz.s[world.a(x2, y2, z2)];
                    if (block != null && block.isLadder(world, x2, y2, z2, entity)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    
    public static void onLivingJump(final of entity) {
        MinecraftForge.EVENT_BUS.post(new LivingEvent.LivingJumpEvent(entity));
    }
    
    public static ss onPlayerTossEvent(final uf player, final ye item) {
        player.captureDrops = true;
        final ss ret = player.a(item, false);
        player.capturedDrops.clear();
        player.captureDrops = false;
        if (ret == null) {
            return null;
        }
        final ItemTossEvent event = new ItemTossEvent(ret, player);
        if (MinecraftForge.EVENT_BUS.post(event)) {
            return null;
        }
        player.a(event.entityItem);
        return event.entityItem;
    }
    
    public static float getEnchantPower(final abw world, final int x, final int y, final int z) {
        if (world.c(x, y, z)) {
            return 0.0f;
        }
        final aqz block = aqz.s[world.a(x, y, z)];
        return (block == null) ? 0.0f : block.getEnchantPowerBonus(world, x, y, z);
    }
    
    public static cv onServerChatEvent(final ka net, final String raw, final cv comp) {
        final ServerChatEvent event = new ServerChatEvent(net.c, raw, comp);
        if (MinecraftForge.EVENT_BUS.post(event)) {
            return null;
        }
        return event.component;
    }
    
    public static boolean canInteractWith(final uf player, final uy openContainer) {
        final PlayerOpenContainerEvent event = new PlayerOpenContainerEvent(player, openContainer);
        MinecraftForge.EVENT_BUS.post(event);
        return (event.getResult() == Event.Result.DEFAULT) ? event.canInteractWith : (event.getResult() == Event.Result.ALLOW);
    }
    
    public static BlockEvent.BreakEvent onBlockBreakEvent(final abw world, final ace gameType, final jv entityPlayer, final int x, final int y, final int z) {
        boolean preCancelEvent = false;
        if (gameType.c() && !entityPlayer.d(x, y, z)) {
            preCancelEvent = true;
        }
        else if (gameType.d() && entityPlayer.aZ() != null && entityPlayer.aZ().b() instanceof zl) {
            preCancelEvent = true;
        }
        if (world.r(x, y, z) == null) {
            final gg packet = new gg(x, y, z, world);
            packet.d = 0;
            packet.e = 0;
            entityPlayer.a.b((ey)packet);
        }
        final aqz block = aqz.s[world.a(x, y, z)];
        final int blockMetadata = world.h(x, y, z);
        final BlockEvent.BreakEvent event = new BlockEvent.BreakEvent(x, y, z, world, block, blockMetadata, (uf)entityPlayer);
        event.setCanceled(preCancelEvent);
        MinecraftForge.EVENT_BUS.post(event);
        if (event.isCanceled()) {
            entityPlayer.a.b((ey)new gg(x, y, z, world));
            final asp tileentity = world.r(x, y, z);
            if (tileentity != null) {
                final ey pkt = tileentity.m();
                if (pkt != null) {
                    entityPlayer.a.b(pkt);
                }
            }
        }
        return event;
    }
    
    static {
        grassList = new ArrayList<GrassEntry>();
        seedList = new ArrayList<SeedEntry>();
        ForgeHooks.toolInit = false;
        ForgeHooks.toolClasses = new HashMap<yc, List>();
        ForgeHooks.toolHarvestLevels = new HashMap<List, Integer>();
        ForgeHooks.toolEffectiveness = new HashSet<List>();
        ForgeHooks.grassList.add(new GrassEntry((aqz)aqz.ai, 0, 20));
        ForgeHooks.grassList.add(new GrassEntry((aqz)aqz.aj, 0, 10));
        ForgeHooks.seedList.add(new SeedEntry(new ye(yc.U), 10));
        initTools();
    }
    
    static class GrassEntry extends mj
    {
        public final aqz block;
        public final int metadata;
        
        public GrassEntry(final aqz block, final int meta, final int weight) {
            super(weight);
            this.block = block;
            this.metadata = meta;
        }
    }
    
    static class SeedEntry extends mj
    {
        public final ye seed;
        
        public SeedEntry(final ye seed, final int weight) {
            super(weight);
            this.seed = seed;
        }
    }
}



================================================
FILE: net/minecraftforge/common/ForgeInternalHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import net.minecraftforge.event.world.WorldEvent;
import net.minecraftforge.event.EventPriority;
import net.minecraftforge.event.ForgeSubscribe;
import cpw.mods.fml.common.FMLLog;
import net.minecraftforge.event.entity.EntityJoinWorldEvent;

public class ForgeInternalHandler
{
    @ForgeSubscribe(priority = EventPriority.HIGHEST)
    public void onEntityJoinWorld(final EntityJoinWorldEvent event) {
        if (!event.world.I) {
            ForgeChunkManager.loadEntity(event.entity);
        }
        final nn entity = event.entity;
        if (entity.getClass().equals(ss.class)) {
            final ye stack = entity.v().f(10);
            if (stack == null) {
                return;
            }
            final yc item = stack.b();
            if (item == null) {
                FMLLog.warning("Attempted to add a EntityItem to the world with a invalid item: ID %d at (%2.2f,  %2.2f, %2.2f), this is most likely a config issue between you and the server. Please double check your configs", stack.d, entity.u, entity.v, entity.w);
                entity.x();
                event.setCanceled(true);
                return;
            }
            if (item.hasCustomEntity(stack)) {
                final nn newEntity = item.createEntity(event.world, entity, stack);
                if (newEntity != null) {
                    entity.x();
                    event.setCanceled(true);
                    event.world.d(newEntity);
                }
            }
        }
    }
    
    @ForgeSubscribe(priority = EventPriority.HIGHEST)
    public void onDimensionLoad(final WorldEvent.Load event) {
        ForgeChunkManager.loadWorld(event.world);
    }
    
    @ForgeSubscribe(priority = EventPriority.HIGHEST)
    public void onDimensionSave(final WorldEvent.Save event) {
        ForgeChunkManager.saveWorld(event.world);
    }
    
    @ForgeSubscribe(priority = EventPriority.HIGHEST)
    public void onDimensionUnload(final WorldEvent.Unload event) {
        ForgeChunkManager.unloadWorld(event.world);
    }
}



================================================
FILE: net/minecraftforge/common/ForgeVersion.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

public class ForgeVersion
{
    public static final int majorVersion = 9;
    public static final int minorVersion = 11;
    public static final int revisionVersion = 1;
    public static final int buildVersion = 965;
    
    public static int getMajorVersion() {
        return 9;
    }
    
    public static int getMinorVersion() {
        return 11;
    }
    
    public static int getRevisionVersion() {
        return 1;
    }
    
    public static int getBuildVersion() {
        return 965;
    }
    
    public static String getVersion() {
        return String.format("%d.%d.%d.%d", 9, 11, 1, 965);
    }
}



================================================
FILE: net/minecraftforge/common/IExtendedEntityProperties.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

public interface IExtendedEntityProperties
{
    void saveNBTData(final by p0);
    
    void loadNBTData(final by p0);
    
    void init(final nn p0, final abw p1);
}



================================================
FILE: net/minecraftforge/common/IMinecartCollisionHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

public interface IMinecartCollisionHandler
{
    void onEntityCollision(final st p0, final nn p1);
    
    asx getCollisionBox(final st p0, final nn p1);
    
    asx getMinecartCollisionBox(final st p0);
    
    asx getBoundingBox(final st p0);
}



================================================
FILE: net/minecraftforge/common/IPlantable.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

public interface IPlantable
{
    EnumPlantType getPlantType(final abw p0, final int p1, final int p2, final int p3);
    
    int getPlantID(final abw p0, final int p1, final int p2, final int p3);
    
    int getPlantMetadata(final abw p0, final int p1, final int p2, final int p3);
}



================================================
FILE: net/minecraftforge/common/IShearable.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import java.util.ArrayList;

public interface IShearable
{
    boolean isShearable(final ye p0, final abw p1, final int p2, final int p3, final int p4);
    
    ArrayList<ye> onSheared(final ye p0, final abw p1, final int p2, final int p3, final int p4, final int p5);
}



================================================
FILE: net/minecraftforge/common/ISpecialArmor.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import java.util.Arrays;
import java.util.ArrayList;

public interface ISpecialArmor
{
    ArmorProperties getProperties(final of p0, final ye p1, final nb p2, final double p3, final int p4);
    
    int getArmorDisplay(final uf p0, final ye p1, final int p2);
    
    void damageArmor(final of p0, final ye p1, final nb p2, final int p3, final int p4);
    
    public static class ArmorProperties implements Comparable<ArmorProperties>
    {
        public int Priority;
        public int AbsorbMax;
        public double AbsorbRatio;
        public int Slot;
        private static final boolean DEBUG = false;
        
        public ArmorProperties(final int priority, final double ratio, final int max) {
            this.Priority = 0;
            this.AbsorbMax = Integer.MAX_VALUE;
            this.AbsorbRatio = 0.0;
            this.Slot = 0;
            this.Priority = priority;
            this.AbsorbRatio = ratio;
            this.AbsorbMax = max;
        }
        
        public static float ApplyArmor(final of entity, final ye[] inventory, final nb source, double damage) {
            damage *= 25.0;
            final ArrayList<ArmorProperties> dmgVals = new ArrayList<ArmorProperties>();
            for (int x = 0; x < inventory.length; ++x) {
                final ye stack = inventory[x];
                if (stack != null) {
                    ArmorProperties prop = null;
                    if (stack.b() instanceof ISpecialArmor) {
                        final ISpecialArmor armor = (ISpecialArmor)stack.b();
                        prop = armor.getProperties(entity, stack, source, damage / 25.0, x).copy();
                    }
                    else if (stack.b() instanceof wh && !source.e()) {
                        final wh armor2 = (wh)stack.b();
                        prop = new ArmorProperties(0, armor2.c / 25.0, armor2.o() + 1 - stack.k());
                    }
                    if (prop != null) {
                        prop.Slot = x;
                        dmgVals.add(prop);
                    }
                }
            }
            if (dmgVals.size() > 0) {
                final ArmorProperties[] props = dmgVals.toArray(new ArmorProperties[dmgVals.size()]);
                StandardizeList(props, damage);
                int level = props[0].Priority;
                double ratio = 0.0;
                for (final ArmorProperties prop2 : props) {
                    if (level != prop2.Priority) {
                        damage -= damage * ratio;
                        ratio = 0.0;
                        level = prop2.Priority;
                    }
                    ratio += prop2.AbsorbRatio;
                    final double absorb = damage * prop2.AbsorbRatio;
                    if (absorb > 0.0) {
                        final ye stack2 = inventory[prop2.Slot];
                        final int itemDamage = (int)((absorb / 25.0 < 1.0) ? 1.0 : (absorb / 25.0));
                        if (stack2.b() instanceof ISpecialArmor) {
                            ((ISpecialArmor)stack2.b()).damageArmor(entity, stack2, source, itemDamage, prop2.Slot);
                        }
                        else {
                            stack2.a(itemDamage, entity);
                        }
                        if (stack2.b <= 0) {
                            inventory[prop2.Slot] = null;
                        }
                    }
                }
                damage -= damage * ratio;
            }
            return (float)(damage / 25.0);
        }
        
        private static void StandardizeList(final ArmorProperties[] armor, double damage) {
            Arrays.sort(armor);
            int start = 0;
            double total = 0.0;
            int priority = armor[0].Priority;
            int pStart = 0;
            boolean pChange = false;
            boolean pFinished = false;
            for (int x = 0; x < armor.length; ++x) {
                total += armor[x].AbsorbRatio;
                if (x == armor.length - 1 || armor[x].Priority != priority) {
                    if (armor[x].Priority != priority) {
                        total -= armor[x].AbsorbRatio;
                        --x;
                        pChange = true;
                    }
                    if (total > 1.0) {
                        for (int y = start; y <= x; ++y) {
                            final double newRatio = armor[y].AbsorbRatio / total;
                            if (newRatio * damage > armor[y].AbsorbMax) {
                                armor[y].AbsorbRatio = armor[y].AbsorbMax / damage;
                                total = 0.0;
                                for (int z = pStart; z <= y; ++z) {
                                    total += armor[z].AbsorbRatio;
                                }
                                start = y + 1;
                                x = y;
                                break;
                            }
                            armor[y].AbsorbRatio = newRatio;
                            pFinished = true;
                        }
                        if (pChange && pFinished) {
                            damage -= damage * total;
                            total = 0.0;
                            start = x + 1;
                            priority = armor[start].Priority;
                            pStart = start;
                            pChange = false;
                            pFinished = false;
                            if (damage <= 0.0) {
                                for (int y = x + 1; y < armor.length; ++y) {
                                    armor[y].AbsorbRatio = 0.0;
                                }
                                break;
                            }
                        }
                    }
                    else {
                        for (int y = start; y <= x; ++y) {
                            total -= armor[y].AbsorbRatio;
                            if (damage * armor[y].AbsorbRatio > armor[y].AbsorbMax) {
                                armor[y].AbsorbRatio = armor[y].AbsorbMax / damage;
                            }
                            total += armor[y].AbsorbRatio;
                        }
                        damage -= damage * total;
                        total = 0.0;
                        if (x != armor.length - 1) {
                            start = x + 1;
                            priority = armor[start].Priority;
                            pStart = start;
                            pChange = false;
                            if (damage <= 0.0) {
                                for (int y = x + 1; y < armor.length; ++y) {
                                    armor[y].AbsorbRatio = 0.0;
                                }
                                break;
                            }
                        }
                    }
                }
            }
        }
        
        @Override
        public int compareTo(final ArmorProperties o) {
            if (o.Priority != this.Priority) {
                return o.Priority - this.Priority;
            }
            final double left = (this.AbsorbRatio == 0.0) ? 0.0 : (this.AbsorbMax * 100.0 / this.AbsorbRatio);
            final double right = (o.AbsorbRatio == 0.0) ? 0.0 : (o.AbsorbMax * 100.0 / o.AbsorbRatio);
            return (int)(left - right);
        }
        
        @Override
        public String toString() {
            return String.format("%d, %d, %f, %d", this.Priority, this.AbsorbMax, this.AbsorbRatio, (this.AbsorbRatio == 0.0) ? 0 : ((int)(this.AbsorbMax * 100.0 / this.AbsorbRatio)));
        }
        
        public ArmorProperties copy() {
            return new ArmorProperties(this.Priority, this.AbsorbRatio, this.AbsorbMax);
        }
    }
}



================================================
FILE: net/minecraftforge/common/MinecraftForge.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import net.minecraftforge.oredict.OreDictionary;
import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;
import cpw.mods.fml.common.FMLLog;
import java.util.List;
import java.util.Arrays;
import java.io.Serializable;
import net.minecraftforge.event.EventBus;

public class MinecraftForge
{
    public static final EventBus EVENT_BUS;
    public static final EventBus TERRAIN_GEN_BUS;
    public static final EventBus ORE_GEN_BUS;
    private static final ForgeInternalHandler INTERNAL_HANDLER;
    
    public static void addGrassPlant(final aqz block, final int metadata, final int weight) {
        ForgeHooks.grassList.add(new ForgeHooks.GrassEntry(block, metadata, weight));
    }
    
    public static void addGrassSeed(final ye seed, final int weight) {
        ForgeHooks.seedList.add(new ForgeHooks.SeedEntry(seed, weight));
    }
    
    public static void setToolClass(final yc tool, final String toolClass, final int harvestLevel) {
        ForgeHooks.toolClasses.put(tool, Arrays.asList(toolClass, harvestLevel));
    }
    
    public static void setBlockHarvestLevel(final aqz block, final int metadata, final String toolClass, final int harvestLevel) {
        final List key = Arrays.asList(block, metadata, toolClass);
        ForgeHooks.toolHarvestLevels.put(key, harvestLevel);
        ForgeHooks.toolEffectiveness.add(key);
    }
    
    public static void removeBlockEffectiveness(final aqz block, final int metadata, final String toolClass) {
        final List key = Arrays.asList(block, metadata, toolClass);
        ForgeHooks.toolEffectiveness.remove(key);
    }
    
    public static void setBlockHarvestLevel(final aqz block, final String toolClass, final int harvestLevel) {
        for (int metadata = 0; metadata < 16; ++metadata) {
            final List key = Arrays.asList(block, metadata, toolClass);
            ForgeHooks.toolHarvestLevels.put(key, harvestLevel);
            ForgeHooks.toolEffectiveness.add(key);
        }
    }
    
    public static int getBlockHarvestLevel(final aqz block, final int metadata, final String toolClass) {
        ForgeHooks.initTools();
        final List key = Arrays.asList(block, metadata, toolClass);
        final Integer harvestLevel = ForgeHooks.toolHarvestLevels.get(key);
        return (harvestLevel == null) ? -1 : harvestLevel;
    }
    
    public static void removeBlockEffectiveness(final aqz block, final String toolClass) {
        for (int metadata = 0; metadata < 16; ++metadata) {
            final List key = Arrays.asList(block, metadata, toolClass);
            ForgeHooks.toolEffectiveness.remove(key);
        }
    }
    
    public static void initialize() {
        System.out.printf("MinecraftForge v%s Initialized\n", ForgeVersion.getVersion());
        FMLLog.info("MinecraftForge v%s Initialized", ForgeVersion.getVersion());
        final aqz filler = new aqz(0, akc.a) {
            @SideOnly(Side.CLIENT)
            public void a(final mt register) {
            }
        };
        aqz.s[0] = null;
        aqz.t[0] = false;
        aqz.u[0] = 0;
        filler.c("ForgeFiller");
        for (int x = 256; x < 4096; ++x) {
            if (yc.g[x] != null) {
                aqz.s[x] = filler;
            }
        }
        final boolean[] temp = new boolean[4096];
        System.arraycopy(tg.br, 0, temp, 0, tg.br.length);
        tg.br = temp;
        MinecraftForge.EVENT_BUS.register(MinecraftForge.INTERNAL_HANDLER);
        OreDictionary.getOreName(0);
        new b("ThisIsFake", (Throwable)new Exception("Not real"));
    }
    
    public static String getBrandingVersion() {
        return "Minecraft Forge " + ForgeVersion.getVersion();
    }
    
    static {
        EVENT_BUS = new EventBus();
        TERRAIN_GEN_BUS = new EventBus();
        ORE_GEN_BUS = new EventBus();
        INTERNAL_HANDLER = new ForgeInternalHandler();
    }
}



================================================
FILE: net/minecraftforge/common/Property.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import java.util.ArrayList;

public class Property
{
    private String name;
    private String value;
    public String comment;
    private String[] values;
    private final boolean wasRead;
    private final boolean isList;
    private final Type type;
    private boolean changed;
    
    public Property() {
        this.changed = false;
        this.wasRead = false;
        this.type = null;
        this.isList = false;
    }
    
    public Property(final String name, final String value, final Type type) {
        this(name, value, type, false);
    }
    
    Property(final String name, final String value, final Type type, final boolean read) {
        this.changed = false;
        this.setName(name);
        this.value = value;
        this.type = type;
        this.wasRead = read;
        this.isList = false;
    }
    
    public Property(final String name, final String[] values, final Type type) {
        this(name, values, type, false);
    }
    
    Property(final String name, final String[] values, final Type type, final boolean read) {
        this.changed = false;
        this.setName(name);
        this.type = type;
        this.values = values;
        this.wasRead = read;
        this.isList = true;
    }
    
    public String getString() {
        return this.value;
    }
    
    public int getInt() {
        return this.getInt(-1);
    }
    
    public int getInt(final int _default) {
        try {
            return Integer.parseInt(this.value);
        }
        catch (final NumberFormatException e) {
            return _default;
        }
    }
    
    public boolean isIntValue() {
        try {
            Integer.parseInt(this.value);
            return true;
        }
        catch (final NumberFormatException e) {
            return false;
        }
    }
    
    public boolean getBoolean(final boolean _default) {
        if (this.isBooleanValue()) {
            return Boolean.parseBoolean(this.value);
        }
        return _default;
    }
    
    public boolean isBooleanValue() {
        return "true".equals(this.value.toLowerCase()) || "false".equals(this.value.toLowerCase());
    }
    
    public boolean isDoubleValue() {
        try {
            Double.parseDouble(this.value);
            return true;
        }
        catch (final NumberFormatException e) {
            return false;
        }
    }
    
    public double getDouble(final double _default) {
        try {
            return Double.parseDouble(this.value);
        }
        catch (final NumberFormatException e) {
            return _default;
        }
    }
    
    public String[] getStringList() {
        return this.values;
    }
    
    public int[] getIntList() {
        final ArrayList<Integer> nums = new ArrayList<Integer>();
        for (final String value : this.values) {
            try {
                nums.add(Integer.parseInt(value));
            }
            catch (final NumberFormatException ex) {}
        }
        final int[] primitives = new int[nums.size()];
        for (int i = 0; i < nums.size(); ++i) {
            primitives[i] = nums.get(i);
        }
        return primitives;
    }
    
    public boolean isIntList() {
        for (final String value : this.values) {
            try {
                Integer.parseInt(value);
            }
            catch (final NumberFormatException e) {
                return false;
            }
        }
        return true;
    }
    
    public boolean[] getBooleanList() {
        final ArrayList<Boolean> tmp = new ArrayList<Boolean>();
        for (final String value : this.values) {
            try {
                tmp.add(Boolean.parseBoolean(value));
            }
            catch (final NumberFormatException ex) {}
        }
        final boolean[] primitives = new boolean[tmp.size()];
        for (int i = 0; i < tmp.size(); ++i) {
            primitives[i] = tmp.get(i);
        }
        return primitives;
    }
    
    public boolean isBooleanList() {
        for (final String value : this.values) {
            if (!"true".equalsIgnoreCase(value) && !"false".equalsIgnoreCase(value)) {
                return false;
            }
        }
        return true;
    }
    
    public double[] getDoubleList() {
        final ArrayList<Double> tmp = new ArrayList<Double>();
        for (final String value : this.values) {
            try {
                tmp.add(Double.parseDouble(value));
            }
            catch (final NumberFormatException ex) {}
        }
        final double[] primitives = new double[tmp.size()];
        for (int i = 0; i < tmp.size(); ++i) {
            primitives[i] = tmp.get(i);
        }
        return primitives;
    }
    
    public boolean isDoubleList() {
        for (final String value : this.values) {
            try {
                Double.parseDouble(value);
            }
            catch (final NumberFormatException e) {
                return false;
            }
        }
        return true;
    }
    
    public String getName() {
        return this.name;
    }
    
    public void setName(final String name) {
        this.name = name;
    }
    
    public boolean wasRead() {
        return this.wasRead;
    }
    
    public Type getType() {
        return this.type;
    }
    
    public boolean isList() {
        return this.isList;
    }
    
    public boolean hasChanged() {
        return this.changed;
    }
    
    void resetChangedState() {
        this.changed = false;
    }
    
    public void set(final String value) {
        this.value = value;
        this.changed = true;
    }
    
    public void set(final String[] values) {
        this.values = values;
        this.changed = true;
    }
    
    public void set(final int value) {
        this.set(Integer.toString(value));
    }
    
    public void set(final boolean value) {
        this.set(Boolean.toString(value));
    }
    
    public void set(final double value) {
        this.set(Double.toString(value));
    }
    
    public enum Type
    {
        STRING, 
        INTEGER, 
        BOOLEAN, 
        DOUBLE;
        
        private static Type[] values;
        
        public static Type tryParse(final char id) {
            for (int x = 0; x < Type.values.length; ++x) {
                if (Type.values[x].getID() == id) {
                    return Type.values[x];
                }
            }
            return Type.STRING;
        }
        
        public char getID() {
            return this.name().charAt(0);
        }
        
        static {
            Type.values = new Type[] { Type.STRING, Type.INTEGER, Type.BOOLEAN, Type.DOUBLE };
        }
    }
}



================================================
FILE: net/minecraftforge/common/RotationHelper.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import com.google.common.collect.HashBiMap;
import java.util.HashMap;
import com.google.common.collect.BiMap;
import java.util.Map;

public class RotationHelper
{
    private static final ForgeDirection[] UP_DOWN_AXES;
    private static final Map<BlockType, BiMap<Integer, ForgeDirection>> MAPPINGS;
    
    public static ForgeDirection[] getValidVanillaBlockRotations(final aqz block) {
        return (block instanceof anb || block instanceof apy || block instanceof aog || block instanceof aqx || block instanceof ark || block instanceof anm || block instanceof apv || block instanceof anu || block instanceof aqp || block instanceof ank || block instanceof aod || block instanceof aok || block instanceof aoy || block.cF == aqz.aN.cF || block.cF == aqz.aI.cF || block instanceof anz || block instanceof aqa || block instanceof anf || block instanceof aqf || block instanceof anp || block instanceof ari || block instanceof aou || block instanceof arm || block instanceof aqk || block instanceof amv) ? RotationHelper.UP_DOWN_AXES : ForgeDirection.VALID_DIRECTIONS;
    }
    
    public static boolean rotateVanillaBlock(final aqz block, final abw worldObj, final int x, final int y, final int z, final ForgeDirection axis) {
        if (worldObj.I) {
            return false;
        }
        if (axis == ForgeDirection.UP || axis == ForgeDirection.DOWN) {
            if (block instanceof anb || block instanceof apy || block instanceof aog || block instanceof aqx || block instanceof ark || block instanceof anm) {
                return rotateBlock(worldObj, x, y, z, axis, 3, BlockType.BED);
            }
            if (block instanceof aqa) {
                return rotateBlock(worldObj, x, y, z, axis, 15, BlockType.RAIL);
            }
            if (block instanceof apv || block instanceof anu) {
                return rotateBlock(worldObj, x, y, z, axis, 7, BlockType.RAIL_POWERED);
            }
            if (block instanceof aqp) {
                return rotateBlock(worldObj, x, y, z, axis, 3, BlockType.STAIR);
            }
            if (block instanceof ank || block instanceof aod || block instanceof aok || block instanceof aoy || block.cF == aqz.aN.cF) {
                return rotateBlock(worldObj, x, y, z, axis, 7, BlockType.CHEST);
            }
            if (block.cF == aqz.aI.cF) {
                return rotateBlock(worldObj, x, y, z, axis, 15, BlockType.SIGNPOST);
            }
            if (block instanceof anz) {
                return rotateBlock(worldObj, x, y, z, axis, 3, BlockType.DOOR);
            }
            if (block instanceof anf) {
                return rotateBlock(worldObj, x, y, z, axis, 7, BlockType.BUTTON);
            }
            if (block instanceof aqf || block instanceof anp) {
                return rotateBlock(worldObj, x, y, z, axis, 3, BlockType.REDSTONE_REPEATER);
            }
            if (block instanceof ari) {
                return rotateBlock(worldObj, x, y, z, axis, 3, BlockType.TRAPDOOR);
            }
            if (block instanceof aou) {
                return rotateBlock(worldObj, x, y, z, axis, 15, BlockType.MUSHROOM_CAP);
            }
            if (block instanceof arm) {
                return rotateBlock(worldObj, x, y, z, axis, 15, BlockType.VINE);
            }
            if (block instanceof aqk) {
                return rotateBlock(worldObj, x, y, z, axis, 7, BlockType.SKULL);
            }
            if (block instanceof amv) {
                return rotateBlock(worldObj, x, y, z, axis, 1, BlockType.ANVIL);
            }
        }
        if (block instanceof arj) {
            return rotateBlock(worldObj, x, y, z, axis, 12, BlockType.LOG);
        }
        if (block instanceof any || block instanceof ast || block instanceof asu || block instanceof aot) {
            return rotateBlock(worldObj, x, y, z, axis, 7, BlockType.DISPENSER);
        }
        if (block instanceof arg) {
            return rotateBlock(worldObj, x, y, z, axis, 15, BlockType.TORCH);
        }
        return block instanceof apb && rotateBlock(worldObj, x, y, z, axis, 7, BlockType.LEVER);
    }
    
    private static boolean rotateBlock(final abw worldObj, final int x, final int y, final int z, final ForgeDirection axis, final int mask, final BlockType blockType) {
        final int rotMeta = worldObj.h(x, y, z);
        if (blockType == BlockType.DOOR && (rotMeta & 0x8) == 0x8) {
            return false;
        }
        final int masked = rotMeta & ~mask;
        final int meta = rotateMetadata(axis, blockType, rotMeta & mask);
        if (meta == -1) {
            return false;
        }
        worldObj.b(x, y, z, (meta & mask) | masked, 3);
        return true;
    }
    
    private static int rotateMetadata(final ForgeDirection axis, BlockType blockType, final int meta) {
        if (blockType == BlockType.RAIL || blockType == BlockType.RAIL_POWERED) {
            if (meta == 0 || meta == 1) {
                return ~meta & 0x1;
            }
            if (meta >= 2 && meta <= 5) {
                blockType = BlockType.RAIL_ASCENDING;
            }
            if (meta >= 6 && meta <= 9 && blockType == BlockType.RAIL) {
                blockType = BlockType.RAIL_CORNER;
            }
        }
        if (blockType == BlockType.SIGNPOST) {
            return (axis == ForgeDirection.UP) ? ((meta + 4) % 16) : ((meta + 12) % 16);
        }
        if (blockType == BlockType.LEVER && (axis == ForgeDirection.UP || axis == ForgeDirection.DOWN)) {
            switch (meta) {
                case 5: {
                    return 6;
                }
                case 6: {
                    return 5;
                }
                case 7: {
                    return 0;
                }
                case 0: {
                    return 7;
                }
            }
        }
        if (blockType == BlockType.MUSHROOM_CAP) {
            if (meta % 2 == 0) {
                blockType = BlockType.MUSHROOM_CAP_SIDE;
            }
            else {
                blockType = BlockType.MUSHROOM_CAP_CORNER;
            }
        }
        if (blockType == BlockType.VINE) {
            return meta << 1 | (meta & 0x8) >> 3;
        }
        final ForgeDirection orientation = metadataToDirection(blockType, meta);
        final ForgeDirection rotated = orientation.getRotation(axis);
        return directionToMetadata(blockType, rotated);
    }
    
    private static ForgeDirection metadataToDirection(final BlockType blockType, int meta) {
        if (blockType == BlockType.LEVER) {
            if (meta == 6) {
                meta = 5;
            }
            else if (meta == 0) {
                meta = 7;
            }
        }
        if (RotationHelper.MAPPINGS.containsKey(blockType)) {
            final BiMap<Integer, ForgeDirection> biMap = RotationHelper.MAPPINGS.get(blockType);
            if (biMap.containsKey((Object)meta)) {
                return (ForgeDirection)biMap.get((Object)meta);
            }
        }
        if (blockType == BlockType.TORCH) {
            return ForgeDirection.getOrientation(6 - meta);
        }
        if (blockType == BlockType.STAIR) {
            return ForgeDirection.getOrientation(5 - meta);
        }
        if (blockType == BlockType.CHEST || blockType == BlockType.DISPENSER || blockType == BlockType.SKULL) {
            return ForgeDirection.getOrientation(meta);
        }
        if (blockType == BlockType.BUTTON) {
            return ForgeDirection.getOrientation(6 - meta);
        }
        if (blockType == BlockType.TRAPDOOR) {
            return ForgeDirection.getOrientation(meta + 2).getOpposite();
        }
        return ForgeDirection.UNKNOWN;
    }
    
    private static int directionToMetadata(final BlockType blockType, ForgeDirection direction) {
        if ((blockType == BlockType.LOG || blockType == BlockType.ANVIL) && direction.offsetX + direction.offsetY + direction.offsetZ < 0) {
            direction = direction.getOpposite();
        }
        if (RotationHelper.MAPPINGS.containsKey(blockType)) {
            final BiMap<ForgeDirection, Integer> biMap = (BiMap<ForgeDirection, Integer>)RotationHelper.MAPPINGS.get(blockType).inverse();
            if (biMap.containsKey((Object)direction)) {
                return (int)biMap.get((Object)direction);
            }
        }
        if (blockType == BlockType.TORCH && direction.ordinal() >= 1) {
            return 6 - direction.ordinal();
        }
        if (blockType == BlockType.STAIR) {
            return 5 - direction.ordinal();
        }
        if (blockType == BlockType.CHEST || blockType == BlockType.DISPENSER || blockType == BlockType.SKULL) {
            return direction.ordinal();
        }
        if (blockType == BlockType.BUTTON && direction.ordinal() >= 2) {
            return 6 - direction.ordinal();
        }
        if (blockType == BlockType.TRAPDOOR) {
            return direction.getOpposite().ordinal() - 2;
        }
        return -1;
    }
    
    static {
        UP_DOWN_AXES = new ForgeDirection[] { ForgeDirection.UP, ForgeDirection.DOWN };
        MAPPINGS = new HashMap<BlockType, BiMap<Integer, ForgeDirection>>();
        BiMap<Integer, ForgeDirection> biMap = (BiMap<Integer, ForgeDirection>)HashBiMap.create(3);
        biMap.put((Object)0, (Object)ForgeDirection.UP);
        biMap.put((Object)4, (Object)ForgeDirection.EAST);
        biMap.put((Object)8, (Object)ForgeDirection.SOUTH);
        RotationHelper.MAPPINGS.put(BlockType.LOG, biMap);
        biMap = (BiMap<Integer, ForgeDirection>)HashBiMap.create(4);
        biMap.put((Object)0, (Object)ForgeDirection.SOUTH);
        biMap.put((Object)1, (Object)ForgeDirection.WEST);
        biMap.put((Object)2, (Object)ForgeDirection.NORTH);
        biMap.put((Object)3, (Object)ForgeDirection.EAST);
        RotationHelper.MAPPINGS.put(BlockType.BED, biMap);
        biMap = (BiMap<Integer, ForgeDirection>)HashBiMap.create(4);
        biMap.put((Object)2, (Object)ForgeDirection.EAST);
        biMap.put((Object)3, (Object)ForgeDirection.WEST);
        biMap.put((Object)4, (Object)ForgeDirection.NORTH);
        biMap.put((Object)5, (Object)ForgeDirection.SOUTH);
        RotationHelper.MAPPINGS.put(BlockType.RAIL_ASCENDING, biMap);
        biMap = (BiMap<Integer, ForgeDirection>)HashBiMap.create(4);
        biMap.put((Object)6, (Object)ForgeDirection.WEST);
        biMap.put((Object)7, (Object)ForgeDirection.NORTH);
        biMap.put((Object)8, (Object)ForgeDirection.EAST);
        biMap.put((Object)9, (Object)ForgeDirection.SOUTH);
        RotationHelper.MAPPINGS.put(BlockType.RAIL_CORNER, biMap);
        biMap = (BiMap<Integer, ForgeDirection>)HashBiMap.create(6);
        biMap.put((Object)1, (Object)ForgeDirection.EAST);
        biMap.put((Object)2, (Object)ForgeDirection.WEST);
        biMap.put((Object)3, (Object)ForgeDirection.SOUTH);
        biMap.put((Object)4, (Object)ForgeDirection.NORTH);
        biMap.put((Object)5, (Object)ForgeDirection.UP);
        biMap.put((Object)7, (Object)ForgeDirection.DOWN);
        RotationHelper.MAPPINGS.put(BlockType.LEVER, biMap);
        biMap = (BiMap<Integer, ForgeDirection>)HashBiMap.create(4);
        biMap.put((Object)0, (Object)ForgeDirection.WEST);
        biMap.put((Object)1, (Object)ForgeDirection.NORTH);
        biMap.put((Object)2, (Object)ForgeDirection.EAST);
        biMap.put((Object)3, (Object)ForgeDirection.SOUTH);
        RotationHelper.MAPPINGS.put(BlockType.DOOR, biMap);
        biMap = (BiMap<Integer, ForgeDirection>)HashBiMap.create(4);
        biMap.put((Object)0, (Object)ForgeDirection.NORTH);
        biMap.put((Object)1, (Object)ForgeDirection.EAST);
        biMap.put((Object)2, (Object)ForgeDirection.SOUTH);
        biMap.put((Object)3, (Object)ForgeDirection.WEST);
        RotationHelper.MAPPINGS.put(BlockType.REDSTONE_REPEATER, biMap);
        biMap = (BiMap<Integer, ForgeDirection>)HashBiMap.create(4);
        biMap.put((Object)1, (Object)ForgeDirection.EAST);
        biMap.put((Object)3, (Object)ForgeDirection.SOUTH);
        biMap.put((Object)7, (Object)ForgeDirection.NORTH);
        biMap.put((Object)9, (Object)ForgeDirection.WEST);
        RotationHelper.MAPPINGS.put(BlockType.MUSHROOM_CAP_CORNER, biMap);
        biMap = (BiMap<Integer, ForgeDirection>)HashBiMap.create(4);
        biMap.put((Object)2, (Object)ForgeDirection.NORTH);
        biMap.put((Object)4, (Object)ForgeDirection.WEST);
        biMap.put((Object)6, (Object)ForgeDirection.EAST);
        biMap.put((Object)8, (Object)ForgeDirection.SOUTH);
        RotationHelper.MAPPINGS.put(BlockType.MUSHROOM_CAP_SIDE, biMap);
        biMap = (BiMap<Integer, ForgeDirection>)HashBiMap.create(2);
        biMap.put((Object)0, (Object)ForgeDirection.SOUTH);
        biMap.put((Object)1, (Object)ForgeDirection.EAST);
        RotationHelper.MAPPINGS.put(BlockType.ANVIL, biMap);
    }
    
    private enum BlockType
    {
        LOG, 
        DISPENSER, 
        BED, 
        RAIL, 
        RAIL_POWERED, 
        RAIL_ASCENDING, 
        RAIL_CORNER, 
        TORCH, 
        STAIR, 
        CHEST, 
        SIGNPOST, 
        DOOR, 
        LEVER, 
        BUTTON, 
        REDSTONE_REPEATER, 
        TRAPDOOR, 
        MUSHROOM_CAP, 
        MUSHROOM_CAP_CORNER, 
        MUSHROOM_CAP_SIDE, 
        VINE, 
        SKULL, 
        ANVIL;
    }
}



================================================
FILE: net/minecraftforge/common/WorldSpecificSaveHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common;

import java.io.File;

public class WorldSpecificSaveHandler implements amc
{
    private js world;
    private amc parent;
    private File dataDir;
    
    public WorldSpecificSaveHandler(final js world, final amc parent) {
        this.world = world;
        this.parent = parent;
        (this.dataDir = new File(world.getChunkSaveLocation(), "data")).mkdirs();
    }
    
    public als d() {
        return this.parent.d();
    }
    
    public void c() throws aca {
        this.parent.c();
    }
    
    public adw a(final aei var1) {
        return this.parent.a(var1);
    }
    
    public void a(final als var1, final by var2) {
        this.parent.a(var1, var2);
    }
    
    public void a(final als var1) {
        this.parent.a(var1);
    }
    
    public amq e() {
        return this.parent.e();
    }
    
    public void a() {
        this.parent.a();
    }
    
    public String g() {
        return this.parent.g();
    }
    
    public File b(final String name) {
        return new File(this.dataDir, name + ".dat");
    }
}



================================================
FILE: net/minecraftforge/common/network/ForgeConnectionHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common.network;

import net.minecraft.server.MinecraftServer;
import cpw.mods.fml.common.network.PacketDispatcher;
import net.minecraftforge.fluids.FluidIdMapPacket;
import cpw.mods.fml.common.network.Player;
import cpw.mods.fml.common.network.IConnectionHandler;

public class ForgeConnectionHandler implements IConnectionHandler
{
    @Override
    public void playerLoggedIn(final Player player, final ez netHandler, final cm manager) {
        final ea[] fluidPackets = ForgePacket.makePacketSet(new FluidIdMapPacket());
        for (int i = 0; i < fluidPackets.length; ++i) {
            PacketDispatcher.sendPacketToPlayer((ey)fluidPackets[i], player);
        }
    }
    
    @Override
    public String connectionReceived(final jy netHandler, final cm manager) {
        return null;
    }
    
    @Override
    public void connectionOpened(final ez netClientHandler, final String server, final int port, final cm manager) {
    }
    
    @Override
    public void connectionOpened(final ez netClientHandler, final MinecraftServer server, final cm manager) {
    }
    
    @Override
    public void connectionClosed(final cm manager) {
    }
    
    @Override
    public void clientLoggedIn(final ez clientHandler, final cm manager, final ep login) {
    }
}



================================================
FILE: net/minecraftforge/common/network/ForgeNetworkHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common.network;

import cpw.mods.fml.common.ModContainer;
import cpw.mods.fml.common.network.NetworkMod;
import net.minecraftforge.common.ForgeDummyContainer;
import cpw.mods.fml.common.network.NetworkModHandler;

public class ForgeNetworkHandler extends NetworkModHandler
{
    public ForgeNetworkHandler(final ForgeDummyContainer container) {
        super(container, container.getClass().getAnnotation(NetworkMod.class));
        this.configureNetworkMod(container);
    }
    
    @Override
    public boolean acceptVersion(final String version) {
        return true;
    }
}



================================================
FILE: net/minecraftforge/common/network/ForgePacket.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common.network;

import net.minecraftforge.fluids.FluidIdMapPacket;
import net.minecraftforge.common.network.packet.DimensionRegisterPacket;
import com.google.common.io.ByteArrayDataInput;
import com.google.common.io.ByteStreams;
import com.google.common.collect.MapMaker;
import cpw.mods.fml.common.network.FMLNetworkException;
import cpw.mods.fml.common.FMLLog;
import java.util.logging.Level;
import com.google.common.base.Throwables;
import java.util.concurrent.ConcurrentMap;
import java.util.Arrays;
import com.google.common.primitives.Ints;
import com.google.common.primitives.Bytes;
import com.google.common.primitives.UnsignedBytes;

public abstract class ForgePacket
{
    public static final String CHANNEL_ID = "FORGE";
    private Type type;
    private byte[][] partials;
    
    public static ea[] makePacketSet(final ForgePacket packet) {
        final byte[] packetData = packet.generatePacket();
        if (packetData.length < 32000) {
            return new ea[] { new ea("FORGE", Bytes.concat(new byte[][] { { UnsignedBytes.checkedCast(0L), UnsignedBytes.checkedCast((long)packet.getID()) }, packetData })) };
        }
        final byte[][] chunks = new byte[packetData.length / 32000 + 1][];
        for (int i = 0; i < packetData.length / 32000 + 1; ++i) {
            final int len = Math.min(32000, packetData.length - i * 32000);
            chunks[i] = Bytes.concat(new byte[][] { { UnsignedBytes.checkedCast(1L), UnsignedBytes.checkedCast((long)packet.getID()), UnsignedBytes.checkedCast((long)i), UnsignedBytes.checkedCast((long)chunks.length) }, Ints.toByteArray(len), Arrays.copyOfRange(packetData, i * 32000, len + i * 32000) });
        }
        final ea[] ret = new ea[chunks.length];
        for (int j = 0; j < chunks.length; ++j) {
            ret[j] = new ea("FORGE", chunks[j]);
        }
        return ret;
    }
    
    public static ForgePacket readPacket(final cm network, final byte[] payload) {
        final boolean multipart = UnsignedBytes.toInt(payload[0]) == 1;
        final int type = UnsignedBytes.toInt(payload[1]);
        final Type eType = Type.values()[type];
        final byte[] data = Arrays.copyOfRange(payload, 2, payload.length);
        if (!multipart) {
            return eType.make().consumePacket(data);
        }
        final ForgePacket pkt = eType.consumePart(network, data);
        if (pkt != null) {
            return pkt.consumePacket(Bytes.concat(pkt.partials));
        }
        return null;
    }
    
    public ForgePacket() {
        for (final Type t : Type.values()) {
            if (t.packetType == this.getClass()) {
                this.type = t;
            }
        }
        if (this.type == null) {
            throw new RuntimeException("ForgePacket constructor called on ungregistered type.");
        }
    }
    
    public byte getID() {
        return UnsignedBytes.checkedCast((long)this.type.ordinal());
    }
    
    public abstract byte[] generatePacket();
    
    public abstract ForgePacket consumePacket(final byte[] p0);
    
    public abstract void execute(final cm p0, final uf p1);
    
    enum Type
    {
        REGISTERDIMENSION((Class<? extends ForgePacket>)DimensionRegisterPacket.class), 
        FLUID_IDMAP((Class<? extends ForgePacket>)FluidIdMapPacket.class);
        
        private Class<? extends ForgePacket> packetType;
        private ConcurrentMap<cm, ForgePacket> partTracker;
        
        private Type(final Class<? extends ForgePacket> clazz) {
            this.packetType = clazz;
        }
        
        ForgePacket make() {
            try {
                return (ForgePacket)this.packetType.newInstance();
            }
            catch (final Exception e) {
                Throwables.propagateIfPossible((Throwable)e);
                FMLLog.log(Level.SEVERE, e, "A bizarre critical error occured during packet encoding", new Object[0]);
                throw new FMLNetworkException(e);
            }
        }
        
        private ForgePacket consumePart(final cm network, final byte[] data) {
            if (this.partTracker == null) {
                this.partTracker = new MapMaker().weakKeys().weakValues().makeMap();
            }
            if (!this.partTracker.containsKey(network)) {
                this.partTracker.put(network, this.make());
            }
            final ForgePacket pkt = this.partTracker.get(network);
            final ByteArrayDataInput bdi = ByteStreams.newDataInput(data);
            final int chunkIdx = UnsignedBytes.toInt(bdi.readByte());
            final int chunkTotal = UnsignedBytes.toInt(bdi.readByte());
            final int chunkLength = bdi.readInt();
            if (pkt.partials == null) {
                pkt.partials = new byte[chunkTotal][];
            }
            bdi.readFully(pkt.partials[chunkIdx] = new byte[chunkLength]);
            for (int i = 0; i < pkt.partials.length; ++i) {
                if (pkt.partials[i] == null) {
                    return null;
                }
            }
            return pkt;
        }
    }
}



================================================
FILE: net/minecraftforge/common/network/ForgePacketHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common.network;

import cpw.mods.fml.common.network.Player;
import cpw.mods.fml.common.network.IPacketHandler;

public class ForgePacketHandler implements IPacketHandler
{
    @Override
    public void onPacketData(final cm network, final ea packet, final Player player) {
        final ForgePacket pkt = ForgePacket.readPacket(network, packet.c);
        if (pkt == null) {
            return;
        }
        pkt.execute(network, (uf)player);
    }
}



================================================
FILE: net/minecraftforge/common/network/ForgeTinyPacketHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common.network;

import cpw.mods.fml.common.network.ITinyPacketHandler;

public class ForgeTinyPacketHandler implements ITinyPacketHandler
{
    @Override
    public void handle(final ez handler, final dr mapData) {
    }
}



================================================
FILE: net/minecraftforge/common/network/packet/DimensionRegisterPacket.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.common.network.packet;

import net.minecraftforge.common.DimensionManager;
import com.google.common.io.ByteArrayDataInput;
import com.google.common.io.ByteArrayDataOutput;
import com.google.common.io.ByteStreams;
import net.minecraftforge.common.network.ForgePacket;

public class DimensionRegisterPacket extends ForgePacket
{
    public int dimensionId;
    public int providerId;
    
    public DimensionRegisterPacket() {
    }
    
    public DimensionRegisterPacket(final int dimensionId, final int providerId) {
        this.dimensionId = dimensionId;
        this.providerId = providerId;
    }
    
    @Override
    public byte[] generatePacket() {
        final ByteArrayDataOutput dat = ByteStreams.newDataOutput();
        dat.writeInt(this.dimensionId);
        dat.writeInt(this.providerId);
        return dat.toByteArray();
    }
    
    @Override
    public ForgePacket consumePacket(final byte[] data) {
        final ByteArrayDataInput dat = ByteStreams.newDataInput(data);
        this.dimensionId = dat.readInt();
        this.providerId = dat.readInt();
        return this;
    }
    
    @Override
    public void execute(final cm network, final uf player) {
        if (!(player instanceof jv) && !DimensionManager.isDimensionRegistered(this.dimensionId)) {
            DimensionManager.registerDimension(this.dimensionId, this.providerId);
        }
    }
}



================================================
FILE: net/minecraftforge/event/ASMEventHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event;

import com.google.common.collect.Maps;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Type;
import org.objectweb.asm.ClassWriter;
import java.lang.reflect.Method;
import java.util.HashMap;

public class ASMEventHandler implements IEventListener
{
    private static int IDs;
    private static final String HANDLER_DESC;
    private static final String HANDLER_FUNC_DESC;
    private static final ASMClassLoader LOADER;
    private static final HashMap<Method, Class<?>> cache;
    private final IEventListener handler;
    private final ForgeSubscribe subInfo;
    
    public ASMEventHandler(final Object target, final Method method) throws Exception {
        this.handler = (IEventListener)this.createWrapper(method).getConstructor(Object.class).newInstance(target);
        this.subInfo = method.getAnnotation(ForgeSubscribe.class);
    }
    
    @Override
    public void invoke(final Event event) {
        if (this.handler != null && (!event.isCancelable() || !event.isCanceled() || this.subInfo.receiveCanceled())) {
            this.handler.invoke(event);
        }
    }
    
    public EventPriority getPriority() {
        return this.subInfo.priority();
    }
    
    public Class<?> createWrapper(final Method callback) {
        if (ASMEventHandler.cache.containsKey(callback)) {
            return ASMEventHandler.cache.get(callback);
        }
        final ClassWriter cw = new ClassWriter(0);
        final String name = this.getUniqueName(callback);
        final String desc = name.replace('.', '/');
        final String instType = Type.getInternalName((Class)callback.getDeclaringClass());
        final String eventType = Type.getInternalName((Class)callback.getParameterTypes()[0]);
        cw.visit(50, 33, desc, (String)null, "java/lang/Object", new String[] { ASMEventHandler.HANDLER_DESC });
        cw.visitSource(".dynamic", (String)null);
        cw.visitField(1, "instance", "Ljava/lang/Object;", (String)null, (Object)null).visitEnd();
        MethodVisitor mv = cw.visitMethod(1, "<init>", "(Ljava/lang/Object;)V", (String)null, (String[])null);
        mv.visitCode();
        mv.visitVarInsn(25, 0);
        mv.visitMethodInsn(183, "java/lang/Object", "<init>", "()V");
        mv.visitVarInsn(25, 0);
        mv.visitVarInsn(25, 1);
        mv.visitFieldInsn(181, desc, "instance", "Ljava/lang/Object;");
        mv.visitInsn(177);
        mv.visitMaxs(2, 2);
        mv.visitEnd();
        mv = cw.visitMethod(1, "invoke", ASMEventHandler.HANDLER_FUNC_DESC, (String)null, (String[])null);
        mv.visitCode();
        mv.visitVarInsn(25, 0);
        mv.visitFieldInsn(180, desc, "instance", "Ljava/lang/Object;");
        mv.visitTypeInsn(192, instType);
        mv.visitVarInsn(25, 1);
        mv.visitTypeInsn(192, eventType);
        mv.visitMethodInsn(182, instType, callback.getName(), Type.getMethodDescriptor(callback));
        mv.visitInsn(177);
        mv.visitMaxs(2, 2);
        mv.visitEnd();
        cw.visitEnd();
        final Class<?> ret = ASMEventHandler.LOADER.define(name, cw.toByteArray());
        ASMEventHandler.cache.put(callback, ret);
        return ret;
    }
    
    private String getUniqueName(final Method callback) {
        return String.format("%s_%d_%s_%s_%s", this.getClass().getName(), ASMEventHandler.IDs++, callback.getDeclaringClass().getSimpleName(), callback.getName(), callback.getParameterTypes()[0].getSimpleName());
    }
    
    static {
        ASMEventHandler.IDs = 0;
        HANDLER_DESC = Type.getInternalName((Class)IEventListener.class);
        HANDLER_FUNC_DESC = Type.getMethodDescriptor(IEventListener.class.getDeclaredMethods()[0]);
        LOADER = new ASMClassLoader();
        cache = Maps.newHashMap();
    }
    
    private static class ASMClassLoader extends ClassLoader
    {
        private ASMClassLoader() {
            super(ASMClassLoader.class.getClassLoader());
        }
        
        public Class<?> define(final String name, final byte[] data) {
            return this.defineClass(name, data, 0, data.length);
        }
    }
}



================================================
FILE: net/minecraftforge/event/Cancelable.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event;

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Retention;

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE })
public @interface Cancelable {
}



================================================
FILE: net/minecraftforge/event/CommandEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event;

@Cancelable
public class CommandEvent extends Event
{
    public final ab command;
    public final ad sender;
    public String[] parameters;
    public Throwable exception;
    
    public CommandEvent(final ab command, final ad sender, final String[] parameters) {
        this.command = command;
        this.sender = sender;
        this.parameters = parameters;
    }
}



================================================
FILE: net/minecraftforge/event/Event.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event;

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Retention;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Map;

public class Event
{
    private boolean isCanceled;
    private final boolean isCancelable;
    private Result result;
    private final boolean hasResult;
    private static ListenerList listeners;
    private static final Map<Class, Map<Class, Boolean>> annotationMap;
    
    public Event() {
        this.isCanceled = false;
        this.result = Result.DEFAULT;
        this.setup();
        this.isCancelable = this.hasAnnotation(Cancelable.class);
        this.hasResult = this.hasAnnotation(HasResult.class);
    }
    
    private boolean hasAnnotation(final Class annotation) {
        final Class me = this.getClass();
        Map<Class, Boolean> list = Event.annotationMap.get(me);
        if (list == null) {
            list = new ConcurrentHashMap<Class, Boolean>();
            Event.annotationMap.put(me, list);
        }
        final Boolean cached = list.get(annotation);
        if (cached != null) {
            return cached;
        }
        for (Class cls = me; cls != Event.class; cls = cls.getSuperclass()) {
            if (cls.isAnnotationPresent(annotation)) {
                list.put(annotation, true);
                return true;
            }
        }
        list.put(annotation, false);
        return false;
    }
    
    public boolean isCancelable() {
        return this.isCancelable;
    }
    
    public boolean isCanceled() {
        return this.isCanceled;
    }
    
    public void setCanceled(final boolean cancel) {
        if (!this.isCancelable()) {
            throw new IllegalArgumentException("Attempted to cancel a uncancelable event");
        }
        this.isCanceled = cancel;
    }
    
    public boolean hasResult() {
        return this.hasResult;
    }
    
    public Result getResult() {
        return this.result;
    }
    
    public void setResult(final Result value) {
        this.result = value;
    }
    
    protected void setup() {
    }
    
    public ListenerList getListenerList() {
        return Event.listeners;
    }
    
    static {
        Event.listeners = new ListenerList();
        annotationMap = new ConcurrentHashMap<Class, Map<Class, Boolean>>();
    }
    
    public enum Result
    {
        DENY, 
        DEFAULT, 
        ALLOW;
    }
    
    @Retention(RetentionPolicy.RUNTIME)
    @Target({ ElementType.TYPE })
    public @interface HasResult {
    }
}



================================================
FILE: net/minecraftforge/event/EventBus.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event;

import java.lang.reflect.Constructor;
import java.util.Iterator;
import java.lang.reflect.Method;
import java.util.Set;
import java.lang.annotation.Annotation;
import com.google.common.reflect.TypeToken;
import java.util.ArrayList;
import java.util.concurrent.ConcurrentHashMap;

public class EventBus
{
    private static int maxID;
    private ConcurrentHashMap<Object, ArrayList<IEventListener>> listeners;
    private final int busID;
    
    public EventBus() {
        this.listeners = new ConcurrentHashMap<Object, ArrayList<IEventListener>>();
        this.busID = EventBus.maxID++;
        ListenerList.resize(this.busID + 1);
    }
    
    public void register(final Object target) {
        if (this.listeners.containsKey(target)) {
            return;
        }
        final Set<? extends Class<?>> supers = TypeToken.of((Class)target.getClass()).getTypes().rawTypes();
        for (final Method method : target.getClass().getMethods()) {
            for (final Class<?> cls : supers) {
                try {
                    final Method real = cls.getDeclaredMethod(method.getName(), method.getParameterTypes());
                    if (!real.isAnnotationPresent(ForgeSubscribe.class)) {
                        continue;
                    }
                    final Class<?>[] parameterTypes = method.getParameterTypes();
                    if (parameterTypes.length != 1) {
                        throw new IllegalArgumentException("Method " + method + " has @ForgeSubscribe annotation, but requires " + parameterTypes.length + " arguments.  Event handler methods must require a single argument.");
                    }
                    final Class<?> eventType = parameterTypes[0];
                    if (!Event.class.isAssignableFrom(eventType)) {
                        throw new IllegalArgumentException("Method " + method + " has @ForgeSubscribe annotation, but takes a argument that is not a Event " + eventType);
                    }
                    this.register(eventType, target, method);
                    break;
                }
                catch (final NoSuchMethodException ex) {}
            }
        }
    }
    
    private void register(final Class<?> eventType, final Object target, final Method method) {
        try {
            final Constructor<?> ctr = eventType.getConstructor((Class<?>[])new Class[0]);
            ctr.setAccessible(true);
            final Event event = (Event)ctr.newInstance(new Object[0]);
            final ASMEventHandler listener = new ASMEventHandler(target, method);
            event.getListenerList().register(this.busID, listener.getPriority(), listener);
            ArrayList<IEventListener> others = this.listeners.get(target);
            if (others == null) {
                others = new ArrayList<IEventListener>();
                this.listeners.put(target, others);
            }
            others.add(listener);
        }
        catch (final Exception e) {
            e.printStackTrace();
        }
    }
    
    public void unregister(final Object object) {
        final ArrayList<IEventListener> list = this.listeners.remove(object);
        for (final IEventListener listener : list) {
            ListenerList.unregiterAll(this.busID, listener);
        }
    }
    
    public boolean post(final Event event) {
        final IEventListener[] arr$;
        final IEventListener[] listeners = arr$ = event.getListenerList().getListeners(this.busID);
        for (final IEventListener listener : arr$) {
            listener.invoke(event);
        }
        return event.isCancelable() && event.isCanceled();
    }
    
    static {
        EventBus.maxID = 0;
    }
}



================================================
FILE: net/minecraftforge/event/EventPriority.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event;

public enum EventPriority
{
    HIGHEST, 
    HIGH, 
    NORMAL, 
    LOW, 
    LOWEST;
}



================================================
FILE: net/minecraftforge/event/ForgeEventFactory.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event;

import net.minecraftforge.event.entity.living.ZombieEvent;
import net.minecraftforge.event.entity.player.ItemTooltipEvent;
import net.minecraftforge.event.world.BlockEvent;
import java.util.ArrayList;
import net.minecraftforge.event.entity.living.LivingPackSizeEvent;
import net.minecraftforge.event.world.WorldEvent;
import java.util.List;
import net.minecraftforge.event.entity.living.LivingSpawnEvent;
import net.minecraftforge.event.entity.player.PlayerDestroyItemEvent;
import net.minecraftforge.event.entity.player.PlayerInteractEvent;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.event.entity.player.PlayerEvent;

public class ForgeEventFactory
{
    public static boolean doPlayerHarvestCheck(final uf player, final aqz block, final boolean success) {
        final PlayerEvent.HarvestCheck event = new PlayerEvent.HarvestCheck(player, block, success);
        MinecraftForge.EVENT_BUS.post(event);
        return event.success;
    }
    
    public static float getBreakSpeed(final uf player, final aqz block, final int metadata, final float original) {
        final PlayerEvent.BreakSpeed event = new PlayerEvent.BreakSpeed(player, block, metadata, original);
        return MinecraftForge.EVENT_BUS.post(event) ? -1.0f : event.newSpeed;
    }
    
    public static PlayerInteractEvent onPlayerInteract(final uf player, final PlayerInteractEvent.Action action, final int x, final int y, final int z, final int face) {
        final PlayerInteractEvent event = new PlayerInteractEvent(player, action, x, y, z, face);
        MinecraftForge.EVENT_BUS.post(event);
        return event;
    }
    
    public static void onPlayerDestroyItem(final uf player, final ye stack) {
        MinecraftForge.EVENT_BUS.post(new PlayerDestroyItemEvent(player, stack));
    }
    
    public static Event.Result canEntitySpawn(final og entity, final abw world, final float x, final float y, final float z) {
        final LivingSpawnEvent.CheckSpawn event = new LivingSpawnEvent.CheckSpawn(entity, world, x, y, z);
        MinecraftForge.EVENT_BUS.post(event);
        return event.getResult();
    }
    
    public static boolean doSpecialSpawn(final og entity, final abw world, final float x, final float y, final float z) {
        return MinecraftForge.EVENT_BUS.post(new LivingSpawnEvent.SpecialSpawn(entity, world, x, y, z));
    }
    
    public static Event.Result canEntityDespawn(final og entity) {
        final LivingSpawnEvent.AllowDespawn event = new LivingSpawnEvent.AllowDespawn(entity);
        MinecraftForge.EVENT_BUS.post(event);
        return event.getResult();
    }
    
    public static List getPotentialSpawns(final js world, final oh type, final int x, final int y, final int z, final List oldList) {
        final WorldEvent.PotentialSpawns event = new WorldEvent.PotentialSpawns((abw)world, type, x, y, z, oldList);
        if (MinecraftForge.EVENT_BUS.post(event)) {
            return null;
        }
        return event.list;
    }
    
    public static int getMaxSpawnPackSize(final og entity) {
        final LivingPackSizeEvent maxCanSpawnEvent = new LivingPackSizeEvent(entity);
        MinecraftForge.EVENT_BUS.post(maxCanSpawnEvent);
        return (maxCanSpawnEvent.getResult() == Event.Result.ALLOW) ? maxCanSpawnEvent.maxPackSize : entity.bv();
    }
    
    public static String getPlayerDisplayName(final uf player, final String username) {
        final PlayerEvent.NameFormat event = new PlayerEvent.NameFormat(player, username);
        MinecraftForge.EVENT_BUS.post(event);
        return event.displayname;
    }
    
    public static float fireBlockHarvesting(final ArrayList<ye> drops, final abw world, final aqz block, final int x, final int y, final int z, final int meta, final int fortune, final float dropChance, final boolean silkTouch, final uf player) {
        final BlockEvent.HarvestDropsEvent event = new BlockEvent.HarvestDropsEvent(x, y, z, world, block, meta, fortune, dropChance, drops, player, silkTouch);
        MinecraftForge.EVENT_BUS.post(event);
        return event.dropChance;
    }
    
    public static ItemTooltipEvent onItemTooltip(final ye itemStack, final uf entityPlayer, final List<String> toolTip, final boolean showAdvancedItemTooltips) {
        final ItemTooltipEvent event = new ItemTooltipEvent(itemStack, entityPlayer, toolTip, showAdvancedItemTooltips);
        MinecraftForge.EVENT_BUS.post(event);
        return event;
    }
    
    public static ZombieEvent.SummonAidEvent fireZombieSummonAid(final tw zombie, final abw world, final int x, final int y, final int z, final of attacker, final double summonChance) {
        final ZombieEvent.SummonAidEvent summonEvent = new ZombieEvent.SummonAidEvent(zombie, world, x, y, z, attacker, summonChance);
        MinecraftForge.EVENT_BUS.post(summonEvent);
        return summonEvent;
    }
}



================================================
FILE: net/minecraftforge/event/ForgeSubscribe.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event;

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Retention;

@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD })
public @interface ForgeSubscribe {
    EventPriority priority() default EventPriority.NORMAL;
    
    boolean receiveCanceled() default false;
}



================================================
FILE: net/minecraftforge/event/IEventListener.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event;

public interface IEventListener
{
    void invoke(final Event p0);
}



================================================
FILE: net/minecraftforge/event/ListenerList.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event;

import java.util.Collection;
import java.util.Iterator;
import java.util.ArrayList;

public class ListenerList
{
    private static ArrayList<ListenerList> allLists;
    private static int maxSize;
    private ListenerList parent;
    private ListenerListInst[] lists;
    
    public ListenerList() {
        this.lists = new ListenerListInst[0];
        ListenerList.allLists.add(this);
        this.resizeLists(ListenerList.maxSize);
    }
    
    public ListenerList(final ListenerList parent) {
        this.lists = new ListenerListInst[0];
        ListenerList.allLists.add(this);
        this.parent = parent;
        this.resizeLists(ListenerList.maxSize);
    }
    
    public static void resize(final int max) {
        if (max <= ListenerList.maxSize) {
            return;
        }
        for (final ListenerList list : ListenerList.allLists) {
            list.resizeLists(max);
        }
        ListenerList.maxSize = max;
    }
    
    public void resizeLists(final int max) {
        if (this.parent != null) {
            this.parent.resizeLists(max);
        }
        if (this.lists.length >= max) {
            return;
        }
        final ListenerListInst[] newList = new ListenerListInst[max];
        int x;
        for (x = 0; x < this.lists.length; ++x) {
            newList[x] = this.lists[x];
        }
        while (x < max) {
            if (this.parent != null) {
                newList[x] = new ListenerListInst(this.parent.getInstance(x));
            }
            else {
                newList[x] = new ListenerListInst();
            }
            ++x;
        }
        this.lists = newList;
    }
    
    public static void clearBusID(final int id) {
        for (final ListenerList list : ListenerList.allLists) {
            list.lists[id].dispose();
        }
    }
    
    protected ListenerListInst getInstance(final int id) {
        return this.lists[id];
    }
    
    public IEventListener[] getListeners(final int id) {
        return this.lists[id].getListeners();
    }
    
    public void register(final int id, final EventPriority priority, final IEventListener listener) {
        this.lists[id].register(priority, listener);
    }
    
    public void unregister(final int id, final IEventListener listener) {
        this.lists[id].unregister(listener);
    }
    
    public static void unregiterAll(final int id, final IEventListener listener) {
        for (final ListenerList list : ListenerList.allLists) {
            list.unregister(id, listener);
        }
    }
    
    static {
        ListenerList.allLists = new ArrayList<ListenerList>();
        ListenerList.maxSize = 0;
    }
    
    private class ListenerListInst
    {
        private boolean rebuild;
        private IEventListener[] listeners;
        private ArrayList<ArrayList<IEventListener>> priorities;
        private ListenerListInst parent;
        
        private ListenerListInst() {
            this.rebuild = true;
            final int count = EventPriority.values().length;
            this.priorities = new ArrayList<ArrayList<IEventListener>>(count);
            for (int x = 0; x < count; ++x) {
                this.priorities.add(new ArrayList<IEventListener>());
            }
        }
        
        public void dispose() {
            for (final ArrayList<IEventListener> listeners : this.priorities) {
                listeners.clear();
            }
            this.priorities.clear();
            this.parent = null;
            this.listeners = null;
        }
        
        private ListenerListInst(final ListenerList list, final ListenerListInst parent) {
            this(list);
            this.parent = parent;
        }
        
        public ArrayList<IEventListener> getListeners(final EventPriority priority) {
            final ArrayList<IEventListener> ret = new ArrayList<IEventListener>(this.priorities.get(priority.ordinal()));
            if (this.parent != null) {
                ret.addAll(this.parent.getListeners(priority));
            }
            return ret;
        }
        
        public IEventListener[] getListeners() {
            if (this.shouldRebuild()) {
                this.buildCache();
            }
            return this.listeners;
        }
        
        protected boolean shouldRebuild() {
            return this.rebuild || (this.parent != null && this.parent.shouldRebuild());
        }
        
        private void buildCache() {
            if (this.parent != null && this.parent.shouldRebuild()) {
                this.parent.buildCache();
            }
            final ArrayList<IEventListener> ret = new ArrayList<IEventListener>();
            for (final EventPriority value : EventPriority.values()) {
                ret.addAll(this.getListeners(value));
            }
            this.listeners = ret.toArray(new IEventListener[ret.size()]);
            this.rebuild = false;
        }
        
        public void register(final EventPriority priority, final IEventListener listener) {
            this.priorities.get(priority.ordinal()).add(listener);
            this.rebuild = true;
        }
        
        public void unregister(final IEventListener listener) {
            for (final ArrayList<IEventListener> list : this.priorities) {
                if (list.remove(listener)) {
                    this.rebuild = true;
                }
            }
        }
    }
}



================================================
FILE: net/minecraftforge/event/ServerChatEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event;

@Cancelable
public class ServerChatEvent extends Event
{
    public final String message;
    public final String username;
    public final jv player;
    public cv component;
    
    public ServerChatEvent(final jv player, final String message, final cv component) {
        this.message = message;
        this.player = player;
        this.username = player.bu;
        this.component = component;
    }
}



================================================
FILE: net/minecraftforge/event/brewing/PotionBrewedEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.brewing;

import net.minecraftforge.event.Event;

public class PotionBrewedEvent extends Event
{
    public ye[] brewingStacks;
    
    public PotionBrewedEvent(final ye[] brewingStacks) {
        this.brewingStacks = brewingStacks;
    }
}



================================================
FILE: net/minecraftforge/event/entity/EntityEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity;

import net.minecraftforge.event.Event;

public class EntityEvent extends Event
{
    public final nn entity;
    
    public EntityEvent(final nn entity) {
        this.entity = entity;
    }
    
    public static class EntityConstructing extends EntityEvent
    {
        public EntityConstructing(final nn entity) {
            super(entity);
        }
    }
    
    public static class CanUpdate extends EntityEvent
    {
        public boolean canUpdate;
        
        public CanUpdate(final nn entity) {
            super(entity);
            this.canUpdate = false;
        }
    }
    
    public static class EnteringChunk extends EntityEvent
    {
        public int newChunkX;
        public int newChunkZ;
        public int oldChunkX;
        public int oldChunkZ;
        
        public EnteringChunk(final nn entity, final int newChunkX, final int newChunkZ, final int oldChunkX, final int oldChunkZ) {
            super(entity);
            this.newChunkX = newChunkX;
            this.newChunkZ = newChunkZ;
            this.oldChunkX = oldChunkX;
            this.oldChunkZ = oldChunkZ;
        }
    }
}



================================================
FILE: net/minecraftforge/event/entity/EntityJoinWorldEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity;

import net.minecraftforge.event.Cancelable;

@Cancelable
public class EntityJoinWorldEvent extends EntityEvent
{
    public final abw world;
    
    public EntityJoinWorldEvent(final nn entity, final abw world) {
        super(entity);
        this.world = world;
    }
}



================================================
FILE: net/minecraftforge/event/entity/EntityStruckByLightningEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity;

import net.minecraftforge.event.Cancelable;

@Cancelable
public class EntityStruckByLightningEvent extends EntityEvent
{
    public final sp lightning;
    
    public EntityStruckByLightningEvent(final nn entity, final sp lightning) {
        super(entity);
        this.lightning = lightning;
    }
}



================================================
FILE: net/minecraftforge/event/entity/PlaySoundAtEntityEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity;

import net.minecraftforge.event.Cancelable;

@Cancelable
public class PlaySoundAtEntityEvent extends EntityEvent
{
    public String name;
    public final float volume;
    public final float pitch;
    
    public PlaySoundAtEntityEvent(final nn entity, final String name, final float volume, final float pitch) {
        super(entity);
        this.name = name;
        this.volume = volume;
        this.pitch = pitch;
    }
}



================================================
FILE: net/minecraftforge/event/entity/item/ItemEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.item;

import net.minecraftforge.event.entity.EntityEvent;

public class ItemEvent extends EntityEvent
{
    public final ss entityItem;
    
    public ItemEvent(final ss itemEntity) {
        super((nn)itemEntity);
        this.entityItem = itemEntity;
    }
}



================================================
FILE: net/minecraftforge/event/entity/item/ItemExpireEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.item;

import net.minecraftforge.event.Cancelable;

@Cancelable
public class ItemExpireEvent extends ItemEvent
{
    public int extraLife;
    
    public ItemExpireEvent(final ss entityItem, final int extraLife) {
        super(entityItem);
        this.extraLife = extraLife;
    }
}



================================================
FILE: net/minecraftforge/event/entity/item/ItemTossEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.item;

import net.minecraftforge.event.Cancelable;

@Cancelable
public class ItemTossEvent extends ItemEvent
{
    public final uf player;
    
    public ItemTossEvent(final ss entityItem, final uf player) {
        super(entityItem);
        this.player = player;
    }
}



================================================
FILE: net/minecraftforge/event/entity/living/EnderTeleportEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.living;

import net.minecraftforge.event.Cancelable;

@Cancelable
public class EnderTeleportEvent extends LivingEvent
{
    public double targetX;
    public double targetY;
    public double targetZ;
    public float attackDamage;
    
    public EnderTeleportEvent(final of entity, final double targetX, final double targetY, final double targetZ, final float attackDamage) {
        super(entity);
        this.targetX = targetX;
        this.targetY = targetY;
        this.targetZ = targetZ;
        this.attackDamage = attackDamage;
    }
}



================================================
FILE: net/minecraftforge/event/entity/living/LivingAttackEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.living;

import net.minecraftforge.event.Cancelable;

@Cancelable
public class LivingAttackEvent extends LivingEvent
{
    public final nb source;
    public final float ammount;
    
    public LivingAttackEvent(final of entity, final nb source, final float ammount) {
        super(entity);
        this.source = source;
        this.ammount = ammount;
    }
}



================================================
FILE: net/minecraftforge/event/entity/living/LivingDeathEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.living;

import net.minecraftforge.event.Cancelable;

@Cancelable
public class LivingDeathEvent extends LivingEvent
{
    public final nb source;
    
    public LivingDeathEvent(final of entity, final nb source) {
        super(entity);
        this.source = source;
    }
}



================================================
FILE: net/minecraftforge/event/entity/living/LivingDropsEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.living;

import java.util.ArrayList;
import net.minecraftforge.event.Cancelable;

@Cancelable
public class LivingDropsEvent extends LivingEvent
{
    public final nb source;
    public final ArrayList<ss> drops;
    public final int lootingLevel;
    public final boolean recentlyHit;
    public final int specialDropValue;
    
    public LivingDropsEvent(final of entity, final nb source, final ArrayList<ss> drops, final int lootingLevel, final boolean recentlyHit, final int specialDropValue) {
        super(entity);
        this.source = source;
        this.drops = drops;
        this.lootingLevel = lootingLevel;
        this.recentlyHit = recentlyHit;
        this.specialDropValue = specialDropValue;
    }
}



================================================
FILE: net/minecraftforge/event/entity/living/LivingEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.living;

import net.minecraftforge.event.Cancelable;
import net.minecraftforge.event.entity.EntityEvent;

public class LivingEvent extends EntityEvent
{
    public final of entityLiving;
    
    public LivingEvent(final of entity) {
        super((nn)entity);
        this.entityLiving = entity;
    }
    
    @Cancelable
    public static class LivingUpdateEvent extends LivingEvent
    {
        public LivingUpdateEvent(final of e) {
            super(e);
        }
    }
    
    public static class LivingJumpEvent extends LivingEvent
    {
        public LivingJumpEvent(final of e) {
            super(e);
        }
    }
}



================================================
FILE: net/minecraftforge/event/entity/living/LivingFallEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.living;

import net.minecraftforge.event.Cancelable;

@Cancelable
public class LivingFallEvent extends LivingEvent
{
    public float distance;
    
    public LivingFallEvent(final of entity, final float distance) {
        super(entity);
        this.distance = distance;
    }
}



================================================
FILE: net/minecraftforge/event/entity/living/LivingHurtEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.living;

import net.minecraftforge.event.Cancelable;

@Cancelable
public class LivingHurtEvent extends LivingEvent
{
    public final nb source;
    public float ammount;
    
    public LivingHurtEvent(final of entity, final nb source, final float ammount) {
        super(entity);
        this.source = source;
        this.ammount = ammount;
    }
}



================================================
FILE: net/minecraftforge/event/entity/living/LivingPackSizeEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.living;

import net.minecraftforge.event.Event;

@HasResult
public class LivingPackSizeEvent extends LivingEvent
{
    public int maxPackSize;
    
    public LivingPackSizeEvent(final og entity) {
        super((of)entity);
    }
}



================================================
FILE: net/minecraftforge/event/entity/living/LivingSetAttackTargetEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.living;

public class LivingSetAttackTargetEvent extends LivingEvent
{
    public final of target;
    
    public LivingSetAttackTargetEvent(final of entity, final of target) {
        super(entity);
        this.target = target;
    }
}



================================================
FILE: net/minecraftforge/event/entity/living/LivingSpawnEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.living;

import net.minecraftforge.event.Cancelable;
import net.minecraftforge.event.Event;

public class LivingSpawnEvent extends LivingEvent
{
    public final abw world;
    public final float x;
    public final float y;
    public final float z;
    
    public LivingSpawnEvent(final og entity, final abw world, final float x, final float y, final float z) {
        super((of)entity);
        this.world = world;
        this.x = x;
        this.y = y;
        this.z = z;
    }
    
    @HasResult
    public static class CheckSpawn extends LivingSpawnEvent
    {
        public CheckSpawn(final og entity, final abw world, final float x, final float y, final float z) {
            super(entity, world, x, y, z);
        }
    }
    
    @Cancelable
    public static class SpecialSpawn extends LivingSpawnEvent
    {
        public SpecialSpawn(final og entity, final abw world, final float x, final float y, final float z) {
            super(entity, world, x, y, z);
        }
    }
    
    @HasResult
    public static class AllowDespawn extends LivingSpawnEvent
    {
        public AllowDespawn(final og entity) {
            super(entity, entity.q, (float)entity.u, (float)entity.v, (float)entity.w);
        }
    }
}



================================================
FILE: net/minecraftforge/event/entity/living/ZombieEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.living;

import net.minecraftforge.event.Event;
import net.minecraftforge.event.entity.EntityEvent;

public class ZombieEvent extends EntityEvent
{
    public ZombieEvent(final tw entity) {
        super((nn)entity);
    }
    
    public tw getSummoner() {
        return (tw)this.entity;
    }
    
    @HasResult
    public static class SummonAidEvent extends ZombieEvent
    {
        public tw customSummonedAid;
        public final abw world;
        public final int x;
        public final int y;
        public final int z;
        public final of attacker;
        public final double summonChance;
        
        public SummonAidEvent(final tw entity, final abw world, final int x, final int y, final int z, final of attacker, final double summonChance) {
            super(entity);
            this.world = world;
            this.x = x;
            this.y = y;
            this.z = z;
            this.attacker = attacker;
            this.summonChance = summonChance;
        }
    }
}



================================================
FILE: net/minecraftforge/event/entity/minecart/MinecartCollisionEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.minecart;

public class MinecartCollisionEvent extends MinecartEvent
{
    public final nn collider;
    
    public MinecartCollisionEvent(final st minecart, final nn collider) {
        super(minecart);
        this.collider = collider;
    }
}



================================================
FILE: net/minecraftforge/event/entity/minecart/MinecartEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.minecart;

import net.minecraftforge.event.entity.EntityEvent;

public class MinecartEvent extends EntityEvent
{
    public final st minecart;
    
    public MinecartEvent(final st minecart) {
        super((nn)minecart);
        this.minecart = minecart;
    }
}



================================================
FILE: net/minecraftforge/event/entity/minecart/MinecartInteractEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.minecart;

import net.minecraftforge.event.Cancelable;

@Cancelable
public class MinecartInteractEvent extends MinecartEvent
{
    public final uf player;
    
    public MinecartInteractEvent(final st minecart, final uf player) {
        super(minecart);
        this.player = player;
    }
}



================================================
FILE: net/minecraftforge/event/entity/minecart/MinecartUpdateEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.minecart;

public class MinecartUpdateEvent extends MinecartEvent
{
    public final float x;
    public final float y;
    public final float z;
    
    public MinecartUpdateEvent(final st minecart, final float x, final float y, final float z) {
        super(minecart);
        this.x = x;
        this.y = y;
        this.z = z;
    }
}



================================================
FILE: net/minecraftforge/event/entity/player/ArrowLooseEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.player;

import net.minecraftforge.event.Cancelable;

@Cancelable
public class ArrowLooseEvent extends PlayerEvent
{
    public final ye bow;
    public int charge;
    
    public ArrowLooseEvent(final uf player, final ye bow, final int charge) {
        super(player);
        this.bow = bow;
        this.charge = charge;
    }
}



================================================
FILE: net/minecraftforge/event/entity/player/ArrowNockEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.player;

import net.minecraftforge.event.Cancelable;

@Cancelable
public class ArrowNockEvent extends PlayerEvent
{
    public ye result;
    
    public ArrowNockEvent(final uf player, final ye result) {
        super(player);
        this.result = result;
    }
}



================================================
FILE: net/minecraftforge/event/entity/player/AttackEntityEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.player;

import net.minecraftforge.event.Cancelable;

@Cancelable
public class AttackEntityEvent extends PlayerEvent
{
    public final nn target;
    
    public AttackEntityEvent(final uf player, final nn target) {
        super(player);
        this.target = target;
    }
}



================================================
FILE: net/minecraftforge/event/entity/player/BonemealEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.player;

import net.minecraftforge.event.Event;
import net.minecraftforge.event.Cancelable;

@Cancelable
@HasResult
public class BonemealEvent extends PlayerEvent
{
    public final abw world;
    public final int ID;
    public final int X;
    public final int Y;
    public final int Z;
    
    public BonemealEvent(final uf player, final abw world, final int id, final int x, final int y, final int z) {
        super(player);
        this.world = world;
        this.ID = id;
        this.X = x;
        this.Y = y;
        this.Z = z;
    }
}



================================================
FILE: net/minecraftforge/event/entity/player/EntityInteractEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.player;

import net.minecraftforge.event.Cancelable;

@Cancelable
public class EntityInteractEvent extends PlayerEvent
{
    public final nn target;
    
    public EntityInteractEvent(final uf player, final nn target) {
        super(player);
        this.target = target;
    }
}



================================================
FILE: net/minecraftforge/event/entity/player/EntityItemPickupEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.player;

import net.minecraftforge.event.Event;
import net.minecraftforge.event.Cancelable;

@Cancelable
@HasResult
public class EntityItemPickupEvent extends PlayerEvent
{
    public final ss item;
    private boolean handled;
    
    public EntityItemPickupEvent(final uf player, final ss item) {
        super(player);
        this.handled = false;
        this.item = item;
    }
}



================================================
FILE: net/minecraftforge/event/entity/player/FillBucketEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.player;

import net.minecraftforge.event.Event;
import net.minecraftforge.event.Cancelable;

@Cancelable
@HasResult
public class FillBucketEvent extends PlayerEvent
{
    public final ye current;
    public final abw world;
    public final ata target;
    public ye result;
    
    public FillBucketEvent(final uf player, final ye current, final abw world, final ata target) {
        super(player);
        this.current = current;
        this.world = world;
        this.target = target;
    }
}



================================================
FILE: net/minecraftforge/event/entity/player/ItemTooltipEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.player;

import java.util.List;

public class ItemTooltipEvent extends PlayerEvent
{
    public final boolean showAdvancedItemTooltips;
    public final ye itemStack;
    public final List<String> toolTip;
    
    public ItemTooltipEvent(final ye itemStack, final uf entityPlayer, final List<String> toolTip, final boolean showAdvancedItemTooltips) {
        super(entityPlayer);
        this.itemStack = itemStack;
        this.toolTip = toolTip;
        this.showAdvancedItemTooltips = showAdvancedItemTooltips;
    }
}



================================================
FILE: net/minecraftforge/event/entity/player/PlayerDestroyItemEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.player;

public class PlayerDestroyItemEvent extends PlayerEvent
{
    public final ye original;
    
    public PlayerDestroyItemEvent(final uf player, final ye original) {
        super(player);
        this.original = original;
    }
}



================================================
FILE: net/minecraftforge/event/entity/player/PlayerDropsEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.player;

import java.util.ArrayList;
import net.minecraftforge.event.Cancelable;
import net.minecraftforge.event.entity.living.LivingDropsEvent;

@Cancelable
public class PlayerDropsEvent extends LivingDropsEvent
{
    public final uf entityPlayer;
    
    public PlayerDropsEvent(final uf entity, final nb source, final ArrayList<ss> drops, final boolean recentlyHit) {
        super((of)entity, source, drops, (source.i() instanceof uf) ? aaw.g((of)source.i()) : 0, recentlyHit, 0);
        this.entityPlayer = entity;
    }
}



================================================
FILE: net/minecraftforge/event/entity/player/PlayerEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.player;

import net.minecraftforge.event.Cancelable;
import net.minecraftforge.event.entity.living.LivingEvent;

public class PlayerEvent extends LivingEvent
{
    public final uf entityPlayer;
    
    public PlayerEvent(final uf player) {
        super((of)player);
        this.entityPlayer = player;
    }
    
    public static class HarvestCheck extends PlayerEvent
    {
        public final aqz block;
        public boolean success;
        
        public HarvestCheck(final uf player, final aqz block, final boolean success) {
            super(player);
            this.block = block;
            this.success = success;
        }
    }
    
    @Cancelable
    public static class BreakSpeed extends PlayerEvent
    {
        public final aqz block;
        public final int metadata;
        public final float originalSpeed;
        public float newSpeed;
        
        public BreakSpeed(final uf player, final aqz block, final int metadata, final float original) {
            super(player);
            this.newSpeed = 0.0f;
            this.block = block;
            this.metadata = metadata;
            this.originalSpeed = original;
            this.newSpeed = original;
        }
    }
    
    public static class NameFormat extends PlayerEvent
    {
        public final String username;
        public String displayname;
        
        public NameFormat(final uf player, final String username) {
            super(player);
            this.username = username;
            this.displayname = username;
        }
    }
}



================================================
FILE: net/minecraftforge/event/entity/player/PlayerFlyableFallEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.player;

public class PlayerFlyableFallEvent extends PlayerEvent
{
    public float distance;
    
    public PlayerFlyableFallEvent(final uf player, final float f) {
        super(player);
        this.distance = f;
    }
}



================================================
FILE: net/minecraftforge/event/entity/player/PlayerInteractEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.player;

import net.minecraftforge.event.Event;
import net.minecraftforge.event.Cancelable;

@Cancelable
public class PlayerInteractEvent extends PlayerEvent
{
    public final Action action;
    public final int x;
    public final int y;
    public final int z;
    public final int face;
    public Result useBlock;
    public Result useItem;
    
    public PlayerInteractEvent(final uf player, final Action action, final int x, final int y, final int z, final int face) {
        super(player);
        this.useBlock = Result.DEFAULT;
        this.useItem = Result.DEFAULT;
        this.action = action;
        this.x = x;
        this.y = y;
        this.z = z;
        this.face = face;
        if (face == -1) {
            this.useBlock = Result.DENY;
        }
    }
    
    @Override
    public void setCanceled(final boolean cancel) {
        super.setCanceled(cancel);
        this.useBlock = (cancel ? Result.DENY : ((this.useBlock == Result.DENY) ? Result.DEFAULT : this.useBlock));
        this.useItem = (cancel ? Result.DENY : ((this.useItem == Result.DENY) ? Result.DEFAULT : this.useItem));
    }
    
    public enum Action
    {
        RIGHT_CLICK_AIR, 
        RIGHT_CLICK_BLOCK, 
        LEFT_CLICK_BLOCK;
    }
}



================================================
FILE: net/minecraftforge/event/entity/player/PlayerOpenContainerEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.player;

import net.minecraftforge.event.Event;

@HasResult
public class PlayerOpenContainerEvent extends PlayerEvent
{
    public final boolean canInteractWith;
    
    public PlayerOpenContainerEvent(final uf player, final uy openContainer) {
        super(player);
        this.canInteractWith = openContainer.a(player);
    }
}



================================================
FILE: net/minecraftforge/event/entity/player/PlayerSleepInBedEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.player;

public class PlayerSleepInBedEvent extends PlayerEvent
{
    public ug result;
    public final int x;
    public final int y;
    public final int z;
    
    public PlayerSleepInBedEvent(final uf player, final int x, final int y, final int z) {
        super(player);
        this.result = null;
        this.x = x;
        this.y = y;
        this.z = z;
    }
}



================================================
FILE: net/minecraftforge/event/entity/player/UseHoeEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.entity.player;

import net.minecraftforge.event.Event;
import net.minecraftforge.event.Cancelable;

@Cancelable
@HasResult
public class UseHoeEvent extends PlayerEvent
{
    public final ye current;
    public final abw world;
    public final int x;
    public final int y;
    public final int z;
    private boolean handeled;
    
    public UseHoeEvent(final uf player, final ye current, final abw world, final int x, final int y, final int z) {
        super(player);
        this.handeled = false;
        this.current = current;
        this.world = world;
        this.x = x;
        this.y = y;
        this.z = z;
    }
}



================================================
FILE: net/minecraftforge/event/terraingen/BiomeEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.terraingen;

import net.minecraftforge.event.Event;

public class BiomeEvent extends Event
{
    public final acq biome;
    
    public BiomeEvent(final acq biome) {
        this.biome = biome;
    }
    
    public static class CreateDecorator extends BiomeEvent
    {
        public final acu originalBiomeDecorator;
        public acu newBiomeDecorator;
        
        public CreateDecorator(final acq biome, final acu original) {
            super(biome);
            this.originalBiomeDecorator = original;
            this.newBiomeDecorator = original;
        }
    }
    
    public static class BlockReplacement extends BiomeEvent
    {
        public final int original;
        public int replacement;
        
        public BlockReplacement(final acq biome, final int original, final int replacement) {
            super(biome);
            this.original = original;
            this.replacement = replacement;
        }
    }
    
    public static class BiomeColor extends BiomeEvent
    {
        public final int originalColor;
        public int newColor;
        
        public BiomeColor(final acq biome, final int original) {
            super(biome);
            this.originalColor = original;
            this.newColor = original;
        }
    }
    
    @HasResult
    public static class GetVillageBlockID extends BlockReplacement
    {
        public GetVillageBlockID(final acq biome, final int original, final int replacement) {
            super(biome, original, replacement);
        }
    }
    
    @HasResult
    public static class GetVillageBlockMeta extends BlockReplacement
    {
        public GetVillageBlockMeta(final acq biome, final int original, final int replacement) {
            super(biome, original, replacement);
        }
    }
    
    public static class GetGrassColor extends BiomeColor
    {
        public GetGrassColor(final acq biome, final int original) {
            super(biome, original);
        }
    }
    
    public static class GetFoliageColor extends BiomeColor
    {
        public GetFoliageColor(final acq biome, final int original) {
            super(biome, original);
        }
    }
    
    public static class GetWaterColor extends BiomeColor
    {
        public GetWaterColor(final acq biome, final int original) {
            super(biome, original);
        }
    }
}



================================================
FILE: net/minecraftforge/event/terraingen/ChunkProviderEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.terraingen;

import net.minecraftforge.event.Event;

public class ChunkProviderEvent extends Event
{
    public final ado chunkProvider;
    
    public ChunkProviderEvent(final ado chunkProvider) {
        this.chunkProvider = chunkProvider;
    }
    
    @HasResult
    public static class ReplaceBiomeBlocks extends ChunkProviderEvent
    {
        public final int chunkX;
        public final int chunkZ;
        public final byte[] blockArray;
        public final acq[] biomeArray;
        
        public ReplaceBiomeBlocks(final ado chunkProvider, final int chunkX, final int chunkZ, final byte[] blockArray, final acq[] biomeArray) {
            super(chunkProvider);
            this.chunkX = chunkX;
            this.chunkZ = chunkZ;
            this.blockArray = blockArray;
            this.biomeArray = biomeArray;
        }
    }
    
    @HasResult
    public static class InitNoiseField extends ChunkProviderEvent
    {
        public double[] noisefield;
        public final int posX;
        public final int posY;
        public final int posZ;
        public final int sizeX;
        public final int sizeY;
        public final int sizeZ;
        
        public InitNoiseField(final ado chunkProvider, final double[] noisefield, final int posX, final int posY, final int posZ, final int sizeX, final int sizeY, final int sizeZ) {
            super(chunkProvider);
            this.noisefield = noisefield;
            this.posX = posX;
            this.posY = posY;
            this.posZ = posZ;
            this.sizeX = sizeX;
            this.sizeY = sizeY;
            this.sizeZ = sizeZ;
        }
    }
}



================================================
FILE: net/minecraftforge/event/terraingen/DecorateBiomeEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.terraingen;

import java.util.Random;
import net.minecraftforge.event.Event;

public class DecorateBiomeEvent extends Event
{
    public final abw world;
    public final Random rand;
    public final int chunkX;
    public final int chunkZ;
    
    public DecorateBiomeEvent(final abw world, final Random rand, final int worldX, final int worldZ) {
        this.world = world;
        this.rand = rand;
        this.chunkX = worldX;
        this.chunkZ = worldZ;
    }
    
    public static class Pre extends DecorateBiomeEvent
    {
        public Pre(final abw world, final Random rand, final int worldX, final int worldZ) {
            super(world, rand, worldX, worldZ);
        }
    }
    
    public static class Post extends DecorateBiomeEvent
    {
        public Post(final abw world, final Random rand, final int worldX, final int worldZ) {
            super(world, rand, worldX, worldZ);
        }
    }
    
    @HasResult
    public static class Decorate extends DecorateBiomeEvent
    {
        public final EventType type;
        
        public Decorate(final abw world, final Random rand, final int worldX, final int worldZ, final EventType type) {
            super(world, rand, worldX, worldZ);
            this.type = type;
        }
        
        public enum EventType
        {
            BIG_SHROOM, 
            CACTUS, 
            CLAY, 
            DEAD_BUSH, 
            LILYPAD, 
            FLOWERS, 
            GRASS, 
            LAKE, 
            PUMPKIN, 
            REED, 
            SAND, 
            SAND_PASS2, 
            SHROOM, 
            TREE, 
            CUSTOM;
        }
    }
}



================================================
FILE: net/minecraftforge/event/terraingen/DeferredBiomeDecorator.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.terraingen;

import net.minecraftforge.event.Event;
import net.minecraftforge.common.MinecraftForge;
import java.util.Random;

public class DeferredBiomeDecorator extends acu
{
    private acu wrapped;
    
    public DeferredBiomeDecorator(final acq biomeGenBase, final acu wrappedOriginal) {
        super(biomeGenBase);
        this.wrapped = wrappedOriginal;
    }
    
    public void a(final abw par1World, final Random par2Random, final int par3, final int par4) {
        this.fireCreateEventAndReplace();
        this.e.I.a(par1World, par2Random, par3, par4);
    }
    
    public void fireCreateEventAndReplace() {
        this.wrapped.J = this.J;
        this.wrapped.F = this.F;
        this.wrapped.I = this.I;
        this.wrapped.C = this.C;
        this.wrapped.A = this.A;
        this.wrapped.K = this.K;
        this.wrapped.B = this.B;
        this.wrapped.D = this.D;
        this.wrapped.E = this.E;
        this.wrapped.G = this.G;
        this.wrapped.H = this.H;
        this.wrapped.z = this.z;
        this.wrapped.y = this.y;
        final BiomeEvent.CreateDecorator event = new BiomeEvent.CreateDecorator(this.e, this.wrapped);
        MinecraftForge.TERRAIN_GEN_BUS.post(event);
        this.e.I = event.newBiomeDecorator;
    }
}



================================================
FILE: net/minecraftforge/event/terraingen/InitMapGenEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.terraingen;

import net.minecraftforge.event.Event;

public class InitMapGenEvent extends Event
{
    public final EventType type;
    public final aer originalGen;
    public aer newGen;
    
    InitMapGenEvent(final EventType type, final aer original) {
        this.type = type;
        this.originalGen = original;
        this.newGen = original;
    }
    
    public enum EventType
    {
        CAVE, 
        MINESHAFT, 
        NETHER_BRIDGE, 
        NETHER_CAVE, 
        RAVINE, 
        SCATTERED_FEATURE, 
        STRONGHOLD, 
        VILLAGE, 
        CUSTOM;
    }
}



================================================
FILE: net/minecraftforge/event/terraingen/InitNoiseGensEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.terraingen;

import java.util.Random;
import net.minecraftforge.event.world.WorldEvent;

public class InitNoiseGensEvent extends WorldEvent
{
    public final Random rand;
    public final ajt[] originalNoiseGens;
    public ajt[] newNoiseGens;
    
    public InitNoiseGensEvent(final abw world, final Random rand, final ajt[] original) {
        super(world);
        this.rand = rand;
        this.originalNoiseGens = original;
        this.newNoiseGens = original.clone();
    }
}



================================================
FILE: net/minecraftforge/event/terraingen/OreGenEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.terraingen;

import java.util.Random;
import net.minecraftforge.event.Event;

public class OreGenEvent extends Event
{
    public final abw world;
    public final Random rand;
    public final int worldX;
    public final int worldZ;
    
    public OreGenEvent(final abw world, final Random rand, final int worldX, final int worldZ) {
        this.world = world;
        this.rand = rand;
        this.worldX = worldX;
        this.worldZ = worldZ;
    }
    
    public static class Pre extends OreGenEvent
    {
        public Pre(final abw world, final Random rand, final int worldX, final int worldZ) {
            super(world, rand, worldX, worldZ);
        }
    }
    
    public static class Post extends OreGenEvent
    {
        public Post(final abw world, final Random rand, final int worldX, final int worldZ) {
            super(world, rand, worldX, worldZ);
        }
    }
    
    @HasResult
    public static class GenerateMinable extends OreGenEvent
    {
        public final EventType type;
        public final afe generator;
        
        public GenerateMinable(final abw world, final Random rand, final afe generator, final int worldX, final int worldZ, final EventType type) {
            super(world, rand, worldX, worldZ);
            this.generator = generator;
            this.type = type;
        }
        
        public enum EventType
        {
            COAL, 
            DIAMOND, 
            DIRT, 
            GOLD, 
            GRAVEL, 
            IRON, 
            LAPIS, 
            REDSTONE, 
            CUSTOM;
        }
    }
}



================================================
FILE: net/minecraftforge/event/terraingen/PopulateChunkEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.terraingen;

import net.minecraftforge.event.Event;
import java.util.Random;

public class PopulateChunkEvent extends ChunkProviderEvent
{
    public final abw world;
    public final Random rand;
    public final int chunkX;
    public final int chunkZ;
    public final boolean hasVillageGenerated;
    
    public PopulateChunkEvent(final ado chunkProvider, final abw world, final Random rand, final int chunkX, final int chunkZ, final boolean hasVillageGenerated) {
        super(chunkProvider);
        this.world = world;
        this.rand = rand;
        this.chunkX = chunkX;
        this.chunkZ = chunkZ;
        this.hasVillageGenerated = hasVillageGenerated;
    }
    
    public static class Pre extends PopulateChunkEvent
    {
        public Pre(final ado chunkProvider, final abw world, final Random rand, final int chunkX, final int chunkZ, final boolean hasVillageGenerated) {
            super(chunkProvider, world, rand, chunkX, chunkZ, hasVillageGenerated);
        }
    }
    
    public static class Post extends PopulateChunkEvent
    {
        public Post(final ado chunkProvider, final abw world, final Random rand, final int chunkX, final int chunkZ, final boolean hasVillageGenerated) {
            super(chunkProvider, world, rand, chunkX, chunkZ, hasVillageGenerated);
        }
    }
    
    @HasResult
    public static class Populate extends PopulateChunkEvent
    {
        public final EventType type;
        
        public Populate(final ado chunkProvider, final abw world, final Random rand, final int chunkX, final int chunkZ, final boolean hasVillageGenerated, final EventType type) {
            super(chunkProvider, world, rand, chunkX, chunkZ, hasVillageGenerated);
            this.type = type;
        }
        
        public enum EventType
        {
            DUNGEON, 
            FIRE, 
            GLOWSTONE, 
            ICE, 
            LAKE, 
            LAVA, 
            NETHER_LAVA, 
            CUSTOM;
        }
    }
}



================================================
FILE: net/minecraftforge/event/terraingen/SaplingGrowTreeEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.terraingen;

import java.util.Random;
import net.minecraftforge.event.Event;
import net.minecraftforge.event.world.WorldEvent;

@HasResult
public class SaplingGrowTreeEvent extends WorldEvent
{
    public final int x;
    public final int y;
    public final int z;
    public final Random rand;
    
    public SaplingGrowTreeEvent(final abw world, final Random rand, final int x, final int y, final int z) {
        super(world);
        this.rand = rand;
        this.x = x;
        this.y = y;
        this.z = z;
    }
}



================================================
FILE: net/minecraftforge/event/terraingen/TerrainGen.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.terraingen;

import net.minecraftforge.event.Event;
import net.minecraftforge.common.MinecraftForge;
import java.util.Random;

public abstract class TerrainGen
{
    public static ajt[] getModdedNoiseGenerators(final abw world, final Random rand, final ajt[] original) {
        final InitNoiseGensEvent event = new InitNoiseGensEvent(world, rand, original);
        MinecraftForge.TERRAIN_GEN_BUS.post(event);
        return event.newNoiseGens;
    }
    
    public static aer getModdedMapGen(final aer original, final InitMapGenEvent.EventType type) {
        final InitMapGenEvent event = new InitMapGenEvent(type, original);
        MinecraftForge.TERRAIN_GEN_BUS.post(event);
        return event.newGen;
    }
    
    public static boolean populate(final ado chunkProvider, final abw world, final Random rand, final int chunkX, final int chunkZ, final boolean hasVillageGenerated, final PopulateChunkEvent.Populate.EventType type) {
        final PopulateChunkEvent.Populate event = new PopulateChunkEvent.Populate(chunkProvider, world, rand, chunkX, chunkZ, hasVillageGenerated, type);
        MinecraftForge.TERRAIN_GEN_BUS.post(event);
        return event.getResult() != Event.Result.DENY;
    }
    
    public static boolean decorate(final abw world, final Random rand, final int chunkX, final int chunkZ, final DecorateBiomeEvent.Decorate.EventType type) {
        final DecorateBiomeEvent.Decorate event = new DecorateBiomeEvent.Decorate(world, rand, chunkX, chunkZ, type);
        MinecraftForge.TERRAIN_GEN_BUS.post(event);
        return event.getResult() != Event.Result.DENY;
    }
    
    public static boolean generateOre(final abw world, final Random rand, final afe generator, final int worldX, final int worldZ, final OreGenEvent.GenerateMinable.EventType type) {
        final OreGenEvent.GenerateMinable event = new OreGenEvent.GenerateMinable(world, rand, generator, worldX, worldZ, type);
        MinecraftForge.ORE_GEN_BUS.post(event);
        return event.getResult() != Event.Result.DENY;
    }
    
    public static boolean saplingGrowTree(final abw world, final Random rand, final int x, final int y, final int z) {
        final SaplingGrowTreeEvent event = new SaplingGrowTreeEvent(world, rand, x, y, z);
        MinecraftForge.TERRAIN_GEN_BUS.post(event);
        return event.getResult() != Event.Result.DENY;
    }
}



================================================
FILE: net/minecraftforge/event/terraingen/WorldTypeEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.terraingen;

import net.minecraftforge.event.Event;

public class WorldTypeEvent extends Event
{
    public final acg worldType;
    
    public WorldTypeEvent(final acg worldType) {
        this.worldType = worldType;
    }
    
    public static class BiomeSize extends WorldTypeEvent
    {
        public final byte originalSize;
        public byte newSize;
        
        public BiomeSize(final acg worldType, final byte original) {
            super(worldType);
            this.originalSize = original;
            this.newSize = original;
        }
    }
    
    public static class InitBiomeGens extends WorldTypeEvent
    {
        public final long seed;
        public final akq[] originalBiomeGens;
        public akq[] newBiomeGens;
        
        public InitBiomeGens(final acg worldType, final long seed, final akq[] original) {
            super(worldType);
            this.seed = seed;
            this.originalBiomeGens = original;
            this.newBiomeGens = original.clone();
        }
    }
}



================================================
FILE: net/minecraftforge/event/world/BlockEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.world;

import net.minecraftforge.event.Cancelable;
import java.util.ArrayList;
import net.minecraftforge.event.Event;

public class BlockEvent extends Event
{
    public final int x;
    public final int y;
    public final int z;
    public final abw world;
    public final aqz block;
    public final int blockMetadata;
    
    public BlockEvent(final int x, final int y, final int z, final abw world, final aqz block, final int blockMetadata) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.world = world;
        this.block = block;
        this.blockMetadata = blockMetadata;
    }
    
    public static class HarvestDropsEvent extends BlockEvent
    {
        public final int fortuneLevel;
        public final ArrayList<ye> drops;
        public final boolean isSilkTouching;
        public float dropChance;
        public final uf harvester;
        
        public HarvestDropsEvent(final int x, final int y, final int z, final abw world, final aqz block, final int blockMetadata, final int fortuneLevel, final float dropChance, final ArrayList<ye> drops, final uf harvester, final boolean isSilkTouching) {
            super(x, y, z, world, block, blockMetadata);
            this.fortuneLevel = fortuneLevel;
            this.dropChance = dropChance;
            this.drops = drops;
            this.isSilkTouching = isSilkTouching;
            this.harvester = harvester;
        }
    }
    
    @Cancelable
    public static class BreakEvent extends BlockEvent
    {
        private final uf player;
        private int exp;
        
        public BreakEvent(final int x, final int y, final int z, final abw world, final aqz block, final int blockMetadata, final uf player) {
            super(x, y, z, world, block, blockMetadata);
            this.player = player;
            if (block == null || !player.a(block) || (block.canSilkHarvest(world, player, x, y, z, blockMetadata) && aaw.e((of)player))) {
                this.exp = 0;
            }
            else {
                final int meta = block.h(world, x, y, z);
                final int bonusLevel = aaw.f((of)player);
                this.exp = block.getExpDrop(world, meta, bonusLevel);
            }
        }
        
        public uf getPlayer() {
            return this.player;
        }
        
        public int getExpToDrop() {
            return this.isCanceled() ? 0 : this.exp;
        }
        
        public void setExpToDrop(final int exp) {
            this.exp = exp;
        }
    }
}



================================================
FILE: net/minecraftforge/event/world/ChunkDataEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.world;

public class ChunkDataEvent extends ChunkEvent
{
    private final by data;
    
    public ChunkDataEvent(final adr chunk, final by data) {
        super(chunk);
        this.data = data;
    }
    
    public by getData() {
        return this.data;
    }
    
    public static class Load extends ChunkDataEvent
    {
        public Load(final adr chunk, final by data) {
            super(chunk, data);
        }
    }
    
    public static class Save extends ChunkDataEvent
    {
        public Save(final adr chunk, final by data) {
            super(chunk, data);
        }
    }
}



================================================
FILE: net/minecraftforge/event/world/ChunkEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.world;

public class ChunkEvent extends WorldEvent
{
    private final adr chunk;
    
    public ChunkEvent(final adr chunk) {
        super(chunk.e);
        this.chunk = chunk;
    }
    
    public adr getChunk() {
        return this.chunk;
    }
    
    public static class Load extends ChunkEvent
    {
        public Load(final adr chunk) {
            super(chunk);
        }
    }
    
    public static class Unload extends ChunkEvent
    {
        public Unload(final adr chunk) {
            super(chunk);
        }
    }
}



================================================
FILE: net/minecraftforge/event/world/ChunkWatchEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.world;

import net.minecraftforge.event.Event;

public class ChunkWatchEvent extends Event
{
    public final abp chunk;
    public final jv player;
    
    public ChunkWatchEvent(final abp chunk, final jv player) {
        this.chunk = chunk;
        this.player = player;
    }
    
    public static class Watch extends ChunkWatchEvent
    {
        public Watch(final abp chunk, final jv player) {
            super(chunk, player);
        }
    }
    
    public static class UnWatch extends ChunkWatchEvent
    {
        public UnWatch(final abp chunkLocation, final jv player) {
            super(chunkLocation, player);
        }
    }
}



================================================
FILE: net/minecraftforge/event/world/WorldEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.event.world;

import java.util.ArrayList;
import java.util.List;
import net.minecraftforge.event.Cancelable;
import net.minecraftforge.event.Event;

public class WorldEvent extends Event
{
    public final abw world;
    
    public WorldEvent(final abw world) {
        this.world = world;
    }
    
    public static class Load extends WorldEvent
    {
        public Load(final abw world) {
            super(world);
        }
    }
    
    public static class Unload extends WorldEvent
    {
        public Unload(final abw world) {
            super(world);
        }
    }
    
    public static class Save extends WorldEvent
    {
        public Save(final abw world) {
            super(world);
        }
    }
    
    @Cancelable
    public static class PotentialSpawns extends WorldEvent
    {
        public final oh type;
        public final int x;
        public final int y;
        public final int z;
        public final List<acr> list;
        
        public PotentialSpawns(final abw world, final oh type, final int x, final int y, final int z, final List oldList) {
            super(world);
            this.x = x;
            this.y = y;
            this.z = z;
            this.type = type;
            if (oldList != null) {
                this.list = oldList;
            }
            else {
                this.list = new ArrayList<acr>();
            }
        }
    }
}



================================================
FILE: net/minecraftforge/fluids/BlockFluidBase.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.fluids;

import java.util.Random;
import java.util.HashMap;
import java.util.Map;

public abstract class BlockFluidBase extends aqz implements IFluidBlock
{
    protected static final Map<Integer, Boolean> defaultDisplacementIds;
    protected Map<Integer, Boolean> displacementIds;
    protected int quantaPerBlock;
    protected float quantaPerBlockFloat;
    protected int density;
    protected int densityDir;
    protected int temperature;
    protected int tickRate;
    protected int renderPass;
    protected int maxScaledLight;
    protected final String fluidName;
    
    public BlockFluidBase(final int id, final Fluid fluid, final akc material) {
        super(id, material);
        this.displacementIds = new HashMap<Integer, Boolean>();
        this.quantaPerBlock = 8;
        this.quantaPerBlockFloat = 8.0f;
        this.density = 1;
        this.densityDir = -1;
        this.temperature = 295;
        this.tickRate = 20;
        this.renderPass = 1;
        this.maxScaledLight = 0;
        this.a(0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f);
        this.b(true);
        this.C();
        this.fluidName = fluid.getName();
        this.density = fluid.density;
        this.temperature = fluid.temperature;
        this.maxScaledLight = fluid.luminosity;
        this.tickRate = fluid.viscosity / 200;
        this.densityDir = ((fluid.density > 0) ? -1 : 1);
        fluid.setBlockID(id);
        this.displacementIds.putAll(BlockFluidBase.defaultDisplacementIds);
    }
    
    public BlockFluidBase setQuantaPerBlock(int quantaPerBlock) {
        if (quantaPerBlock > 16 || quantaPerBlock < 1) {
            quantaPerBlock = 8;
        }
        this.quantaPerBlock = quantaPerBlock;
        this.quantaPerBlockFloat = (float)quantaPerBlock;
        return this;
    }
    
    public BlockFluidBase setDensity(int density) {
        if (density == 0) {
            density = 1;
        }
        this.density = density;
        this.densityDir = ((density > 0) ? -1 : 1);
        return this;
    }
    
    public BlockFluidBase setTemperature(final int temperature) {
        this.temperature = temperature;
        return this;
    }
    
    public BlockFluidBase setTickRate(int tickRate) {
        if (tickRate <= 0) {
            tickRate = 20;
        }
        this.tickRate = tickRate;
        return this;
    }
    
    public BlockFluidBase setRenderPass(final int renderPass) {
        this.renderPass = renderPass;
        return this;
    }
    
    public BlockFluidBase setMaxScaledLight(final int maxScaledLight) {
        this.maxScaledLight = maxScaledLight;
        return this;
    }
    
    public boolean canDisplace(final acf world, final int x, final int y, final int z) {
        if (world.c(x, y, z)) {
            return true;
        }
        final int bId = world.a(x, y, z);
        if (bId == this.cF) {
            return false;
        }
        if (this.displacementIds.containsKey(bId)) {
            return this.displacementIds.get(bId);
        }
        final akc material = aqz.s[bId].cU;
        if (material.c() || material == akc.D) {
            return false;
        }
        final int density = getDensity(world, x, y, z);
        return density == Integer.MAX_VALUE || this.density > density;
    }
    
    public boolean displaceIfPossible(final abw world, final int x, final int y, final int z) {
        if (world.c(x, y, z)) {
            return true;
        }
        final int bId = world.a(x, y, z);
        if (bId == this.cF) {
            return false;
        }
        if (this.displacementIds.containsKey(bId)) {
            if (this.displacementIds.get(bId)) {
                aqz.s[bId].c(world, x, y, z, world.h(x, y, z), 0);
                return true;
            }
            return false;
        }
        else {
            final akc material = aqz.s[bId].cU;
            if (material.c() || material == akc.D) {
                return false;
            }
            final int density = getDensity((acf)world, x, y, z);
            if (density == Integer.MAX_VALUE) {
                aqz.s[bId].c(world, x, y, z, world.h(x, y, z), 0);
                return true;
            }
            return this.density > density;
        }
    }
    
    public abstract int getQuantaValue(final acf p0, final int p1, final int p2, final int p3);
    
    public abstract boolean a(final int p0, final boolean p1);
    
    public abstract int getMaxRenderHeightMeta();
    
    public void a(final abw world, final int x, final int y, final int z) {
        world.a(x, y, z, this.cF, this.tickRate);
    }
    
    public void a(final abw world, final int x, final int y, final int z, final int blockId) {
        world.a(x, y, z, this.cF, this.tickRate);
    }
    
    public boolean l() {
        return false;
    }
    
    public boolean b(final acf world, final int x, final int y, final int z) {
        return true;
    }
    
    public asx b(final abw world, final int x, final int y, final int z) {
        return null;
    }
    
    public int a(final int par1, final Random par2Random, final int par3) {
        return 0;
    }
    
    public int a(final Random par1Random) {
        return 0;
    }
    
    public int a(final abw world) {
        return this.tickRate;
    }
    
    public void a(final abw world, final int x, final int y, final int z, final nn entity, final atc vec) {
        if (this.densityDir > 0) {
            return;
        }
        final atc vec_flow = this.getFlowVector((acf)world, x, y, z);
        vec.c += vec_flow.c * (this.quantaPerBlock * 4);
        vec.d += vec_flow.d * (this.quantaPerBlock * 4);
        vec.e += vec_flow.e * (this.quantaPerBlock * 4);
    }
    
    public int getLightValue(final acf world, final int x, final int y, final int z) {
        if (this.maxScaledLight == 0) {
            return super.getLightValue(world, x, y, z);
        }
        final int data = world.h(x, y, z);
        return (int)(data / this.quantaPerBlockFloat * this.maxScaledLight);
    }
    
    public int d() {
        return FluidRegistry.renderIdFluid;
    }
    
    public boolean c() {
        return false;
    }
    
    public boolean b() {
        return false;
    }
    
    public float f(final acf world, final int x, final int y, final int z) {
        final float lightThis = world.q(x, y, z);
        final float lightUp = world.q(x, y + 1, z);
        return (lightThis > lightUp) ? lightThis : lightUp;
    }
    
    public int e(final acf world, final int x, final int y, final int z) {
        final int lightThis = world.h(x, y, z, 0);
        final int lightUp = world.h(x, y + 1, z, 0);
        final int lightThisBase = lightThis & 0xFF;
        final int lightUpBase = lightUp & 0xFF;
        final int lightThisExt = lightThis >> 16 & 0xFF;
        final int lightUpExt = lightUp >> 16 & 0xFF;
        return ((lightThisBase > lightUpBase) ? lightThisBase : lightUpBase) | ((lightThisExt > lightUpExt) ? lightThisExt : lightUpExt) << 16;
    }
    
    public int n() {
        return this.renderPass;
    }
    
    public boolean a(final acf world, final int x, final int y, final int z, final int side) {
        if (world.a(x, y, z) != this.cF) {
            return !world.t(x, y, z);
        }
        final akc mat = world.g(x, y, z);
        return mat != this.cU && super.a(world, x, y, z, side);
    }
    
    public static final int getDensity(final acf world, final int x, final int y, final int z) {
        final aqz block = aqz.s[world.a(x, y, z)];
        if (!(block instanceof BlockFluidBase)) {
            return Integer.MAX_VALUE;
        }
        return ((BlockFluidBase)block).density;
    }
    
    public static final int getTemperature(final acf world, final int x, final int y, final int z) {
        final aqz block = aqz.s[world.a(x, y, z)];
        if (!(block instanceof BlockFluidBase)) {
            return Integer.MAX_VALUE;
        }
        return ((BlockFluidBase)block).temperature;
    }
    
    public static double getFlowDirection(final acf world, final int x, final int y, final int z) {
        final aqz block = aqz.s[world.a(x, y, z)];
        if (!world.g(x, y, z).d()) {
            return -1000.0;
        }
        final atc vec = ((BlockFluidBase)block).getFlowVector(world, x, y, z);
        return (vec.c == 0.0 && vec.e == 0.0) ? -1000.0 : (Math.atan2(vec.e, vec.c) - 1.5707963267948966);
    }
    
    public final int getQuantaValueBelow(final acf world, final int x, final int y, final int z, final int belowThis) {
        final int quantaRemaining = this.getQuantaValue(world, x, y, z);
        if (quantaRemaining >= belowThis) {
            return -1;
        }
        return quantaRemaining;
    }
    
    public final int getQuantaValueAbove(final acf world, final int x, final int y, final int z, final int aboveThis) {
        final int quantaRemaining = this.getQuantaValue(world, x, y, z);
        if (quantaRemaining <= aboveThis) {
            return -1;
        }
        return quantaRemaining;
    }
    
    public final float getQuantaPercentage(final acf world, final int x, final int y, final int z) {
        final int quantaRemaining = this.getQuantaValue(world, x, y, z);
        return quantaRemaining / this.quantaPerBlockFloat;
    }
    
    public atc getFlowVector(final acf world, final int x, final int y, final int z) {
        atc vec = world.V().a(0.0, 0.0, 0.0);
        final int decay = this.quantaPerBlock - this.getQuantaValue(world, x, y, z);
        for (int side = 0; side < 4; ++side) {
            int x2 = x;
            int z2 = z;
            switch (side) {
                case 0: {
                    --x2;
                    break;
                }
                case 1: {
                    --z2;
                    break;
                }
                case 2: {
                    ++x2;
                    break;
                }
                case 3: {
                    ++z2;
                    break;
                }
            }
            int otherDecay = this.quantaPerBlock - this.getQuantaValue(world, x2, y, z2);
            if (otherDecay >= this.quantaPerBlock) {
                if (!world.g(x2, y, z2).c()) {
                    otherDecay = this.quantaPerBlock - this.getQuantaValue(world, x2, y - 1, z2);
                    if (otherDecay >= 0) {
                        final int power = otherDecay - (decay - this.quantaPerBlock);
                        vec = vec.c((double)((x2 - x) * power), (double)((y - y) * power), (double)((z2 - z) * power));
                    }
                }
            }
            else if (otherDecay >= 0) {
                final int power = otherDecay - decay;
                vec = vec.c((double)((x2 - x) * power), (double)((y - y) * power), (double)((z2 - z) * power));
            }
        }
        if (world.a(x, y + 1, z) == this.cF) {
            final boolean flag = this.a_(world, x, y, z - 1, 2) || this.a_(world, x, y, z + 1, 3) || this.a_(world, x - 1, y, z, 4) || this.a_(world, x + 1, y, z, 5) || this.a_(world, x, y + 1, z - 1, 2) || this.a_(world, x, y + 1, z + 1, 3) || this.a_(world, x - 1, y + 1, z, 4) || this.a_(world, x + 1, y + 1, z, 5);
            if (flag) {
                vec = vec.a().c(0.0, -6.0, 0.0);
            }
        }
        vec = vec.a();
        return vec;
    }
    
    public Fluid getFluid() {
        return FluidRegistry.getFluid(this.fluidName);
    }
    
    public float getFilledPercentage(final abw world, final int x, final int y, final int z) {
        final int quantaRemaining = this.getQuantaValue((acf)world, x, y, z) + 1;
        float remaining = quantaRemaining / this.quantaPerBlockFloat;
        if (remaining > 1.0f) {
            remaining = 1.0f;
        }
        return remaining * ((this.density > 0) ? 1 : -1);
    }
    
    static {
        (defaultDisplacementIds = new HashMap<Integer, Boolean>()).put(aqz.aJ.cF, false);
        BlockFluidBase.defaultDisplacementIds.put(aqz.aQ.cF, false);
        BlockFluidBase.defaultDisplacementIds.put(aqz.aI.cF, false);
        BlockFluidBase.defaultDisplacementIds.put(aqz.aN.cF, false);
        BlockFluidBase.defaultDisplacementIds.put(aqz.bc.cF, false);
    }
}



================================================
FILE: net/minecraftforge/fluids/BlockFluidClassic.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.fluids;

import java.util.Random;

public class BlockFluidClassic extends BlockFluidBase
{
    protected boolean[] isOptimalFlowDirection;
    protected int[] flowCost;
    protected FluidStack stack;
    
    public BlockFluidClassic(final int id, final Fluid fluid, final akc material) {
        super(id, fluid, material);
        this.isOptimalFlowDirection = new boolean[4];
        this.flowCost = new int[4];
        this.stack = new FluidStack(fluid, 1000);
    }
    
    public BlockFluidClassic setFluidStack(final FluidStack stack) {
        this.stack = stack;
        return this;
    }
    
    public BlockFluidClassic setFluidStackAmount(final int amount) {
        this.stack.amount = amount;
        return this;
    }
    
    @Override
    public int getQuantaValue(final acf world, final int x, final int y, final int z) {
        if (world.a(x, y, z) == 0) {
            return 0;
        }
        if (world.a(x, y, z) != this.cF) {
            return -1;
        }
        final int quantaRemaining = this.quantaPerBlock - world.h(x, y, z);
        return quantaRemaining;
    }
    
    @Override
    public boolean a(final int meta, final boolean fullHit) {
        return fullHit && meta == 0;
    }
    
    @Override
    public int getMaxRenderHeightMeta() {
        return 0;
    }
    
    @Override
    public int getLightValue(final acf world, final int x, final int y, final int z) {
        if (this.maxScaledLight == 0) {
            return super.getLightValue(world, x, y, z);
        }
        final int data = this.quantaPerBlock - world.h(x, y, z) - 1;
        return (int)(data / this.quantaPerBlockFloat * this.maxScaledLight);
    }
    
    public void a(final abw world, final int x, final int y, final int z, final Random rand) {
        int quantaRemaining = this.quantaPerBlock - world.h(x, y, z);
        int expQuanta = -101;
        if (quantaRemaining < this.quantaPerBlock) {
            final int y2 = y - this.densityDir;
            if (world.a(x, y2, z) == this.cF || world.a(x - 1, y2, z) == this.cF || world.a(x + 1, y2, z) == this.cF || world.a(x, y2, z - 1) == this.cF || world.a(x, y2, z + 1) == this.cF) {
                expQuanta = this.quantaPerBlock - 1;
            }
            else {
                int maxQuanta = -100;
                maxQuanta = this.getLargerQuanta((acf)world, x - 1, y, z, maxQuanta);
                maxQuanta = this.getLargerQuanta((acf)world, x + 1, y, z, maxQuanta);
                maxQuanta = this.getLargerQuanta((acf)world, x, y, z - 1, maxQuanta);
                maxQuanta = this.getLargerQuanta((acf)world, x, y, z + 1, maxQuanta);
                expQuanta = maxQuanta - 1;
            }
            if (expQuanta != quantaRemaining) {
                if ((quantaRemaining = expQuanta) <= 0) {
                    world.i(x, y, z);
                }
                else {
                    world.b(x, y, z, this.quantaPerBlock - expQuanta, 3);
                    world.a(x, y, z, this.cF, this.tickRate);
                    world.f(x, y, z, this.cF);
                }
            }
        }
        else if (quantaRemaining >= this.quantaPerBlock) {
            world.b(x, y, z, 0, 2);
        }
        if (this.canDisplace((acf)world, x, y + this.densityDir, z)) {
            this.flowIntoBlock(world, x, y + this.densityDir, z, 1);
            return;
        }
        int flowMeta = this.quantaPerBlock - quantaRemaining + 1;
        if (flowMeta >= this.quantaPerBlock) {
            return;
        }
        if (this.isSourceBlock((acf)world, x, y, z) || !this.isFlowingVertically((acf)world, x, y, z)) {
            if (world.a(x, y - this.densityDir, z) == this.cF) {
                flowMeta = 1;
            }
            final boolean[] flowTo = this.getOptimalFlowDirections(world, x, y, z);
            if (flowTo[0]) {
                this.flowIntoBlock(world, x - 1, y, z, flowMeta);
            }
            if (flowTo[1]) {
                this.flowIntoBlock(world, x + 1, y, z, flowMeta);
            }
            if (flowTo[2]) {
                this.flowIntoBlock(world, x, y, z - 1, flowMeta);
            }
            if (flowTo[3]) {
                this.flowIntoBlock(world, x, y, z + 1, flowMeta);
            }
        }
    }
    
    public boolean isFlowingVertically(final acf world, final int x, final int y, final int z) {
        return world.a(x, y + this.densityDir, z) == this.cF || (world.a(x, y, z) == this.cF && this.canFlowInto(world, x, y + this.densityDir, z));
    }
    
    public boolean isSourceBlock(final acf world, final int x, final int y, final int z) {
        return world.a(x, y, z) == this.cF && world.h(x, y, z) == 0;
    }
    
    protected boolean[] getOptimalFlowDirections(final abw world, final int x, final int y, final int z) {
        for (int side = 0; side < 4; ++side) {
            this.flowCost[side] = 1000;
            int x2 = x;
            final int y2 = y;
            int z2 = z;
            switch (side) {
                case 0: {
                    --x2;
                    break;
                }
                case 1: {
                    ++x2;
                    break;
                }
                case 2: {
                    --z2;
                    break;
                }
                case 3: {
                    ++z2;
                    break;
                }
            }
            if (this.canFlowInto((acf)world, x2, y2, z2)) {
                if (!this.isSourceBlock((acf)world, x2, y2, z2)) {
                    if (this.canFlowInto((acf)world, x2, y2 + this.densityDir, z2)) {
                        this.flowCost[side] = 0;
                    }
                    else {
                        this.flowCost[side] = this.calculateFlowCost(world, x2, y2, z2, 1, side);
                    }
                }
            }
        }
        int min = this.flowCost[0];
        for (int side2 = 1; side2 < 4; ++side2) {
            if (this.flowCost[side2] < min) {
                min = this.flowCost[side2];
            }
        }
        for (int side2 = 0; side2 < 4; ++side2) {
            this.isOptimalFlowDirection[side2] = (this.flowCost[side2] == min);
        }
        return this.isOptimalFlowDirection;
    }
    
    protected int calculateFlowCost(final abw world, final int x, final int y, final int z, final int recurseDepth, final int side) {
        int cost = 1000;
        for (int adjSide = 0; adjSide < 4; ++adjSide) {
            if ((adjSide != 0 || side != 1) && (adjSide != 1 || side != 0) && (adjSide != 2 || side != 3)) {
                if (adjSide != 3 || side != 2) {
                    int x2 = x;
                    final int y2 = y;
                    int z2 = z;
                    switch (adjSide) {
                        case 0: {
                            --x2;
                            break;
                        }
                        case 1: {
                            ++x2;
                            break;
                        }
                        case 2: {
                            --z2;
                            break;
                        }
                        case 3: {
                            ++z2;
                            break;
                        }
                    }
                    if (this.canFlowInto((acf)world, x2, y2, z2)) {
                        if (!this.isSourceBlock((acf)world, x2, y2, z2)) {
                            if (this.canFlowInto((acf)world, x2, y2 + this.densityDir, z2)) {
                                return recurseDepth;
                            }
                            if (recurseDepth < 4) {
                                final int min = this.calculateFlowCost(world, x2, y2, z2, recurseDepth + 1, adjSide);
                                if (min < cost) {
                                    cost = min;
                                }
                            }
                        }
                    }
                }
            }
        }
        return cost;
    }
    
    protected void flowIntoBlock(final abw world, final int x, final int y, final int z, final int meta) {
        if (meta < 0) {
            return;
        }
        if (this.displaceIfPossible(world, x, y, z)) {
            world.f(x, y, z, this.cF, meta, 3);
        }
    }
    
    protected boolean canFlowInto(final acf world, final int x, final int y, final int z) {
        if (world.c(x, y, z)) {
            return true;
        }
        final int bId = world.a(x, y, z);
        if (bId == this.cF) {
            return true;
        }
        if (this.displacementIds.containsKey(bId)) {
            return this.displacementIds.get(bId);
        }
        final akc material = aqz.s[bId].cU;
        if (material.c() || material == akc.h || material == akc.i || material == akc.D) {
            return false;
        }
        final int density = BlockFluidBase.getDensity(world, x, y, z);
        return density == Integer.MAX_VALUE || this.density > density;
    }
    
    protected int getLargerQuanta(final acf world, final int x, final int y, final int z, final int compare) {
        final int quantaRemaining = this.getQuantaValue(world, x, y, z);
        if (quantaRemaining <= 0) {
            return compare;
        }
        return (quantaRemaining >= compare) ? quantaRemaining : compare;
    }
    
    public FluidStack drain(final abw world, final int x, final int y, final int z, final boolean doDrain) {
        if (!this.isSourceBlock((acf)world, x, y, z)) {
            return null;
        }
        if (doDrain) {
            world.i(x, y, z);
        }
        return this.stack.copy();
    }
    
    public boolean canDrain(final abw world, final int x, final int y, final int z) {
        return this.isSourceBlock((acf)world, x, y, z);
    }
}



================================================
FILE: net/minecraftforge/fluids/BlockFluidFinite.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.fluids;

import java.util.Random;

public class BlockFluidFinite extends BlockFluidBase
{
    public BlockFluidFinite(final int id, final Fluid fluid, final akc material) {
        super(id, fluid, material);
    }
    
    @Override
    public int getQuantaValue(final acf world, final int x, final int y, final int z) {
        if (world.c(x, y, z)) {
            return 0;
        }
        if (world.a(x, y, z) != this.cF) {
            return -1;
        }
        final int quantaRemaining = world.h(x, y, z) + 1;
        return quantaRemaining;
    }
    
    @Override
    public boolean a(final int meta, final boolean fullHit) {
        return fullHit && meta == this.quantaPerBlock - 1;
    }
    
    @Override
    public int getMaxRenderHeightMeta() {
        return this.quantaPerBlock - 1;
    }
    
    public void a(final abw world, final int x, final int y, final int z, final Random rand) {
        boolean changed = false;
        final int prevRemaining;
        int quantaRemaining = prevRemaining = world.h(x, y, z) + 1;
        quantaRemaining = this.tryToFlowVerticallyInto(world, x, y, z, quantaRemaining);
        if (quantaRemaining < 1) {
            return;
        }
        if (quantaRemaining != prevRemaining) {
            changed = true;
            if (quantaRemaining == 1) {
                world.b(x, y, z, quantaRemaining - 1, 2);
                return;
            }
        }
        else if (quantaRemaining == 1) {
            return;
        }
        final int lowerthan = quantaRemaining - 1;
        if (this.displaceIfPossible(world, x, y, z - 1)) {
            world.c(x, y, z - 1, 0);
        }
        if (this.displaceIfPossible(world, x, y, z + 1)) {
            world.c(x, y, z + 1, 0);
        }
        if (this.displaceIfPossible(world, x - 1, y, z)) {
            world.c(x - 1, y, z, 0);
        }
        if (this.displaceIfPossible(world, x + 1, y, z)) {
            world.c(x + 1, y, z, 0);
        }
        final int north = this.getQuantaValueBelow((acf)world, x, y, z - 1, lowerthan);
        final int south = this.getQuantaValueBelow((acf)world, x, y, z + 1, lowerthan);
        final int west = this.getQuantaValueBelow((acf)world, x - 1, y, z, lowerthan);
        final int east = this.getQuantaValueBelow((acf)world, x + 1, y, z, lowerthan);
        int total = quantaRemaining;
        int count = 1;
        if (north >= 0) {
            ++count;
            total += north;
        }
        if (south >= 0) {
            ++count;
            total += south;
        }
        if (west >= 0) {
            ++count;
            total += west;
        }
        if (east >= 0) {
            ++count;
            total += east;
        }
        if (count == 1) {
            if (changed) {
                world.b(x, y, z, quantaRemaining - 1, 2);
            }
            return;
        }
        int each = total / count;
        int rem = total % count;
        if (north >= 0) {
            int newnorth = each;
            if (rem == count || (rem > 1 && rand.nextInt(count - rem) != 0)) {
                ++newnorth;
                --rem;
            }
            if (newnorth != north) {
                if (newnorth == 0) {
                    world.c(x, y, z - 1, 0);
                }
                else {
                    world.f(x, y, z - 1, this.cF, newnorth - 1, 2);
                }
                world.a(x, y, z - 1, this.cF, this.tickRate);
            }
            --count;
        }
        if (south >= 0) {
            int newsouth = each;
            if (rem == count || (rem > 1 && rand.nextInt(count - rem) != 0)) {
                ++newsouth;
                --rem;
            }
            if (newsouth != south) {
                if (newsouth == 0) {
                    world.c(x, y, z + 1, 0);
                }
                else {
                    world.f(x, y, z + 1, this.cF, newsouth - 1, 2);
                }
                world.a(x, y, z + 1, this.cF, this.tickRate);
            }
            --count;
        }
        if (west >= 0) {
            int newwest = each;
            if (rem == count || (rem > 1 && rand.nextInt(count - rem) != 0)) {
                ++newwest;
                --rem;
            }
            if (newwest != west) {
                if (newwest == 0) {
                    world.c(x - 1, y, z, 0);
                }
                else {
                    world.f(x - 1, y, z, this.cF, newwest - 1, 2);
                }
                world.a(x - 1, y, z, this.cF, this.tickRate);
            }
            --count;
        }
        if (east >= 0) {
            int neweast = each;
            if (rem == count || (rem > 1 && rand.nextInt(count - rem) != 0)) {
                ++neweast;
                --rem;
            }
            if (neweast != east) {
                if (neweast == 0) {
                    world.c(x + 1, y, z, 0);
                }
                else {
                    world.f(x + 1, y, z, this.cF, neweast - 1, 2);
                }
                world.a(x + 1, y, z, this.cF, this.tickRate);
            }
            --count;
        }
        if (rem > 0) {
            ++each;
        }
        world.b(x, y, z, each - 1, 2);
    }
    
    public int tryToFlowVerticallyInto(final abw world, final int x, final int y, final int z, final int amtToInput) {
        final int otherY = y + this.densityDir;
        if (otherY < 0 || otherY >= world.R()) {
            world.i(x, y, z);
            return 0;
        }
        int amt = this.getQuantaValueBelow((acf)world, x, otherY, z, this.quantaPerBlock);
        if (amt >= 0) {
            amt += amtToInput;
            if (amt > this.quantaPerBlock) {
                world.f(x, otherY, z, this.cF, this.quantaPerBlock - 1, 3);
                world.a(x, otherY, z, this.cF, this.tickRate);
                return amt - this.quantaPerBlock;
            }
            if (amt > 0) {
                world.f(x, otherY, z, this.cF, amt - 1, 3);
                world.a(x, otherY, z, this.cF, this.tickRate);
                world.i(x, y, z);
                return 0;
            }
            return amtToInput;
        }
        else {
            final int density_other = BlockFluidBase.getDensity((acf)world, x, otherY, z);
            if (density_other != Integer.MAX_VALUE) {
                if (this.densityDir < 0) {
                    if (density_other < this.density) {
                        final int bId = world.a(x, otherY, z);
                        final BlockFluidBase block = (BlockFluidBase)aqz.s[bId];
                        final int otherData = world.h(x, otherY, z);
                        world.f(x, otherY, z, this.cF, amtToInput - 1, 3);
                        world.f(x, y, z, bId, otherData, 3);
                        world.a(x, otherY, z, this.cF, this.tickRate);
                        world.a(x, y, z, bId, block.a(world));
                        return 0;
                    }
                }
                else if (density_other > this.density) {
                    final int bId = world.a(x, otherY, z);
                    final BlockFluidBase block = (BlockFluidBase)aqz.s[bId];
                    final int otherData = world.h(x, otherY, z);
                    world.f(x, otherY, z, this.cF, amtToInput - 1, 3);
                    world.f(x, y, z, bId, otherData, 3);
                    world.a(x, otherY, z, this.cF, this.tickRate);
                    world.a(x, y, z, bId, block.a(world));
                    return 0;
                }
                return amtToInput;
            }
            if (this.displaceIfPossible(world, x, otherY, z)) {
                world.f(x, otherY, z, this.cF, amtToInput - 1, 3);
                world.a(x, otherY, z, this.cF, this.tickRate);
                world.i(x, y, z);
                return 0;
            }
            return amtToInput;
        }
    }
    
    public FluidStack drain(final abw world, final int x, final int y, final int z, final boolean doDrain) {
        return null;
    }
    
    public boolean canDrain(final abw world, final int x, final int y, final int z) {
        return false;
    }
}



================================================
FILE: net/minecraftforge/fluids/Fluid.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.fluids;

import com.google.common.collect.Maps;
import cpw.mods.fml.common.LoaderException;
import cpw.mods.fml.common.FMLLog;
import net.minecraftforge.common.ForgeDummyContainer;
import java.util.Locale;
import java.util.Map;

public class Fluid
{
    protected final String fluidName;
    protected String unlocalizedName;
    protected ms stillIcon;
    protected ms flowingIcon;
    protected int luminosity;
    protected int density;
    protected int temperature;
    protected int viscosity;
    protected boolean isGaseous;
    protected yq rarity;
    protected int blockID;
    private static Map<String, String> legacyNames;
    
    public Fluid(final String fluidName) {
        this.luminosity = 0;
        this.density = 1000;
        this.temperature = 295;
        this.viscosity = 1000;
        this.rarity = yq.a;
        this.blockID = -1;
        this.fluidName = fluidName.toLowerCase(Locale.ENGLISH);
        this.unlocalizedName = fluidName;
    }
    
    public Fluid setUnlocalizedName(final String unlocalizedName) {
        this.unlocalizedName = unlocalizedName;
        return this;
    }
    
    public Fluid setBlockID(final int blockID) {
        if (this.blockID == -1 || this.blockID == blockID) {
            this.blockID = blockID;
        }
        else {
            if (ForgeDummyContainer.forceDuplicateFluidBlockCrash) {
                FMLLog.severe("A mod has attempted to assign BlockID " + blockID + " to the Fluid '" + this.fluidName + "' but this Fluid has already been linked to BlockID " + this.blockID + ". Configure your mods to prevent this from happening.", new Object[0]);
                throw new LoaderException(new RuntimeException("A mod has attempted to assign BlockID " + blockID + " to the Fluid '" + this.fluidName + "' but this Fluid has already been linked to BlockID " + this.blockID + ". Configure your mods to prevent this from happening."));
            }
            FMLLog.warning("A mod has attempted to assign BlockID " + blockID + " to the Fluid '" + this.fluidName + "' but this Fluid has already been linked to BlockID " + this.blockID + ". Configure your mods to prevent this from happening.", new Object[0]);
        }
        return this;
    }
    
    public Fluid setBlockID(final aqz block) {
        return this.setBlockID(block.cF);
    }
    
    public Fluid setLuminosity(final int luminosity) {
        this.luminosity = luminosity;
        return this;
    }
    
    public Fluid setDensity(final int density) {
        this.density = density;
        return this;
    }
    
    public Fluid setTemperature(final int temperature) {
        this.temperature = temperature;
        return this;
    }
    
    public Fluid setViscosity(final int viscosity) {
        this.viscosity = viscosity;
        return this;
    }
    
    public Fluid setGaseous(final boolean isGaseous) {
        this.isGaseous = isGaseous;
        return this;
    }
    
    public Fluid setRarity(final yq rarity) {
        this.rarity = rarity;
        return this;
    }
    
    public final String getName() {
        return this.fluidName;
    }
    
    public final int getID() {
        return FluidRegistry.getFluidID(this.fluidName);
    }
    
    public final int getBlockID() {
        return this.blockID;
    }
    
    public final boolean canBePlacedInWorld() {
        return this.blockID != -1;
    }
    
    public String getLocalizedName() {
        final String s = this.getUnlocalizedName();
        return (s == null) ? "" : bu.a(s);
    }
    
    public String getUnlocalizedName() {
        return "fluid." + this.unlocalizedName;
    }
    
    public final int getSpriteNumber() {
        return 0;
    }
    
    public final int getLuminosity() {
        return this.luminosity;
    }
    
    public final int getDensity() {
        return this.density;
    }
    
    public final int getTemperature() {
        return this.temperature;
    }
    
    public final int getViscosity() {
        return this.viscosity;
    }
    
    public final boolean isGaseous() {
        return this.isGaseous;
    }
    
    public yq getRarity() {
        return this.rarity;
    }
    
    public int getColor() {
        return 16777215;
    }
    
    public final Fluid setStillIcon(final ms stillIcon) {
        this.stillIcon = stillIcon;
        return this;
    }
    
    public final Fluid setFlowingIcon(final ms flowingIcon) {
        this.flowingIcon = flowingIcon;
        return this;
    }
    
    public final Fluid setIcons(final ms stillIcon, final ms flowingIcon) {
        return this.setStillIcon(stillIcon).setFlowingIcon(flowingIcon);
    }
    
    public final Fluid setIcons(final ms commonIcon) {
        return this.setStillIcon(commonIcon).setFlowingIcon(commonIcon);
    }
    
    public ms getIcon() {
        return this.getStillIcon();
    }
    
    public ms getStillIcon() {
        return this.stillIcon;
    }
    
    public ms getFlowingIcon() {
        return this.flowingIcon;
    }
    
    public int getLuminosity(final FluidStack stack) {
        return this.getLuminosity();
    }
    
    public int getDensity(final FluidStack stack) {
        return this.getDensity();
    }
    
    public int getTemperature(final FluidStack stack) {
        return this.getTemperature();
    }
    
    public int getViscosity(final FluidStack stack) {
        return this.getViscosity();
    }
    
    public boolean isGaseous(final FluidStack stack) {
        return this.isGaseous();
    }
    
    public yq getRarity(final FluidStack stack) {
        return this.getRarity();
    }
    
    public int getColor(final FluidStack stack) {
        return this.getColor();
    }
    
    public ms getIcon(final FluidStack stack) {
        return this.getIcon();
    }
    
    public int getLuminosity(final abw world, final int x, final int y, final int z) {
        return this.getLuminosity();
    }
    
    public int getDensity(final abw world, final int x, final int y, final int z) {
        return this.getDensity();
    }
    
    public int getTemperature(final abw world, final int x, final int y, final int z) {
        return this.getTemperature();
    }
    
    public int getViscosity(final abw world, final int x, final int y, final int z) {
        return this.getViscosity();
    }
    
    public boolean isGaseous(final abw world, final int x, final int y, final int z) {
        return this.isGaseous();
    }
    
    public yq getRarity(final abw world, final int x, final int y, final int z) {
        return this.getRarity();
    }
    
    public int getColor(final abw world, final int x, final int y, final int z) {
        return this.getColor();
    }
    
    public ms getIcon(final abw world, final int x, final int y, final int z) {
        return this.getIcon();
    }
    
    static String convertLegacyName(final String fluidName) {
        return (fluidName != null && Fluid.legacyNames.containsKey(fluidName)) ? Fluid.legacyNames.get(fluidName) : fluidName;
    }
    
    public static void registerLegacyName(final String legacyName, final String canonicalName) {
        Fluid.legacyNames.put(legacyName.toLowerCase(Locale.ENGLISH), canonicalName);
    }
    
    static {
        Fluid.legacyNames = Maps.newHashMap();
    }
}



================================================
FILE: net/minecraftforge/fluids/FluidContainerRegistry.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.fluids;

import java.util.HashSet;
import java.util.HashMap;
import net.minecraftforge.event.Event;
import net.minecraftforge.common.MinecraftForge;
import java.util.Arrays;
import java.util.Set;
import java.util.List;
import java.util.Map;

public abstract class FluidContainerRegistry
{
    private static Map<List, FluidContainerData> containerFluidMap;
    private static Map<List, FluidContainerData> filledContainerMap;
    private static Set<List> emptyContainers;
    public static final int BUCKET_VOLUME = 1000;
    public static final ye EMPTY_BUCKET;
    public static final ye EMPTY_BOTTLE;
    private static final ye NULL_EMPTYCONTAINER;
    
    private FluidContainerRegistry() {
    }
    
    public static boolean registerFluidContainer(final FluidStack stack, final ye filledContainer, final ye emptyContainer) {
        return registerFluidContainer(new FluidContainerData(stack, filledContainer, emptyContainer));
    }
    
    public static boolean registerFluidContainer(final Fluid fluid, final ye filledContainer, final ye emptyContainer) {
        if (!FluidRegistry.isFluidRegistered(fluid)) {
            FluidRegistry.registerFluid(fluid);
        }
        return registerFluidContainer(new FluidStack(fluid, 1000), filledContainer, emptyContainer);
    }
    
    public static boolean registerFluidContainer(final FluidStack stack, final ye filledContainer) {
        return registerFluidContainer(new FluidContainerData(stack, filledContainer, null, true));
    }
    
    public static boolean registerFluidContainer(final Fluid fluid, final ye filledContainer) {
        if (!FluidRegistry.isFluidRegistered(fluid)) {
            FluidRegistry.registerFluid(fluid);
        }
        return registerFluidContainer(new FluidStack(fluid, 1000), filledContainer);
    }
    
    public static boolean registerFluidContainer(final FluidContainerData data) {
        if (isFilledContainer(data.filledContainer)) {
            return false;
        }
        FluidContainerRegistry.containerFluidMap.put(Arrays.asList(data.filledContainer.d, data.filledContainer.k()), data);
        if (data.emptyContainer != null && data.emptyContainer != FluidContainerRegistry.NULL_EMPTYCONTAINER) {
            FluidContainerRegistry.filledContainerMap.put(Arrays.asList(data.emptyContainer.d, data.emptyContainer.k(), data.fluid.fluidID), data);
            FluidContainerRegistry.emptyContainers.add(Arrays.asList(data.emptyContainer.d, data.emptyContainer.k()));
        }
        MinecraftForge.EVENT_BUS.post(new FluidContainerRegisterEvent(data));
        return true;
    }
    
    public static FluidStack getFluidForFilledItem(final ye container) {
        if (container == null) {
            return null;
        }
        final FluidContainerData data = FluidContainerRegistry.containerFluidMap.get(Arrays.asList(container.d, container.k()));
        return (data == null) ? null : data.fluid.copy();
    }
    
    public static ye fillFluidContainer(final FluidStack fluid, final ye container) {
        if (container == null || fluid == null) {
            return null;
        }
        final FluidContainerData data = FluidContainerRegistry.filledContainerMap.get(Arrays.asList(container.d, container.k(), fluid.fluidID));
        if (data != null && fluid.amount >= data.fluid.amount) {
            return data.filledContainer.m();
        }
        return null;
    }
    
    public static boolean containsFluid(final ye container, final FluidStack fluid) {
        if (container == null || fluid == null) {
            return false;
        }
        final FluidContainerData data = FluidContainerRegistry.filledContainerMap.get(Arrays.asList(container.d, container.k(), fluid.fluidID));
        return data != null && data.fluid.isFluidEqual(fluid);
    }
    
    public static boolean isBucket(final ye container) {
        if (container == null) {
            return false;
        }
        if (container.a(FluidContainerRegistry.EMPTY_BUCKET)) {
            return true;
        }
        final FluidContainerData data = FluidContainerRegistry.containerFluidMap.get(Arrays.asList(container.d, container.k()));
        return data != null && data.emptyContainer.a(FluidContainerRegistry.EMPTY_BUCKET);
    }
    
    public static boolean isContainer(final ye container) {
        return isEmptyContainer(container) || isFilledContainer(container);
    }
    
    public static boolean isEmptyContainer(final ye container) {
        return container != null && FluidContainerRegistry.emptyContainers.contains(Arrays.asList(container.d, container.k()));
    }
    
    public static boolean isFilledContainer(final ye container) {
        return container != null && getFluidForFilledItem(container) != null;
    }
    
    public static FluidContainerData[] getRegisteredFluidContainerData() {
        return FluidContainerRegistry.containerFluidMap.values().toArray(new FluidContainerData[FluidContainerRegistry.containerFluidMap.size()]);
    }
    
    static {
        FluidContainerRegistry.containerFluidMap = new HashMap<List, FluidContainerData>();
        FluidContainerRegistry.filledContainerMap = new HashMap<List, FluidContainerData>();
        FluidContainerRegistry.emptyContainers = new HashSet<List>();
        EMPTY_BUCKET = new ye(yc.ay);
        EMPTY_BOTTLE = new ye(yc.bv);
        NULL_EMPTYCONTAINER = new ye(yc.ay);
        registerFluidContainer(FluidRegistry.WATER, new ye(yc.az), FluidContainerRegistry.EMPTY_BUCKET);
        registerFluidContainer(FluidRegistry.LAVA, new ye(yc.aA), FluidContainerRegistry.EMPTY_BUCKET);
        registerFluidContainer(FluidRegistry.WATER, new ye((yc)yc.bu), FluidContainerRegistry.EMPTY_BOTTLE);
    }
    
    public static class FluidContainerData
    {
        public final FluidStack fluid;
        public final ye filledContainer;
        public final ye emptyContainer;
        
        public FluidContainerData(final FluidStack stack, final ye filledContainer, final ye emptyContainer) {
            this(stack, filledContainer, emptyContainer, false);
        }
        
        public FluidContainerData(final FluidStack stack, final ye filledContainer, final ye emptyContainer, final boolean nullEmpty) {
            this.fluid = stack;
            this.filledContainer = filledContainer;
            this.emptyContainer = ((emptyContainer == null) ? FluidContainerRegistry.NULL_EMPTYCONTAINER : emptyContainer);
            if (stack == null || filledContainer == null || (emptyContainer == null && !nullEmpty)) {
                throw new RuntimeException("Invalid FluidContainerData - a parameter was null.");
            }
        }
        
        public FluidContainerData copy() {
            return new FluidContainerData(this.fluid, this.filledContainer, this.emptyContainer, true);
        }
    }
    
    public static class FluidContainerRegisterEvent extends Event
    {
        public final FluidContainerData data;
        
        public FluidContainerRegisterEvent(final FluidContainerData data) {
            this.data = data.copy();
        }
    }
}



================================================
FILE: net/minecraftforge/fluids/FluidEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.fluids;

import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.event.Event;

public class FluidEvent extends Event
{
    public final FluidStack fluid;
    public final int x;
    public final int y;
    public final int z;
    public final abw world;
    
    public FluidEvent(final FluidStack fluid, final abw world, final int x, final int y, final int z) {
        this.fluid = fluid;
        this.world = world;
        this.x = x;
        this.y = y;
        this.z = z;
    }
    
    public static final void fireEvent(final FluidEvent event) {
        MinecraftForge.EVENT_BUS.post(event);
    }
    
    public static class FluidMotionEvent extends FluidEvent
    {
        public FluidMotionEvent(final FluidStack fluid, final abw world, final int x, final int y, final int z) {
            super(fluid, world, x, y, z);
        }
    }
    
    public static class FluidFillingEvent extends FluidEvent
    {
        public final IFluidTank tank;
        
        public FluidFillingEvent(final FluidStack fluid, final abw world, final int x, final int y, final int z, final IFluidTank tank) {
            super(fluid, world, x, y, z);
            this.tank = tank;
        }
    }
    
    public static class FluidDrainingEvent extends FluidEvent
    {
        public final IFluidTank tank;
        
        public FluidDrainingEvent(final FluidStack fluid, final abw world, final int x, final int y, final int z, final IFluidTank tank) {
            super(fluid, world, x, y, z);
            this.tank = tank;
        }
    }
    
    public static class FluidSpilledEvent extends FluidEvent
    {
        public FluidSpilledEvent(final FluidStack fluid, final abw world, final int x, final int y, final int z) {
            super(fluid, world, x, y, z);
        }
    }
}



================================================
FILE: net/minecraftforge/fluids/FluidIdMapPacket.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.fluids;

import com.google.common.io.ByteArrayDataInput;
import java.util.Iterator;
import com.google.common.io.ByteArrayDataOutput;
import java.util.Map;
import com.google.common.io.ByteStreams;
import com.google.common.collect.HashBiMap;
import com.google.common.collect.BiMap;
import net.minecraftforge.common.network.ForgePacket;

public class FluidIdMapPacket extends ForgePacket
{
    private BiMap<String, Integer> fluidIds;
    
    public FluidIdMapPacket() {
        this.fluidIds = (BiMap<String, Integer>)HashBiMap.create();
    }
    
    @Override
    public byte[] generatePacket() {
        final ByteArrayDataOutput dat = ByteStreams.newDataOutput();
        dat.writeInt(FluidRegistry.maxID);
        for (final Map.Entry<String, Integer> entry : FluidRegistry.fluidIDs.entrySet()) {
            dat.writeUTF((String)entry.getKey());
            dat.writeInt((int)entry.getValue());
        }
        return dat.toByteArray();
    }
    
    @Override
    public ForgePacket consumePacket(final byte[] data) {
        final ByteArrayDataInput dat = ByteStreams.newDataInput(data);
        for (int listSize = dat.readInt(), i = 0; i < listSize; ++i) {
            final String fluidName = dat.readUTF();
            final int fluidId = dat.readInt();
            this.fluidIds.put((Object)fluidName, (Object)fluidId);
        }
        return this;
    }
    
    @Override
    public void execute(final cm network, final uf player) {
        FluidRegistry.initFluidIDs(this.fluidIds);
    }
}



================================================
FILE: net/minecraftforge/fluids/FluidRegistry.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.fluids;

import java.util.Iterator;
import com.google.common.collect.HashBiMap;
import com.google.common.collect.ImmutableMap;
import net.minecraftforge.event.Event;
import net.minecraftforge.common.MinecraftForge;
import java.util.Map;
import com.google.common.collect.BiMap;
import java.util.HashMap;

public abstract class FluidRegistry
{
    static int maxID;
    static HashMap<String, Fluid> fluids;
    static BiMap<String, Integer> fluidIDs;
    static BiMap<aqz, Fluid> fluidBlocks;
    public static final Fluid WATER;
    public static final Fluid LAVA;
    public static int renderIdFluid;
    
    private FluidRegistry() {
    }
    
    static void initFluidIDs(final BiMap<String, Integer> newfluidIDs) {
        FluidRegistry.maxID = newfluidIDs.size();
        FluidRegistry.fluidIDs.clear();
        FluidRegistry.fluidIDs.putAll((Map)newfluidIDs);
    }
    
    public static boolean registerFluid(final Fluid fluid) {
        if (FluidRegistry.fluidIDs.containsKey((Object)fluid.getName())) {
            return false;
        }
        FluidRegistry.fluids.put(fluid.getName(), fluid);
        FluidRegistry.fluidIDs.put((Object)fluid.getName(), (Object)(++FluidRegistry.maxID));
        MinecraftForge.EVENT_BUS.post(new FluidRegisterEvent(fluid.getName(), FluidRegistry.maxID));
        return true;
    }
    
    public static boolean isFluidRegistered(final Fluid fluid) {
        return FluidRegistry.fluidIDs.containsKey((Object)fluid.getName());
    }
    
    public static boolean isFluidRegistered(final String fluidName) {
        return FluidRegistry.fluidIDs.containsKey((Object)fluidName);
    }
    
    public static Fluid getFluid(final String fluidName) {
        return FluidRegistry.fluids.get(fluidName);
    }
    
    public static Fluid getFluid(final int fluidID) {
        return FluidRegistry.fluids.get(getFluidName(fluidID));
    }
    
    public static String getFluidName(final int fluidID) {
        return (String)FluidRegistry.fluidIDs.inverse().get((Object)fluidID);
    }
    
    public static String getFluidName(final FluidStack stack) {
        return getFluidName(stack.fluidID);
    }
    
    public static int getFluidID(final String fluidName) {
        return (int)FluidRegistry.fluidIDs.get((Object)fluidName);
    }
    
    public static FluidStack getFluidStack(final String fluidName, final int amount) {
        if (!FluidRegistry.fluidIDs.containsKey((Object)fluidName)) {
            return null;
        }
        return new FluidStack(getFluidID(fluidName), amount);
    }
    
    public static Map<String, Fluid> getRegisteredFluids() {
        return (Map<String, Fluid>)ImmutableMap.copyOf((Map)FluidRegistry.fluids);
    }
    
    public static Map<String, Integer> getRegisteredFluidIDs() {
        return (Map<String, Integer>)ImmutableMap.copyOf((Map)FluidRegistry.fluidIDs);
    }
    
    public static Fluid lookupFluidForBlock(final aqz block) {
        if (FluidRegistry.fluidBlocks == null) {
            FluidRegistry.fluidBlocks = (BiMap<aqz, Fluid>)HashBiMap.create();
            for (final Fluid fluid : FluidRegistry.fluids.values()) {
                if (fluid.canBePlacedInWorld() && aqz.s[fluid.getBlockID()] != null) {
                    FluidRegistry.fluidBlocks.put((Object)aqz.s[fluid.getBlockID()], (Object)fluid);
                }
            }
        }
        return (Fluid)FluidRegistry.fluidBlocks.get((Object)block);
    }
    
    static {
        FluidRegistry.maxID = 0;
        FluidRegistry.fluids = new HashMap<String, Fluid>();
        FluidRegistry.fluidIDs = (BiMap<String, Integer>)HashBiMap.create();
        WATER = new Fluid("water") {
            @Override
            public String getLocalizedName() {
                return bu.a("tile.water.name");
            }
        }.setBlockID(aqz.G.cF).setUnlocalizedName(aqz.G.a());
        LAVA = new Fluid("lava") {
            @Override
            public String getLocalizedName() {
                return bu.a("tile.lava.name");
            }
        }.setBlockID(aqz.I.cF).setLuminosity(15).setDensity(3000).setViscosity(6000).setTemperature(1300).setUnlocalizedName(aqz.I.a());
        FluidRegistry.renderIdFluid = -1;
        registerFluid(FluidRegistry.WATER);
        registerFluid(FluidRegistry.LAVA);
    }
    
    public static class FluidRegisterEvent extends Event
    {
        public final String fluidName;
        public final int fluidID;
        
        public FluidRegisterEvent(final String fluidName, final int fluidID) {
            this.fluidName = fluidName;
            this.fluidID = fluidID;
        }
    }
}



================================================
FILE: net/minecraftforge/fluids/FluidStack.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.fluids;

import java.util.Locale;

public class FluidStack
{
    public int fluidID;
    public int amount;
    public by tag;
    
    public FluidStack(final Fluid fluid, final int amount) {
        this.fluidID = fluid.getID();
        this.amount = amount;
    }
    
    public FluidStack(final int fluidID, final int amount) {
        this.fluidID = fluidID;
        this.amount = amount;
    }
    
    public FluidStack(final int fluidID, final int amount, final by nbt) {
        this(fluidID, amount);
        if (nbt != null) {
            this.tag = (by)nbt.b();
        }
    }
    
    public FluidStack(final FluidStack stack, final int amount) {
        this(stack.fluidID, amount, stack.tag);
    }
    
    public static FluidStack loadFluidStackFromNBT(final by nbt) {
        if (nbt == null) {
            return null;
        }
        String fluidName = nbt.i("FluidName");
        if (fluidName == null) {
            fluidName = (nbt.b("LiquidName") ? nbt.i("LiquidName").toLowerCase(Locale.ENGLISH) : null);
            fluidName = Fluid.convertLegacyName(fluidName);
        }
        if (fluidName == null || FluidRegistry.getFluid(fluidName) == null) {
            return null;
        }
        final FluidStack stack = new FluidStack(FluidRegistry.getFluidID(fluidName), nbt.e("Amount"));
        if (nbt.b("Tag")) {
            stack.tag = nbt.l("Tag");
        }
        else if (nbt.b("extra")) {
            stack.tag = nbt.l("extra");
        }
        return stack;
    }
    
    public by writeToNBT(final by nbt) {
        nbt.a("FluidName", FluidRegistry.getFluidName(this.fluidID));
        nbt.a("Amount", this.amount);
        if (this.tag != null) {
            nbt.a("Tag", (cl)this.tag);
        }
        return nbt;
    }
    
    public final Fluid getFluid() {
        return FluidRegistry.getFluid(this.fluidID);
    }
    
    public FluidStack copy() {
        return new FluidStack(this.fluidID, this.amount, this.tag);
    }
    
    public boolean isFluidEqual(final FluidStack other) {
        return other != null && this.fluidID == other.fluidID && this.isFluidStackTagEqual(other);
    }
    
    private boolean isFluidStackTagEqual(final FluidStack other) {
        return (this.tag == null) ? (other.tag == null) : (other.tag != null && this.tag.equals((Object)other.tag));
    }
    
    public static boolean areFluidStackTagsEqual(final FluidStack stack1, final FluidStack stack2) {
        return (stack1 == null && stack2 == null) || (stack1 != null && stack2 != null && stack1.isFluidStackTagEqual(stack2));
    }
    
    public boolean containsFluid(final FluidStack other) {
        return this.isFluidEqual(other) && this.amount >= other.amount;
    }
    
    public boolean isFluidStackIdentical(final FluidStack other) {
        return this.isFluidEqual(other) && this.amount == other.amount;
    }
    
    public boolean isFluidEqual(final ye other) {
        if (other == null) {
            return false;
        }
        if (other.b() instanceof IFluidContainerItem) {
            return this.isFluidEqual(((IFluidContainerItem)other.b()).getFluid(other));
        }
        return this.isFluidEqual(FluidContainerRegistry.getFluidForFilledItem(other));
    }
    
    @Override
    public final int hashCode() {
        return this.fluidID;
    }
    
    @Override
    public final boolean equals(final Object o) {
        return o instanceof FluidStack && this.isFluidEqual((FluidStack)o);
    }
}



================================================
FILE: net/minecraftforge/fluids/FluidTank.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.fluids;

public class FluidTank implements IFluidTank
{
    protected FluidStack fluid;
    protected int capacity;
    protected asp tile;
    
    public FluidTank(final int capacity) {
        this(null, capacity);
    }
    
    public FluidTank(final FluidStack stack, final int capacity) {
        this.fluid = stack;
        this.capacity = capacity;
    }
    
    public FluidTank(final Fluid fluid, final int amount, final int capacity) {
        this(new FluidStack(fluid, amount), capacity);
    }
    
    public FluidTank readFromNBT(final by nbt) {
        if (!nbt.b("Empty")) {
            final FluidStack fluid = FluidStack.loadFluidStackFromNBT(nbt);
            if (fluid != null) {
                this.setFluid(fluid);
            }
        }
        return this;
    }
    
    public by writeToNBT(final by nbt) {
        if (this.fluid != null) {
            this.fluid.writeToNBT(nbt);
        }
        else {
            nbt.a("Empty", "");
        }
        return nbt;
    }
    
    public void setFluid(final FluidStack fluid) {
        this.fluid = fluid;
    }
    
    public void setCapacity(final int capacity) {
        this.capacity = capacity;
    }
    
    @Override
    public FluidStack getFluid() {
        return this.fluid;
    }
    
    @Override
    public int getFluidAmount() {
        if (this.fluid == null) {
            return 0;
        }
        return this.fluid.amount;
    }
    
    @Override
    public int getCapacity() {
        return this.capacity;
    }
    
    @Override
    public FluidTankInfo getInfo() {
        return new FluidTankInfo(this);
    }
    
    @Override
    public int fill(final FluidStack resource, final boolean doFill) {
        if (resource == null) {
            return 0;
        }
        if (!doFill) {
            if (this.fluid == null) {
                return Math.min(this.capacity, resource.amount);
            }
            if (!this.fluid.isFluidEqual(resource)) {
                return 0;
            }
            return Math.min(this.capacity - this.fluid.amount, resource.amount);
        }
        else {
            if (this.fluid == null) {
                this.fluid = new FluidStack(resource, Math.min(this.capacity, resource.amount));
                if (this.tile != null) {
                    FluidEvent.fireEvent(new FluidEvent.FluidFillingEvent(this.fluid, this.tile.k, this.tile.l, this.tile.m, this.tile.n, this));
                }
                return this.fluid.amount;
            }
            if (!this.fluid.isFluidEqual(resource)) {
                return 0;
            }
            int filled = this.capacity - this.fluid.amount;
            if (resource.amount < filled) {
                final FluidStack fluid = this.fluid;
                fluid.amount += resource.amount;
                filled = resource.amount;
            }
            else {
                this.fluid.amount = this.capacity;
            }
            if (this.tile != null) {
                FluidEvent.fireEvent(new FluidEvent.FluidFillingEvent(this.fluid, this.tile.k, this.tile.l, this.tile.m, this.tile.n, this));
            }
            return filled;
        }
    }
    
    @Override
    public FluidStack drain(final int maxDrain, final boolean doDrain) {
        if (this.fluid == null) {
            return null;
        }
        int drained = maxDrain;
        if (this.fluid.amount < drained) {
            drained = this.fluid.amount;
        }
        final FluidStack stack = new FluidStack(this.fluid, drained);
        if (doDrain) {
            final FluidStack fluid = this.fluid;
            fluid.amount -= drained;
            if (this.fluid.amount <= 0) {
                this.fluid = null;
            }
            if (this.tile != null) {
                FluidEvent.fireEvent(new FluidEvent.FluidDrainingEvent(this.fluid, this.tile.k, this.tile.l, this.tile.m, this.tile.n, this));
            }
        }
        return stack;
    }
}



================================================
FILE: net/minecraftforge/fluids/FluidTankInfo.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.fluids;

public final class FluidTankInfo
{
    public final FluidStack fluid;
    public final int capacity;
    
    public FluidTankInfo(final FluidStack fluid, final int capacity) {
        this.fluid = fluid;
        this.capacity = capacity;
    }
    
    public FluidTankInfo(final IFluidTank tank) {
        this.fluid = tank.getFluid();
        this.capacity = tank.getCapacity();
    }
}



================================================
FILE: net/minecraftforge/fluids/IFluidBlock.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.fluids;

public interface IFluidBlock
{
    Fluid getFluid();
    
    FluidStack drain(final abw p0, final int p1, final int p2, final int p3, final boolean p4);
    
    boolean canDrain(final abw p0, final int p1, final int p2, final int p3);
    
    float getFilledPercentage(final abw p0, final int p1, final int p2, final int p3);
}



================================================
FILE: net/minecraftforge/fluids/IFluidContainerItem.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.fluids;

public interface IFluidContainerItem
{
    FluidStack getFluid(final ye p0);
    
    int getCapacity(final ye p0);
    
    int fill(final ye p0, final FluidStack p1, final boolean p2);
    
    FluidStack drain(final ye p0, final int p1, final boolean p2);
}



================================================
FILE: net/minecraftforge/fluids/IFluidHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.fluids;

import net.minecraftforge.common.ForgeDirection;

public interface IFluidHandler
{
    int fill(final ForgeDirection p0, final FluidStack p1, final boolean p2);
    
    FluidStack drain(final ForgeDirection p0, final FluidStack p1, final boolean p2);
    
    FluidStack drain(final ForgeDirection p0, final int p1, final boolean p2);
    
    boolean canFill(final ForgeDirection p0, final Fluid p1);
    
    boolean canDrain(final ForgeDirection p0, final Fluid p1);
    
    FluidTankInfo[] getTankInfo(final ForgeDirection p0);
}



================================================
FILE: net/minecraftforge/fluids/IFluidTank.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.fluids;

public interface IFluidTank
{
    FluidStack getFluid();
    
    int getFluidAmount();
    
    int getCapacity();
    
    FluidTankInfo getInfo();
    
    int fill(final FluidStack p0, final boolean p1);
    
    FluidStack drain(final int p0, final boolean p1);
}



================================================
FILE: net/minecraftforge/fluids/ItemFluidContainer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.fluids;

public class ItemFluidContainer extends yc implements IFluidContainerItem
{
    protected int capacity;
    
    public ItemFluidContainer(final int itemID) {
        super(itemID);
    }
    
    public ItemFluidContainer(final int itemID, final int capacity) {
        super(itemID);
        this.capacity = capacity;
    }
    
    public ItemFluidContainer setCapacity(final int capacity) {
        this.capacity = capacity;
        return this;
    }
    
    public FluidStack getFluid(final ye container) {
        if (container.e == null || !container.e.b("Fluid")) {
            return null;
        }
        return FluidStack.loadFluidStackFromNBT(container.e.l("Fluid"));
    }
    
    public int getCapacity(final ye container) {
        return this.capacity;
    }
    
    public int fill(final ye container, final FluidStack resource, final boolean doFill) {
        if (resource == null) {
            return 0;
        }
        if (!doFill) {
            if (container.e == null || !container.e.b("Fluid")) {
                return Math.min(this.capacity, resource.amount);
            }
            final FluidStack stack = FluidStack.loadFluidStackFromNBT(container.e.l("Fluid"));
            if (stack == null) {
                return Math.min(this.capacity, resource.amount);
            }
            if (!stack.isFluidEqual(resource)) {
                return 0;
            }
            return Math.min(this.capacity - stack.amount, resource.amount);
        }
        else {
            if (container.e == null) {
                container.e = new by();
            }
            if (!container.e.b("Fluid")) {
                final by fluidTag = resource.writeToNBT(new by());
                if (this.capacity < resource.amount) {
                    fluidTag.a("Amount", this.capacity);
                    container.e.a("Fluid", (cl)fluidTag);
                    return this.capacity;
                }
                container.e.a("Fluid", (cl)fluidTag);
                return resource.amount;
            }
            else {
                final by fluidTag = container.e.l("Fluid");
                final FluidStack stack2 = FluidStack.loadFluidStackFromNBT(fluidTag);
                if (!stack2.isFluidEqual(resource)) {
                    return 0;
                }
                int filled = this.capacity - stack2.amount;
                if (resource.amount < filled) {
                    final FluidStack fluidStack = stack2;
                    fluidStack.amount += resource.amount;
                    filled = resource.amount;
                }
                else {
                    stack2.amount = this.capacity;
                }
                container.e.a("Fluid", (cl)stack2.writeToNBT(fluidTag));
                return filled;
            }
        }
    }
    
    public FluidStack drain(final ye container, final int maxDrain, final boolean doDrain) {
        if (container.e == null || !container.e.b("Fluid") || maxDrain == 0) {
            return null;
        }
        final FluidStack stack = FluidStack.loadFluidStackFromNBT(container.e.l("Fluid"));
        if (stack == null) {
            return null;
        }
        final int drained = Math.min(stack.amount, maxDrain);
        if (doDrain) {
            if (maxDrain >= stack.amount) {
                container.e.o("Fluid");
                if (container.e.d()) {
                    container.e = null;
                }
                return stack;
            }
            final by fluidTag = container.e.l("Fluid");
            fluidTag.a("Amount", fluidTag.e("Amount") - maxDrain);
            container.e.a("Fluid", (cl)fluidTag);
        }
        stack.amount = drained;
        return stack;
    }
}



================================================
FILE: net/minecraftforge/fluids/RenderBlockFluid.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.fluids;

import cpw.mods.fml.client.registry.ISimpleBlockRenderingHandler;

public class RenderBlockFluid implements ISimpleBlockRenderingHandler
{
    public static RenderBlockFluid instance;
    static final float LIGHT_Y_NEG = 0.5f;
    static final float LIGHT_Y_POS = 1.0f;
    static final float LIGHT_XZ_NEG = 0.8f;
    static final float LIGHT_XZ_POS = 0.6f;
    static final double RENDER_OFFSET = 0.0010000000474974513;
    
    public float getFluidHeightAverage(final float[] flow) {
        float total = 0.0f;
        int count = 0;
        float end = 0.0f;
        for (int i = 0; i < flow.length; ++i) {
            if (flow[i] >= 0.875f && end != 1.0f) {
                end = flow[i];
            }
            if (flow[i] >= 0.0f) {
                total += flow[i];
                ++count;
            }
        }
        if (end == 0.0f) {
            end = total / count;
        }
        return end;
    }
    
    public float getFluidHeightForRender(final acf world, final int x, final int y, final int z, final BlockFluidBase block) {
        if (world.a(x, y, z) == block.cF) {
            if (world.g(x, y - block.densityDir, z).d()) {
                return 1.0f;
            }
            if (world.h(x, y, z) == block.getMaxRenderHeightMeta()) {
                return 0.875f;
            }
        }
        return (!world.g(x, y, z).a() && world.a(x, y - block.densityDir, z) == block.cF) ? 1.0f : (block.getQuantaPercentage(world, x, y, z) * 0.875f);
    }
    
    @Override
    public void renderInventoryBlock(final aqz block, final int metadata, final int modelID, final bfr renderer) {
    }
    
    @Override
    public boolean renderWorldBlock(final acf world, final int x, final int y, final int z, final aqz block, final int modelId, final bfr renderer) {
        if (!(block instanceof BlockFluidBase)) {
            return false;
        }
        final bfq tessellator = bfq.a;
        final int color = block.c(world, x, y, z);
        final float red = (color >> 16 & 0xFF) / 255.0f;
        final float green = (color >> 8 & 0xFF) / 255.0f;
        final float blue = (color & 0xFF) / 255.0f;
        final BlockFluidBase theFluid = (BlockFluidBase)block;
        final int bMeta = world.h(x, y, z);
        final boolean renderTop = world.a(x, y - theFluid.densityDir, z) != theFluid.cF;
        final boolean renderBottom = block.a(world, x, y + theFluid.densityDir, z, 0) && world.a(x, y + theFluid.densityDir, z) != theFluid.cF;
        final boolean[] renderSides = { block.a(world, x, y, z - 1, 2), block.a(world, x, y, z + 1, 3), block.a(world, x - 1, y, z, 4), block.a(world, x + 1, y, z, 5) };
        if (!renderTop && !renderBottom && !renderSides[0] && !renderSides[1] && !renderSides[2] && !renderSides[3]) {
            return false;
        }
        boolean rendered = false;
        final float flow11 = this.getFluidHeightForRender(world, x, y, z, theFluid);
        double heightNW;
        double heightSW;
        double heightSE;
        double heightNE;
        if (flow11 != 1.0f) {
            final float flow12 = this.getFluidHeightForRender(world, x - 1, y, z - 1, theFluid);
            final float flow13 = this.getFluidHeightForRender(world, x - 1, y, z, theFluid);
            final float flow14 = this.getFluidHeightForRender(world, x - 1, y, z + 1, theFluid);
            final float flow15 = this.getFluidHeightForRender(world, x, y, z - 1, theFluid);
            final float flow16 = this.getFluidHeightForRender(world, x, y, z + 1, theFluid);
            final float flow17 = this.getFluidHeightForRender(world, x + 1, y, z - 1, theFluid);
            final float flow18 = this.getFluidHeightForRender(world, x + 1, y, z, theFluid);
            final float flow19 = this.getFluidHeightForRender(world, x + 1, y, z + 1, theFluid);
            heightNW = this.getFluidHeightAverage(new float[] { flow12, flow13, flow15, flow11 });
            heightSW = this.getFluidHeightAverage(new float[] { flow13, flow14, flow16, flow11 });
            heightSE = this.getFluidHeightAverage(new float[] { flow16, flow18, flow19, flow11 });
            heightNE = this.getFluidHeightAverage(new float[] { flow15, flow17, flow18, flow11 });
        }
        else {
            heightNW = flow11;
            heightSW = flow11;
            heightSE = flow11;
            heightNE = flow11;
        }
        final boolean rises = theFluid.densityDir == 1;
        if (renderer.f || renderTop) {
            rendered = true;
            ms iconStill = block.a(1, bMeta);
            final float flowDir = (float)BlockFluidBase.getFlowDirection(world, x, y, z);
            if (flowDir > -999.0f) {
                iconStill = block.a(2, bMeta);
            }
            heightNW -= 0.0010000000474974513;
            heightSW -= 0.0010000000474974513;
            heightSE -= 0.0010000000474974513;
            heightNE -= 0.0010000000474974513;
            double u2;
            double v2;
            double u3;
            double v3;
            double u4;
            double v4;
            double u5;
            double v5;
            if (flowDir < -999.0f) {
                u2 = iconStill.a(0.0);
                v2 = iconStill.b(0.0);
                u3 = u2;
                v3 = iconStill.b(16.0);
                u4 = iconStill.a(16.0);
                v4 = v3;
                u5 = u4;
                v5 = v2;
            }
            else {
                final float xFlow = ls.a(flowDir) * 0.25f;
                final float zFlow = ls.b(flowDir) * 0.25f;
                u2 = iconStill.a((double)(8.0f + (-zFlow - xFlow) * 16.0f));
                v2 = iconStill.b((double)(8.0f + (-zFlow + xFlow) * 16.0f));
                u3 = iconStill.a((double)(8.0f + (-zFlow + xFlow) * 16.0f));
                v3 = iconStill.b((double)(8.0f + (zFlow + xFlow) * 16.0f));
                u4 = iconStill.a((double)(8.0f + (zFlow + xFlow) * 16.0f));
                v4 = iconStill.b((double)(8.0f + (zFlow - xFlow) * 16.0f));
                u5 = iconStill.a((double)(8.0f + (zFlow - xFlow) * 16.0f));
                v5 = iconStill.b((double)(8.0f + (-zFlow - xFlow) * 16.0f));
            }
            tessellator.c(block.e(world, x, y, z));
            tessellator.a(1.0f * red, 1.0f * green, 1.0f * blue);
            if (!rises) {
                tessellator.a((double)(x + 0), y + heightNW, (double)(z + 0), u2, v2);
                tessellator.a((double)(x + 0), y + heightSW, (double)(z + 1), u3, v3);
                tessellator.a((double)(x + 1), y + heightSE, (double)(z + 1), u4, v4);
                tessellator.a((double)(x + 1), y + heightNE, (double)(z + 0), u5, v5);
            }
            else {
                tessellator.a((double)(x + 1), y + 1 - heightNE, (double)(z + 0), u5, v5);
                tessellator.a((double)(x + 1), y + 1 - heightSE, (double)(z + 1), u4, v4);
                tessellator.a((double)(x + 0), y + 1 - heightSW, (double)(z + 1), u3, v3);
                tessellator.a((double)(x + 0), y + 1 - heightNW, (double)(z + 0), u2, v2);
            }
        }
        if (renderer.f || renderBottom) {
            rendered = true;
            tessellator.c(block.e(world, x, y - 1, z));
            if (!rises) {
                tessellator.a(0.5f * red, 0.5f * green, 0.5f * blue);
                renderer.a(block, (double)x, y + 0.0010000000474974513, (double)z, block.a(0, bMeta));
            }
            else {
                tessellator.a(1.0f * red, 1.0f * green, 1.0f * blue);
                renderer.b(block, (double)x, y + 0.0010000000474974513, (double)z, block.a(1, bMeta));
            }
        }
        for (int side = 0; side < 4; ++side) {
            int x2 = x;
            int z2 = z;
            switch (side) {
                case 0: {
                    --z2;
                    break;
                }
                case 1: {
                    ++z2;
                    break;
                }
                case 2: {
                    --x2;
                    break;
                }
                case 3: {
                    ++x2;
                    break;
                }
            }
            final ms iconFlow = block.a(side + 2, bMeta);
            if (renderer.f || renderSides[side]) {
                rendered = true;
                double ty1;
                double ty2;
                double tx1;
                double tx2;
                double tz1;
                double tz2;
                if (side == 0) {
                    ty1 = heightNW;
                    ty2 = heightNE;
                    tx1 = x;
                    tx2 = x + 1;
                    tz1 = z + 0.0010000000474974513;
                    tz2 = z + 0.0010000000474974513;
                }
                else if (side == 1) {
                    ty1 = heightSE;
                    ty2 = heightSW;
                    tx1 = x + 1;
                    tx2 = x;
                    tz1 = z + 1 - 0.0010000000474974513;
                    tz2 = z + 1 - 0.0010000000474974513;
                }
                else if (side == 2) {
                    ty1 = heightSW;
                    ty2 = heightNW;
                    tx1 = x + 0.0010000000474974513;
                    tx2 = x + 0.0010000000474974513;
                    tz1 = z + 1;
                    tz2 = z;
                }
                else {
                    ty1 = heightNE;
                    ty2 = heightSE;
                    tx1 = x + 1 - 0.0010000000474974513;
                    tx2 = x + 1 - 0.0010000000474974513;
                    tz1 = z;
                    tz2 = z + 1;
                }
                final float u1Flow = iconFlow.a(0.0);
                final float u2Flow = iconFlow.a(8.0);
                final float v1Flow = iconFlow.b((1.0 - ty1) * 16.0 * 0.5);
                final float v2Flow = iconFlow.b((1.0 - ty2) * 16.0 * 0.5);
                final float v3Flow = iconFlow.b(8.0);
                tessellator.c(block.e(world, x2, y, z2));
                float sideLighting = 1.0f;
                if (side < 2) {
                    sideLighting = 0.8f;
                }
                else {
                    sideLighting = 0.6f;
                }
                tessellator.a(1.0f * sideLighting * red, 1.0f * sideLighting * green, 1.0f * sideLighting * blue);
                if (!rises) {
                    tessellator.a(tx1, y + ty1, tz1, (double)u1Flow, (double)v1Flow);
                    tessellator.a(tx2, y + ty2, tz2, (double)u2Flow, (double)v2Flow);
                    tessellator.a(tx2, (double)(y + 0), tz2, (double)u2Flow, (double)v3Flow);
                    tessellator.a(tx1, (double)(y + 0), tz1, (double)u1Flow, (double)v3Flow);
                }
                else {
                    tessellator.a(tx1, (double)(y + 1 - 0), tz1, (double)u1Flow, (double)v3Flow);
                    tessellator.a(tx2, (double)(y + 1 - 0), tz2, (double)u2Flow, (double)v3Flow);
                    tessellator.a(tx2, y + 1 - ty2, tz2, (double)u2Flow, (double)v2Flow);
                    tessellator.a(tx1, y + 1 - ty1, tz1, (double)u1Flow, (double)v1Flow);
                }
            }
        }
        renderer.i = 0.0;
        renderer.j = 1.0;
        return rendered;
    }
    
    @Override
    public boolean shouldRender3DInInventory() {
        return false;
    }
    
    @Override
    public int getRenderId() {
        return FluidRegistry.renderIdFluid;
    }
    
    static {
        RenderBlockFluid.instance = new RenderBlockFluid();
    }
}



================================================
FILE: net/minecraftforge/fluids/TileFluidHandler.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.fluids;

import net.minecraftforge.common.ForgeDirection;

public class TileFluidHandler extends asp implements IFluidHandler
{
    protected FluidTank tank;
    
    public TileFluidHandler() {
        this.tank = new FluidTank(1000);
    }
    
    public void a(final by tag) {
        super.a(tag);
        this.tank.writeToNBT(tag);
    }
    
    public void b(final by tag) {
        super.b(tag);
        this.tank.readFromNBT(tag);
    }
    
    public int fill(final ForgeDirection from, final FluidStack resource, final boolean doFill) {
        return this.tank.fill(resource, doFill);
    }
    
    public FluidStack drain(final ForgeDirection from, final FluidStack resource, final boolean doDrain) {
        if (resource == null || !resource.isFluidEqual(this.tank.getFluid())) {
            return null;
        }
        return this.tank.drain(resource.amount, doDrain);
    }
    
    public FluidStack drain(final ForgeDirection from, final int maxDrain, final boolean doDrain) {
        return this.tank.drain(maxDrain, doDrain);
    }
    
    public boolean canFill(final ForgeDirection from, final Fluid fluid) {
        return true;
    }
    
    public boolean canDrain(final ForgeDirection from, final Fluid fluid) {
        return true;
    }
    
    public FluidTankInfo[] getTankInfo(final ForgeDirection from) {
        return new FluidTankInfo[] { this.tank.getInfo() };
    }
}



================================================
FILE: net/minecraftforge/liquids/IBlockLiquid.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.liquids;

@Deprecated
public interface IBlockLiquid extends ILiquid
{
    boolean willGenerateSources();
    
    int getFlowDistance();
    
    byte[] getLiquidRGB();
    
    String getLiquidBlockTextureFile();
    
    by getLiquidProperties();
    
    public enum BlockType
    {
        NONE, 
        VANILLA, 
        FINITE;
    }
}



================================================
FILE: net/minecraftforge/liquids/ILiquid.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.liquids;

@Deprecated
public interface ILiquid
{
    int stillLiquidId();
    
    boolean isMetaSensitive();
    
    int stillLiquidMeta();
}



================================================
FILE: net/minecraftforge/liquids/ILiquidTank.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.liquids;

@Deprecated
public interface ILiquidTank
{
    LiquidStack getLiquid();
    
    int getCapacity();
    
    int fill(final LiquidStack p0, final boolean p1);
    
    LiquidStack drain(final int p0, final boolean p1);
    
    int getTankPressure();
}



================================================
FILE: net/minecraftforge/liquids/ITankContainer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.liquids;

import net.minecraftforge.common.ForgeDirection;

@Deprecated
public interface ITankContainer
{
    int fill(final ForgeDirection p0, final LiquidStack p1, final boolean p2);
    
    int fill(final int p0, final LiquidStack p1, final boolean p2);
    
    LiquidStack drain(final ForgeDirection p0, final int p1, final boolean p2);
    
    LiquidStack drain(final int p0, final int p1, final boolean p2);
    
    ILiquidTank[] getTanks(final ForgeDirection p0);
    
    ILiquidTank getTank(final ForgeDirection p0, final LiquidStack p1);
}



================================================
FILE: net/minecraftforge/liquids/LiquidContainerData.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.liquids;

@Deprecated
public class LiquidContainerData
{
    public final LiquidStack stillLiquid;
    public final ye filled;
    public final ye container;
    
    public LiquidContainerData(final LiquidStack stillLiquid, final ye filled, final ye container) {
        this.stillLiquid = stillLiquid;
        this.filled = filled;
        this.container = container;
        if (stillLiquid == null || filled == null || container == null) {
            throw new RuntimeException("stillLiquid, filled, or container is null, this is an error");
        }
    }
}



================================================
FILE: net/minecraftforge/liquids/LiquidContainerRegistry.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.liquids;

import java.util.HashSet;
import java.util.HashMap;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Set;
import java.util.List;
import java.util.Map;

@Deprecated
public class LiquidContainerRegistry
{
    public static final int BUCKET_VOLUME = 1000;
    public static final ye EMPTY_BUCKET;
    private static Map<List, LiquidContainerData> mapFilledItemFromLiquid;
    private static Map<List, LiquidContainerData> mapLiquidFromFilledItem;
    private static Set<List> setContainerValidation;
    private static Set<List> setLiquidValidation;
    private static ArrayList<LiquidContainerData> liquids;
    
    public static void registerLiquid(final LiquidContainerData data) {
        LiquidContainerRegistry.mapFilledItemFromLiquid.put(Arrays.asList(data.container.d, data.container.k(), data.stillLiquid.itemID, data.stillLiquid.itemMeta), data);
        LiquidContainerRegistry.mapLiquidFromFilledItem.put(Arrays.asList(data.filled.d, data.filled.k()), data);
        LiquidContainerRegistry.setContainerValidation.add(Arrays.asList(data.container.d, data.container.k()));
        LiquidContainerRegistry.setLiquidValidation.add(Arrays.asList(data.stillLiquid.itemID, data.stillLiquid.itemMeta));
        LiquidContainerRegistry.liquids.add(data);
    }
    
    public static LiquidStack getLiquidForFilledItem(final ye filledContainer) {
        if (filledContainer == null) {
            return null;
        }
        final LiquidContainerData ret = LiquidContainerRegistry.mapLiquidFromFilledItem.get(Arrays.asList(filledContainer.d, filledContainer.k()));
        return (ret == null) ? null : ret.stillLiquid.copy();
    }
    
    public static ye fillLiquidContainer(final LiquidStack liquid, final ye emptyContainer) {
        if (emptyContainer == null || liquid == null) {
            return null;
        }
        final LiquidContainerData ret = LiquidContainerRegistry.mapFilledItemFromLiquid.get(Arrays.asList(emptyContainer.d, emptyContainer.k(), liquid.itemID, liquid.itemMeta));
        if (ret != null && liquid.amount >= ret.stillLiquid.amount) {
            return ret.filled.m();
        }
        return null;
    }
    
    public static boolean containsLiquid(final ye filledContainer, final LiquidStack liquid) {
        if (filledContainer == null || liquid == null) {
            return false;
        }
        final LiquidContainerData ret = LiquidContainerRegistry.mapLiquidFromFilledItem.get(Arrays.asList(filledContainer.d, filledContainer.k()));
        return ret != null && ret.stillLiquid.isLiquidEqual(liquid);
    }
    
    public static boolean isBucket(final ye container) {
        if (container == null) {
            return false;
        }
        if (container.a(LiquidContainerRegistry.EMPTY_BUCKET)) {
            return true;
        }
        final LiquidContainerData ret = LiquidContainerRegistry.mapLiquidFromFilledItem.get(Arrays.asList(container.d, container.k()));
        return ret != null && ret.container.a(LiquidContainerRegistry.EMPTY_BUCKET);
    }
    
    public static boolean isContainer(final ye container) {
        return isEmptyContainer(container) || isFilledContainer(container);
    }
    
    public static boolean isEmptyContainer(final ye emptyContainer) {
        return emptyContainer != null && LiquidContainerRegistry.setContainerValidation.contains(Arrays.asList(emptyContainer.d, emptyContainer.k()));
    }
    
    public static boolean isFilledContainer(final ye filledContainer) {
        return filledContainer != null && getLiquidForFilledItem(filledContainer) != null;
    }
    
    public static boolean isLiquid(final ye item) {
        return item != null && LiquidContainerRegistry.setLiquidValidation.contains(Arrays.asList(item.d, item.k()));
    }
    
    public static LiquidContainerData[] getRegisteredLiquidContainerData() {
        return LiquidContainerRegistry.liquids.toArray(new LiquidContainerData[LiquidContainerRegistry.liquids.size()]);
    }
    
    static {
        EMPTY_BUCKET = new ye(yc.ay);
        LiquidContainerRegistry.mapFilledItemFromLiquid = new HashMap<List, LiquidContainerData>();
        LiquidContainerRegistry.mapLiquidFromFilledItem = new HashMap<List, LiquidContainerData>();
        LiquidContainerRegistry.setContainerValidation = new HashSet<List>();
        LiquidContainerRegistry.setLiquidValidation = new HashSet<List>();
        LiquidContainerRegistry.liquids = new ArrayList<LiquidContainerData>();
        registerLiquid(new LiquidContainerData(new LiquidStack(aqz.G, 1000), new ye(yc.az), new ye(yc.ay)));
        registerLiquid(new LiquidContainerData(new LiquidStack(aqz.I, 1000), new ye(yc.aA), new ye(yc.ay)));
        registerLiquid(new LiquidContainerData(new LiquidStack(aqz.G, 1000), new ye((yc)yc.bu), new ye(yc.bv)));
    }
}



================================================
FILE: net/minecraftforge/liquids/LiquidDictionary.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.liquids;

import com.google.common.collect.HashBiMap;
import com.google.common.collect.ImmutableMap;
import java.util.Map;
import net.minecraftforge.event.Event;
import net.minecraftforge.common.MinecraftForge;
import com.google.common.collect.BiMap;

@Deprecated
public abstract class LiquidDictionary
{
    private static BiMap<String, LiquidStack> liquids;
    
    public static LiquidStack getOrCreateLiquid(final String name, final LiquidStack liquid) {
        if (liquid == null) {
            throw new NullPointerException("You cannot register a null LiquidStack");
        }
        final LiquidStack existing = (LiquidStack)LiquidDictionary.liquids.get((Object)name);
        if (existing != null) {
            return existing.copy();
        }
        LiquidDictionary.liquids.put((Object)name, (Object)liquid.copy());
        MinecraftForge.EVENT_BUS.post(new LiquidRegisterEvent(name, liquid));
        return liquid;
    }
    
    public static LiquidStack getLiquid(final String name, final int amount) {
        LiquidStack liquid = (LiquidStack)LiquidDictionary.liquids.get((Object)name);
        if (liquid == null) {
            return null;
        }
        liquid = liquid.copy();
        liquid.amount = amount;
        return liquid;
    }
    
    public static LiquidStack getCanonicalLiquid(final String name) {
        return (LiquidStack)LiquidDictionary.liquids.get((Object)name);
    }
    
    public static Map<String, LiquidStack> getLiquids() {
        return (Map<String, LiquidStack>)ImmutableMap.copyOf((Map)LiquidDictionary.liquids);
    }
    
    public static String findLiquidName(final LiquidStack reference) {
        if (reference != null) {
            return (String)LiquidDictionary.liquids.inverse().get((Object)reference);
        }
        return null;
    }
    
    public static LiquidStack getCanonicalLiquid(final LiquidStack liquidStack) {
        return (LiquidStack)LiquidDictionary.liquids.get(LiquidDictionary.liquids.inverse().get((Object)liquidStack));
    }
    
    static {
        LiquidDictionary.liquids = (BiMap<String, LiquidStack>)HashBiMap.create();
        getOrCreateLiquid("Water", new LiquidStack(aqz.G, 1000));
        getOrCreateLiquid("Lava", new LiquidStack(aqz.I, 1000));
    }
    
    public static class LiquidRegisterEvent extends Event
    {
        public final String Name;
        public final LiquidStack Liquid;
        
        public LiquidRegisterEvent(final String name, final LiquidStack liquid) {
            this.Name = name;
            this.Liquid = liquid.copy();
        }
    }
}



================================================
FILE: net/minecraftforge/liquids/LiquidEvent.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.liquids;

import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.event.Event;

@Deprecated
public class LiquidEvent extends Event
{
    public final LiquidStack liquid;
    public final int x;
    public final int y;
    public final int z;
    public final abw world;
    
    public LiquidEvent(final LiquidStack liquid, final abw world, final int x, final int y, final int z) {
        this.liquid = liquid;
        this.world = world;
        this.x = x;
        this.y = y;
        this.z = z;
    }
    
    public static final void fireEvent(final LiquidEvent event) {
        MinecraftForge.EVENT_BUS.post(event);
    }
    
    public static class LiquidMotionEvent extends LiquidEvent
    {
        public LiquidMotionEvent(final LiquidStack liquid, final abw world, final int x, final int y, final int z) {
            super(liquid, world, x, y, z);
        }
    }
    
    public static class LiquidFillingEvent extends LiquidEvent
    {
        public final ILiquidTank tank;
        
        public LiquidFillingEvent(final LiquidStack liquid, final abw world, final int x, final int y, final int z, final ILiquidTank tank) {
            super(liquid, world, x, y, z);
            this.tank = tank;
        }
    }
    
    public static class LiquidDrainingEvent extends LiquidEvent
    {
        public final ILiquidTank tank;
        
        public LiquidDrainingEvent(final LiquidStack liquid, final abw world, final int x, final int y, final int z, final ILiquidTank tank) {
            super(liquid, world, x, y, z);
            this.tank = tank;
        }
    }
    
    public static class LiquidSpilledEvent extends LiquidEvent
    {
        public LiquidSpilledEvent(final LiquidStack liquid, final abw world, final int x, final int y, final int z) {
            super(liquid, world, x, y, z);
        }
    }
}



================================================
FILE: net/minecraftforge/liquids/LiquidStack.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.liquids;

import cpw.mods.fml.relauncher.Side;
import cpw.mods.fml.relauncher.SideOnly;

@Deprecated
public class LiquidStack
{
    public final int itemID;
    public int amount;
    public final int itemMeta;
    public by extra;
    private String textureSheet;
    @SideOnly(Side.CLIENT)
    private ms renderingIcon;
    
    public LiquidStack(final int itemID, final int amount) {
        this(itemID, amount, 0);
    }
    
    public LiquidStack(final yc item, final int amount) {
        this(item.cv, amount, 0);
    }
    
    public LiquidStack(final aqz block, final int amount) {
        this(block.cF, amount, 0);
    }
    
    public LiquidStack(final int itemID, final int amount, final int itemDamage) {
        this.textureSheet = "/terrain.png";
        this.itemID = itemID;
        this.amount = amount;
        this.itemMeta = itemDamage;
    }
    
    public LiquidStack(final int itemID, final int amount, final int itemDamage, final by nbt) {
        this(itemID, amount, itemDamage);
        if (nbt != null) {
            this.extra = (by)nbt.b();
        }
    }
    
    public by writeToNBT(final by nbt) {
        nbt.a("Amount", this.amount);
        nbt.a("Id", (short)this.itemID);
        nbt.a("Meta", (short)this.itemMeta);
        final String name = LiquidDictionary.findLiquidName(this);
        if (name != null) {
            nbt.a("LiquidName", name);
        }
        if (this.extra != null) {
            nbt.a("extra", (cl)this.extra);
        }
        return nbt;
    }
    
    public LiquidStack copy() {
        return new LiquidStack(this.itemID, this.amount, this.itemMeta, this.extra);
    }
    
    public boolean isLiquidEqual(final LiquidStack other) {
        return other != null && this.itemID == other.itemID && this.itemMeta == other.itemMeta && ((this.extra != null) ? this.extra.equals((Object)other.extra) : (other.extra == null));
    }
    
    public boolean containsLiquid(final LiquidStack other) {
        return this.isLiquidEqual(other) && this.amount >= other.amount;
    }
    
    public boolean isLiquidEqual(final ye other) {
        return other != null && ((this.itemID == other.d && this.itemMeta == other.k()) || this.isLiquidEqual(LiquidContainerRegistry.getLiquidForFilledItem(other)));
    }
    
    public ye asItemStack() {
        final ye stack = new ye(this.itemID, 1, this.itemMeta);
        if (this.extra != null) {
            stack.e = (by)this.extra.b();
        }
        return stack;
    }
    
    public static LiquidStack loadLiquidStackFromNBT(final by nbt) {
        if (nbt == null) {
            return null;
        }
        final String liquidName = nbt.i("LiquidName");
        int itemID = nbt.d("Id");
        int itemMeta = nbt.d("Meta");
        final LiquidStack liquid = LiquidDictionary.getCanonicalLiquid(liquidName);
        if (liquid != null) {
            itemID = liquid.itemID;
            itemMeta = liquid.itemMeta;
        }
        else if (yc.g[itemID] == null) {
            return null;
        }
        final int amount = nbt.e("Amount");
        final LiquidStack liquidstack = new LiquidStack(itemID, amount, itemMeta);
        if (nbt.b("extra")) {
            liquidstack.extra = nbt.l("extra");
        }
        return (liquidstack.itemID == 0) ? null : liquidstack;
    }
    
    public String getTextureSheet() {
        return this.textureSheet;
    }
    
    public LiquidStack setTextureSheet(final String textureSheet) {
        this.textureSheet = textureSheet;
        return this;
    }
    
    @SideOnly(Side.CLIENT)
    public ms getRenderingIcon() {
        if (this.itemID == aqz.G.cF) {
            return apc.b("water");
        }
        if (this.itemID == aqz.I.cF) {
            return apc.b("lava");
        }
        return this.renderingIcon;
    }
    
    @SideOnly(Side.CLIENT)
    public LiquidStack setRenderingIcon(final ms icon) {
        this.renderingIcon = icon;
        return this;
    }
    
    @Override
    public final int hashCode() {
        return 31 * this.itemMeta + this.itemID;
    }
    
    @Override
    public final boolean equals(final Object ob) {
        if (ob instanceof LiquidStack) {
            final LiquidStack ls = (LiquidStack)ob;
            return ls.itemID == this.itemID && ls.itemMeta == this.itemMeta && ((this.extra != null) ? this.extra.equals((Object)ls.extra) : (ls.extra == null));
        }
        return false;
    }
    
    public LiquidStack canonical() {
        return LiquidDictionary.getCanonicalLiquid(this);
    }
}



================================================
FILE: net/minecraftforge/liquids/LiquidTank.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.liquids;

@Deprecated
public class LiquidTank implements ILiquidTank
{
    private LiquidStack liquid;
    private int capacity;
    private int tankPressure;
    private asp tile;
    
    public LiquidTank(final int capacity) {
        this(null, capacity);
    }
    
    public LiquidTank(final int liquidId, final int quantity, final int capacity) {
        this(new LiquidStack(liquidId, quantity), capacity);
    }
    
    public LiquidTank(final int liquidId, final int quantity, final int capacity, final asp tile) {
        this(liquidId, quantity, capacity);
        this.tile = tile;
    }
    
    public LiquidTank(final LiquidStack liquid, final int capacity) {
        this.liquid = liquid;
        this.capacity = capacity;
    }
    
    public LiquidTank(final LiquidStack liquid, final int capacity, final asp tile) {
        this(liquid, capacity);
        this.tile = tile;
    }
    
    @Override
    public LiquidStack getLiquid() {
        return this.liquid;
    }
    
    @Override
    public int getCapacity() {
        return this.capacity;
    }
    
    public void setLiquid(final LiquidStack liquid) {
        this.liquid = liquid;
    }
    
    public void setCapacity(final int capacity) {
        this.capacity = capacity;
    }
    
    @Override
    public int fill(final LiquidStack resource, final boolean doFill) {
        if (resource == null || resource.itemID <= 0) {
            return 0;
        }
        if (this.liquid == null || this.liquid.itemID <= 0) {
            if (resource.amount <= this.capacity) {
                if (doFill) {
                    this.liquid = resource.copy();
                }
                return resource.amount;
            }
            if (doFill) {
                this.liquid = resource.copy();
                this.liquid.amount = this.capacity;
                if (this.tile != null) {
                    LiquidEvent.fireEvent(new LiquidEvent.LiquidFillingEvent(this.liquid, this.tile.k, this.tile.l, this.tile.m, this.tile.n, this));
                }
            }
            return this.capacity;
        }
        else {
            if (!this.liquid.isLiquidEqual(resource)) {
                return 0;
            }
            final int space = this.capacity - this.liquid.amount;
            if (resource.amount <= space) {
                if (doFill) {
                    final LiquidStack liquid = this.liquid;
                    liquid.amount += resource.amount;
                }
                return resource.amount;
            }
            if (doFill) {
                this.liquid.amount = this.capacity;
            }
            return space;
        }
    }
    
    @Override
    public LiquidStack drain(final int maxDrain, final boolean doDrain) {
        if (this.liquid == null || this.liquid.itemID <= 0) {
            return null;
        }
        if (this.liquid.amount <= 0) {
            return null;
        }
        int used = maxDrain;
        if (this.liquid.amount < used) {
            used = this.liquid.amount;
        }
        if (doDrain) {
            final LiquidStack liquid = this.liquid;
            liquid.amount -= used;
        }
        final LiquidStack drained = new LiquidStack(this.liquid.itemID, used, this.liquid.itemMeta);
        if (this.liquid.amount <= 0) {
            this.liquid = null;
        }
        if (doDrain && this.tile != null) {
            LiquidEvent.fireEvent(new LiquidEvent.LiquidDrainingEvent(drained, this.tile.k, this.tile.l, this.tile.m, this.tile.n, this));
        }
        return drained;
    }
    
    @Override
    public int getTankPressure() {
        return this.tankPressure;
    }
    
    public void setTankPressure(final int pressure) {
        this.tankPressure = pressure;
    }
    
    public String getLiquidName() {
        return (this.liquid != null) ? LiquidDictionary.findLiquidName(this.liquid) : null;
    }
    
    public boolean containsValidLiquid() {
        return LiquidDictionary.findLiquidName(this.liquid) != null;
    }
    
    public by writeToNBT(final by nbt) {
        if (this.containsValidLiquid()) {
            this.liquid.writeToNBT(nbt);
        }
        else {
            nbt.a("emptyTank", "");
        }
        return nbt;
    }
    
    public LiquidTank readFromNBT(final by nbt) {
        if (!nbt.b("emptyTank")) {
            final LiquidStack liquid = LiquidStack.loadLiquidStackFromNBT(nbt);
            if (liquid != null) {
                this.setLiquid(liquid);
            }
        }
        return this;
    }
}



================================================
FILE: net/minecraftforge/oredict/OreDictionary.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.oredict;

import net.minecraftforge.event.Event;
import net.minecraftforge.common.MinecraftForge;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Collection;
import java.util.ArrayList;
import java.util.HashMap;

public class OreDictionary
{
    private static boolean hasInit;
    private static int maxID;
    private static HashMap<String, Integer> oreIDs;
    private static HashMap<Integer, ArrayList<ye>> oreStacks;
    public static final int WILDCARD_VALUE = 32767;
    
    public static void initVanillaEntries() {
        if (!OreDictionary.hasInit) {
            registerOre("logWood", new ye(aqz.O, 1, 32767));
            registerOre("plankWood", new ye(aqz.C, 1, 32767));
            registerOre("slabWood", new ye((aqz)aqz.bT, 1, 32767));
            registerOre("stairWood", aqz.ay);
            registerOre("stairWood", aqz.cc);
            registerOre("stairWood", aqz.cd);
            registerOre("stairWood", aqz.cb);
            registerOre("stickWood", yc.F);
            registerOre("treeSapling", new ye(aqz.D, 1, 32767));
            registerOre("treeLeaves", new ye((aqz)aqz.P, 1, 32767));
            registerOre("oreGold", aqz.L);
            registerOre("oreIron", aqz.M);
            registerOre("oreLapis", aqz.S);
            registerOre("oreDiamond", aqz.aB);
            registerOre("oreRedstone", aqz.aS);
            registerOre("oreEmerald", aqz.bW);
            registerOre("oreQuartz", aqz.cu);
            registerOre("stone", aqz.y);
            registerOre("cobblestone", aqz.B);
            registerOre("record", yc.cj);
            registerOre("record", yc.ck);
            registerOre("record", yc.cl);
            registerOre("record", yc.cm);
            registerOre("record", yc.cn);
            registerOre("record", yc.co);
            registerOre("record", yc.cp);
            registerOre("record", yc.cq);
            registerOre("record", yc.cr);
            registerOre("record", yc.cs);
            registerOre("record", yc.ct);
            registerOre("record", yc.cu);
        }
        final Map<ye, String> replacements = new HashMap<ye, String>();
        replacements.put(new ye(yc.F), "stickWood");
        replacements.put(new ye(aqz.C), "plankWood");
        replacements.put(new ye(aqz.C, 1, 32767), "plankWood");
        replacements.put(new ye(aqz.y), "stone");
        replacements.put(new ye(aqz.y, 1, 32767), "stone");
        replacements.put(new ye(aqz.B), "cobblestone");
        replacements.put(new ye(aqz.B, 1, 32767), "cobblestone");
        final String[] dyes = { "dyeBlack", "dyeRed", "dyeGreen", "dyeBrown", "dyeBlue", "dyePurple", "dyeCyan", "dyeLightGray", "dyeGray", "dyePink", "dyeLime", "dyeYellow", "dyeLightBlue", "dyeMagenta", "dyeOrange", "dyeWhite" };
        for (int i = 0; i < 16; ++i) {
            final ye dye = new ye(yc.aY, 1, i);
            if (!OreDictionary.hasInit) {
                registerOre(dyes[i], dye);
            }
            replacements.put(dye, dyes[i]);
        }
        OreDictionary.hasInit = true;
        final ye[] replaceStacks = replacements.keySet().toArray(new ye[replacements.keySet().size()]);
        final ye[] exclusions = { new ye(aqz.T), new ye(yc.be), new ye(aqz.br), new ye((aqz)aqz.ap), new ye(aqz.aM), new ye(aqz.cg), new ye(aqz.ay), new ye(aqz.cc), new ye(aqz.cd), new ye(aqz.cb) };
        final List recipes = aaf.a().b();
        final List<aah> recipesToRemove = new ArrayList<aah>();
        final List<aah> recipesToAdd = new ArrayList<aah>();
        for (final Object obj : recipes) {
            if (obj instanceof aai) {
                final aai recipe = (aai)obj;
                final ye output = recipe.b();
                if (output != null && containsMatch(false, exclusions, output)) {
                    continue;
                }
                if (!containsMatch(true, recipe.d, replaceStacks)) {
                    continue;
                }
                recipesToRemove.add((aah)recipe);
                recipesToAdd.add((aah)new ShapedOreRecipe(recipe, replacements));
            }
            else {
                if (!(obj instanceof aaj)) {
                    continue;
                }
                final aaj recipe2 = (aaj)obj;
                final ye output = recipe2.b();
                if (output != null && containsMatch(false, exclusions, output)) {
                    continue;
                }
                if (!containsMatch(true, recipe2.b.toArray(new ye[recipe2.b.size()]), replaceStacks)) {
                    continue;
                }
                recipesToRemove.add((aah)obj);
                final aah newRecipe = (aah)new ShapelessOreRecipe(recipe2, replacements);
                recipesToAdd.add(newRecipe);
            }
        }
        recipes.removeAll(recipesToRemove);
        recipes.addAll(recipesToAdd);
        if (recipesToRemove.size() > 0) {
            System.out.println("Replaced " + recipesToRemove.size() + " ore recipies");
        }
    }
    
    public static int getOreID(final String name) {
        Integer val = OreDictionary.oreIDs.get(name);
        if (val == null) {
            val = OreDictionary.maxID++;
            OreDictionary.oreIDs.put(name, val);
            OreDictionary.oreStacks.put(val, new ArrayList<ye>());
        }
        return val;
    }
    
    public static String getOreName(final int id) {
        for (final Map.Entry<String, Integer> entry : OreDictionary.oreIDs.entrySet()) {
            if (id == entry.getValue()) {
                return entry.getKey();
            }
        }
        return "Unknown";
    }
    
    public static int getOreID(final ye itemStack) {
        if (itemStack == null) {
            return -1;
        }
        for (final Map.Entry<Integer, ArrayList<ye>> ore : OreDictionary.oreStacks.entrySet()) {
            for (final ye target : ore.getValue()) {
                if (itemStack.d == target.d && (target.k() == 32767 || itemStack.k() == target.k())) {
                    return ore.getKey();
                }
            }
        }
        return -1;
    }
    
    public static ArrayList<ye> getOres(final String name) {
        return getOres(getOreID(name));
    }
    
    public static String[] getOreNames() {
        return OreDictionary.oreIDs.keySet().toArray(new String[OreDictionary.oreIDs.keySet().size()]);
    }
    
    public static ArrayList<ye> getOres(final Integer id) {
        ArrayList<ye> val = OreDictionary.oreStacks.get(id);
        if (val == null) {
            val = new ArrayList<ye>();
            OreDictionary.oreStacks.put(id, val);
        }
        return val;
    }
    
    private static boolean containsMatch(final boolean strict, final ye[] inputs, final ye... targets) {
        for (final ye input : inputs) {
            for (final ye target : targets) {
                if (itemMatches(target, input, strict)) {
                    return true;
                }
            }
        }
        return false;
    }
    
    public static boolean itemMatches(final ye target, final ye input, final boolean strict) {
        return (input != null || target == null) && (input == null || target != null) && target.d == input.d && ((target.k() == 32767 && !strict) || target.k() == input.k());
    }
    
    public static void registerOre(final String name, final yc ore) {
        registerOre(name, new ye(ore));
    }
    
    public static void registerOre(final String name, final aqz ore) {
        registerOre(name, new ye(ore));
    }
    
    public static void registerOre(final String name, final ye ore) {
        registerOre(name, getOreID(name), ore);
    }
    
    public static void registerOre(final int id, final yc ore) {
        registerOre(id, new ye(ore));
    }
    
    public static void registerOre(final int id, final aqz ore) {
        registerOre(id, new ye(ore));
    }
    
    public static void registerOre(final int id, final ye ore) {
        registerOre(getOreName(id), id, ore);
    }
    
    private static void registerOre(final String name, final int id, ye ore) {
        final ArrayList<ye> ores = getOres(id);
        ore = ore.m();
        ores.add(ore);
        MinecraftForge.EVENT_BUS.post(new OreRegisterEvent(name, ore));
    }
    
    static {
        OreDictionary.hasInit = false;
        OreDictionary.maxID = 0;
        OreDictionary.oreIDs = new HashMap<String, Integer>();
        OreDictionary.oreStacks = new HashMap<Integer, ArrayList<ye>>();
        initVanillaEntries();
    }
    
    public static class OreRegisterEvent extends Event
    {
        public final String Name;
        public final ye Ore;
        
        public OreRegisterEvent(final String name, final ye ore) {
            this.Name = name;
            this.Ore = ore;
        }
    }
}



================================================
FILE: net/minecraftforge/oredict/RecipeSorter.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.oredict;

import com.google.common.base.Joiner;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;
import com.google.common.collect.Maps;
import java.util.Iterator;
import cpw.mods.fml.common.toposort.TopologicalSort;
import java.util.List;
import java.util.Collections;
import cpw.mods.fml.common.FMLLog;
import java.util.Set;
import java.util.Map;
import java.util.Comparator;

public class RecipeSorter implements Comparator<aah>
{
    private static Map<Class, Category> categories;
    private static Map<String, Class> types;
    private static Map<String, SortEntry> entries;
    private static Map<Class, Integer> priorities;
    public static RecipeSorter INSTANCE;
    private static boolean isDirty;
    private static SortEntry before;
    private static SortEntry after;
    private static Set<Class> warned;
    
    private RecipeSorter() {
        register("minecraft:shaped", aai.class, Category.SHAPED, "before:minecraft:shapeless");
        register("minecraft:mapextending", aad.class, Category.SHAPED, "after:minecraft:shaped before:minecraft:shapeless");
        register("minecraft:shapeless", aaj.class, Category.SHAPELESS, "after:minecraft:shaped");
        register("minecraft:fireworks", zz.class, Category.SHAPELESS, "after:minecraft:shapeless");
        register("minecraft:armordyes", zw.class, Category.SHAPELESS, "after:minecraft:shapeless");
        register("minecraft:mapcloning", aac.class, Category.SHAPELESS, "after:minecraft:shapeless");
        register("forge:shapedore", ShapedOreRecipe.class, Category.SHAPED, "after:minecraft:shaped before:minecraft:shapeless");
        register("forge:shapelessore", ShapelessOreRecipe.class, Category.SHAPELESS, "after:minecraft:shapeless");
    }
    
    @Override
    public int compare(final aah r1, final aah r2) {
        final Category c1 = getCategory(r1);
        final Category c2 = getCategory(r2);
        if (c1 == Category.SHAPELESS && c2 == Category.SHAPED) {
            return 1;
        }
        if (c1 == Category.SHAPED && c2 == Category.SHAPELESS) {
            return -1;
        }
        if (r2.a() < r1.a()) {
            return -1;
        }
        if (r2.a() > r1.a()) {
            return 1;
        }
        return getPriority(r2) - getPriority(r1);
    }
    
    public static void sortCraftManager() {
        bake();
        FMLLog.fine("Sorting recipies", new Object[0]);
        RecipeSorter.warned.clear();
        Collections.sort((List<Object>)aaf.a().b(), (Comparator<? super Object>)RecipeSorter.INSTANCE);
    }
    
    public static void register(final String name, final Class recipe, final Category category, final String dependancies) {
        assert category != Category.UNKNOWN : "Category must not be unknown!";
        RecipeSorter.isDirty = true;
        final SortEntry entry = new SortEntry(name, recipe, category, dependancies);
        RecipeSorter.entries.put(name, entry);
        setCategory(recipe, category);
    }
    
    public static void setCategory(final Class recipe, final Category category) {
        assert category != Category.UNKNOWN : "Category must not be unknown!";
        RecipeSorter.categories.put(recipe, category);
    }
    
    public static Category getCategory(final aah recipe) {
        return getCategory(recipe.getClass());
    }
    
    public static Category getCategory(final Class recipe) {
        Class cls = recipe;
        Category ret = RecipeSorter.categories.get(cls);
        if (ret == null) {
            cls = cls.getSuperclass();
            while (cls != Object.class) {
                ret = RecipeSorter.categories.get(cls);
                if (ret != null) {
                    RecipeSorter.categories.put(recipe, ret);
                    return ret;
                }
            }
        }
        return (ret == null) ? Category.UNKNOWN : ret;
    }
    
    private static int getPriority(final aah recipe) {
        Class cls = recipe.getClass();
        Integer ret = RecipeSorter.priorities.get(cls);
        if (ret == null) {
            final RecipeSorter instance = RecipeSorter.INSTANCE;
            if (!RecipeSorter.warned.contains(cls)) {
                FMLLog.fine("  Unknown recipe class! %s Modder please refer to %s", cls.getName(), RecipeSorter.class.getName());
                RecipeSorter.warned.add(cls);
            }
            cls = cls.getSuperclass();
            while (cls != Object.class) {
                ret = RecipeSorter.priorities.get(cls);
                if (ret != null) {
                    RecipeSorter.priorities.put(recipe.getClass(), ret);
                    FMLLog.fine("    Parent Found: %d - %s", ret, cls.getName());
                    return ret;
                }
            }
        }
        return (ret == null) ? 0 : ret;
    }
    
    private static void bake() {
        if (!RecipeSorter.isDirty) {
            return;
        }
        FMLLog.fine("Forge RecipeSorter Baking:", new Object[0]);
        final TopologicalSort.DirectedGraph<SortEntry> sorter = new TopologicalSort.DirectedGraph<SortEntry>();
        sorter.addNode(RecipeSorter.before);
        sorter.addNode(RecipeSorter.after);
        sorter.addEdge(RecipeSorter.before, RecipeSorter.after);
        for (final Map.Entry<String, SortEntry> entry : RecipeSorter.entries.entrySet()) {
            sorter.addNode(entry.getValue());
        }
        for (final Map.Entry<String, SortEntry> e : RecipeSorter.entries.entrySet()) {
            final SortEntry entry2 = e.getValue();
            boolean postAdded = false;
            sorter.addEdge(RecipeSorter.before, entry2);
            for (final String dep : entry2.after) {
                if (RecipeSorter.entries.containsKey(dep)) {
                    sorter.addEdge(RecipeSorter.entries.get(dep), entry2);
                }
            }
            for (final String dep : entry2.before) {
                postAdded = true;
                sorter.addEdge(entry2, RecipeSorter.after);
                if (RecipeSorter.entries.containsKey(dep)) {
                    sorter.addEdge(entry2, RecipeSorter.entries.get(dep));
                }
            }
            if (!postAdded) {
                sorter.addEdge(entry2, RecipeSorter.after);
            }
        }
        final List<SortEntry> sorted = TopologicalSort.topologicalSort(sorter);
        int x = sorted.size();
        for (final SortEntry entry3 : sorted) {
            FMLLog.fine("  %d: %s", x, entry3);
            RecipeSorter.priorities.put(entry3.cls, x--);
        }
    }
    
    static {
        RecipeSorter.categories = Maps.newHashMap();
        RecipeSorter.types = Maps.newHashMap();
        RecipeSorter.entries = Maps.newHashMap();
        RecipeSorter.priorities = Maps.newHashMap();
        RecipeSorter.INSTANCE = new RecipeSorter();
        RecipeSorter.isDirty = true;
        RecipeSorter.before = new SortEntry("Before", (Class)null, Category.UNKNOWN, "");
        RecipeSorter.after = new SortEntry("After", (Class)null, Category.UNKNOWN, "");
        RecipeSorter.warned = Sets.newHashSet();
    }
    
    public enum Category
    {
        UNKNOWN, 
        SHAPELESS, 
        SHAPED;
    }
    
    private static class SortEntry
    {
        private String name;
        private Class cls;
        private Category cat;
        List<String> before;
        List<String> after;
        
        private SortEntry(final String name, final Class cls, final Category cat, final String deps) {
            this.before = Lists.newArrayList();
            this.after = Lists.newArrayList();
            this.name = name;
            this.cls = cls;
            this.cat = cat;
            this.parseDepends(deps);
        }
        
        private void parseDepends(final String deps) {
            if (deps.isEmpty()) {
                return;
            }
            for (final String dep : deps.split(" ")) {
                if (dep.startsWith("before:")) {
                    this.before.add(dep.substring(7));
                }
                else {
                    if (!dep.startsWith("after:")) {
                        throw new IllegalArgumentException("Invalid dependancy: " + dep);
                    }
                    this.after.add(dep.substring(6));
                }
            }
        }
        
        @Override
        public String toString() {
            final StringBuilder buf = new StringBuilder();
            buf.append("RecipeEntry(\"").append(this.name).append("\", ");
            buf.append(this.cat.name()).append(", ");
            buf.append((this.cls == null) ? "" : this.cls.getName()).append(")");
            if (this.before.size() > 0) {
                buf.append(" Before: ").append(Joiner.on(", ").join((Iterable)this.before));
            }
            if (this.after.size() > 0) {
                buf.append(" After: ").append(Joiner.on(", ").join((Iterable)this.after));
            }
            return buf.toString();
        }
        
        @Override
        public int hashCode() {
            return this.name.hashCode();
        }
    }
}



================================================
FILE: net/minecraftforge/oredict/ShapedOreRecipe.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.oredict;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map;
import java.util.HashMap;

public class ShapedOreRecipe implements aah
{
    private static final int MAX_CRAFT_GRID_WIDTH = 3;
    private static final int MAX_CRAFT_GRID_HEIGHT = 3;
    private ye output;
    private Object[] input;
    private int width;
    private int height;
    private boolean mirrored;
    
    public ShapedOreRecipe(final aqz result, final Object... recipe) {
        this(new ye(result), recipe);
    }
    
    public ShapedOreRecipe(final yc result, final Object... recipe) {
        this(new ye(result), recipe);
    }
    
    public ShapedOreRecipe(final ye result, Object... recipe) {
        this.output = null;
        this.input = null;
        this.width = 0;
        this.height = 0;
        this.mirrored = true;
        this.output = result.m();
        String shape = "";
        int idx = 0;
        if (recipe[idx] instanceof Boolean) {
            this.mirrored = (boolean)recipe[idx];
            if (recipe[idx + 1] instanceof Object[]) {
                recipe = (Object[])recipe[idx + 1];
            }
            else {
                idx = 1;
            }
        }
        if (recipe[idx] instanceof String[]) {
            final String[] arr$;
            final String[] parts = arr$ = (String[])recipe[idx++];
            for (final String s : arr$) {
                this.width = s.length();
                shape += s;
            }
            this.height = parts.length;
        }
        else {
            while (recipe[idx] instanceof String) {
                final String s2 = (String)recipe[idx++];
                shape += s2;
                this.width = s2.length();
                ++this.height;
            }
        }
        if (this.width * this.height != shape.length()) {
            String ret = "Invalid shaped ore recipe: ";
            for (final Object tmp : recipe) {
                ret = ret + tmp + ", ";
            }
            ret += this.output;
            throw new RuntimeException(ret);
        }
        final HashMap<Character, Object> itemMap = new HashMap<Character, Object>();
        while (idx < recipe.length) {
            final Character chr = (Character)recipe[idx];
            final Object in = recipe[idx + 1];
            if (in instanceof ye) {
                itemMap.put(chr, ((ye)in).m());
            }
            else if (in instanceof yc) {
                itemMap.put(chr, new ye((yc)in));
            }
            else if (in instanceof aqz) {
                itemMap.put(chr, new ye((aqz)in, 1, 32767));
            }
            else {
                if (!(in instanceof String)) {
                    String ret2 = "Invalid shaped ore recipe: ";
                    for (final Object tmp2 : recipe) {
                        ret2 = ret2 + tmp2 + ", ";
                    }
                    ret2 += this.output;
                    throw new RuntimeException(ret2);
                }
                itemMap.put(chr, OreDictionary.getOres((String)in));
            }
            idx += 2;
        }
        this.input = new Object[this.width * this.height];
        int x = 0;
        for (final char chr2 : shape.toCharArray()) {
            this.input[x++] = itemMap.get(chr2);
        }
    }
    
    ShapedOreRecipe(final aai recipe, final Map<ye, String> replacements) {
        this.output = null;
        this.input = null;
        this.width = 0;
        this.height = 0;
        this.mirrored = true;
        this.output = recipe.b();
        this.width = recipe.b;
        this.height = recipe.c;
        this.input = new Object[recipe.d.length];
        for (int i = 0; i < this.input.length; ++i) {
            final ye ingred = recipe.d[i];
            if (ingred != null) {
                this.input[i] = recipe.d[i];
                for (final Map.Entry<ye, String> replace : replacements.entrySet()) {
                    if (OreDictionary.itemMatches(replace.getKey(), ingred, true)) {
                        this.input[i] = OreDictionary.getOres(replace.getValue());
                        break;
                    }
                }
            }
        }
    }
    
    public ye a(final vk var1) {
        return this.output.m();
    }
    
    public int a() {
        return this.input.length;
    }
    
    public ye b() {
        return this.output;
    }
    
    public boolean a(final vk inv, final abw world) {
        for (int x = 0; x <= 3 - this.width; ++x) {
            for (int y = 0; y <= 3 - this.height; ++y) {
                if (this.checkMatch(inv, x, y, false)) {
                    return true;
                }
                if (this.mirrored && this.checkMatch(inv, x, y, true)) {
                    return true;
                }
            }
        }
        return false;
    }
    
    private boolean checkMatch(final vk inv, final int startX, final int startY, final boolean mirror) {
        for (int x = 0; x < 3; ++x) {
            for (int y = 0; y < 3; ++y) {
                final int subX = x - startX;
                final int subY = y - startY;
                Object target = null;
                if (subX >= 0 && subY >= 0 && subX < this.width && subY < this.height) {
                    if (mirror) {
                        target = this.input[this.width - subX - 1 + subY * this.width];
                    }
                    else {
                        target = this.input[subX + subY * this.width];
                    }
                }
                final ye slot = inv.b(x, y);
                if (target instanceof ye) {
                    if (!this.checkItemEquals((ye)target, slot)) {
                        return false;
                    }
                }
                else if (target instanceof ArrayList) {
                    boolean matched = false;
                    for (final ye item : (ArrayList)target) {
                        matched = (matched || this.checkItemEquals(item, slot));
                    }
                    if (!matched) {
                        return false;
                    }
                }
                else if (target == null && slot != null) {
                    return false;
                }
            }
        }
        return true;
    }
    
    private boolean checkItemEquals(final ye target, final ye input) {
        return (input != null || target == null) && (input == null || target != null) && target.d == input.d && (target.k() == 32767 || target.k() == input.k());
    }
    
    public ShapedOreRecipe setMirrored(final boolean mirror) {
        this.mirrored = mirror;
        return this;
    }
    
    public Object[] getInput() {
        return this.input;
    }
}



================================================
FILE: net/minecraftforge/oredict/ShapelessOreRecipe.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.oredict;

import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.ArrayList;

public class ShapelessOreRecipe implements aah
{
    private ye output;
    private ArrayList input;
    
    public ShapelessOreRecipe(final aqz result, final Object... recipe) {
        this(new ye(result), recipe);
    }
    
    public ShapelessOreRecipe(final yc result, final Object... recipe) {
        this(new ye(result), recipe);
    }
    
    public ShapelessOreRecipe(final ye result, final Object... recipe) {
        this.output = null;
        this.input = new ArrayList();
        this.output = result.m();
        for (final Object in : recipe) {
            if (in instanceof ye) {
                this.input.add(((ye)in).m());
            }
            else if (in instanceof yc) {
                this.input.add(new ye((yc)in));
            }
            else if (in instanceof aqz) {
                this.input.add(new ye((aqz)in));
            }
            else {
                if (!(in instanceof String)) {
                    String ret = "Invalid shapeless ore recipe: ";
                    for (final Object tmp : recipe) {
                        ret = ret + tmp + ", ";
                    }
                    ret += this.output;
                    throw new RuntimeException(ret);
                }
                this.input.add(OreDictionary.getOres((String)in));
            }
        }
    }
    
    ShapelessOreRecipe(final aaj recipe, final Map<ye, String> replacements) {
        this.output = null;
        this.input = new ArrayList();
        this.output = recipe.b();
        for (Object finalObj : recipe.b) {
            final ye ingred = (ye)finalObj;
            for (final Map.Entry<ye, String> replace : replacements.entrySet()) {
                if (OreDictionary.itemMatches(replace.getKey(), ingred, false)) {
                    finalObj = OreDictionary.getOres(replace.getValue());
                    break;
                }
            }
            this.input.add(finalObj);
        }
    }
    
    public int a() {
        return this.input.size();
    }
    
    public ye b() {
        return this.output;
    }
    
    public ye a(final vk var1) {
        return this.output.m();
    }
    
    public boolean a(final vk var1, final abw world) {
        final ArrayList required = new ArrayList(this.input);
        for (int x = 0; x < var1.j_(); ++x) {
            final ye slot = var1.a(x);
            if (slot != null) {
                boolean inRecipe = false;
                final Iterator req = required.iterator();
                while (req.hasNext()) {
                    boolean match = false;
                    final Object next = req.next();
                    if (next instanceof ye) {
                        match = this.checkItemEquals((ye)next, slot);
                    }
                    else if (next instanceof ArrayList) {
                        for (final ye item : (ArrayList)next) {
                            match = (match || this.checkItemEquals(item, slot));
                        }
                    }
                    if (match) {
                        inRecipe = true;
                        required.remove(next);
                        break;
                    }
                }
                if (!inRecipe) {
                    return false;
                }
            }
        }
        return required.isEmpty();
    }
    
    private boolean checkItemEquals(final ye target, final ye input) {
        return target.d == input.d && (target.k() == 32767 || target.k() == input.k());
    }
    
    public ArrayList getInput() {
        return this.input;
    }
}



================================================
FILE: net/minecraftforge/server/ForgeTimeTracker.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.server;

import java.util.Iterator;
import java.util.Arrays;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.MapMaker;
import java.lang.ref.WeakReference;
import java.util.Map;

public class ForgeTimeTracker
{
    public static boolean tileEntityTracking;
    public static int tileEntityTrackingDuration;
    public static long tileEntityTrackingTime;
    private Map<asp, int[]> tileEntityTimings;
    private Map<nn, int[]> entityTimings;
    private static final ForgeTimeTracker INSTANCE;
    private WeakReference<asp> tile;
    private WeakReference<nn> entity;
    private long timing;
    
    private ForgeTimeTracker() {
        final MapMaker mm = new MapMaker();
        mm.weakKeys();
        this.tileEntityTimings = mm.makeMap();
        this.entityTimings = mm.makeMap();
    }
    
    private void trackTileStart(final asp tileEntity, final long nanoTime) {
        if (ForgeTimeTracker.tileEntityTrackingTime == 0L) {
            ForgeTimeTracker.tileEntityTrackingTime = nanoTime;
        }
        else if (ForgeTimeTracker.tileEntityTrackingTime + ForgeTimeTracker.tileEntityTrackingDuration < nanoTime) {
            ForgeTimeTracker.tileEntityTracking = false;
            ForgeTimeTracker.tileEntityTrackingTime = 0L;
            return;
        }
        this.tile = new WeakReference<asp>(tileEntity);
        this.timing = nanoTime;
    }
    
    private void trackTileEnd(final asp tileEntity, final long nanoTime) {
        if (this.tile == null || this.tile.get() != tileEntity) {
            this.tile = null;
            return;
        }
        int[] timings = this.tileEntityTimings.get(tileEntity);
        if (timings == null) {
            timings = new int[101];
            this.tileEntityTimings.put(tileEntity, timings);
        }
        final int[] array = timings;
        final int n = 100;
        final int n2 = (timings[100] + 1) % 100;
        array[n] = n2;
        final int idx = n2;
        timings[idx] = (int)(nanoTime - this.timing);
    }
    
    public static ImmutableMap<asp, int[]> getTileTimings() {
        return ForgeTimeTracker.INSTANCE.buildImmutableTileEntityTimingMap();
    }
    
    private ImmutableMap<asp, int[]> buildImmutableTileEntityTimingMap() {
        final ImmutableMap.Builder<asp, int[]> builder = (ImmutableMap.Builder<asp, int[]>)ImmutableMap.builder();
        for (final Map.Entry<asp, int[]> entry : this.tileEntityTimings.entrySet()) {
            builder.put((Object)entry.getKey(), (Object)Arrays.copyOfRange(entry.getValue(), 0, 100));
        }
        return (ImmutableMap<asp, int[]>)builder.build();
    }
    
    public static void trackStart(final asp tileEntity) {
        if (!ForgeTimeTracker.tileEntityTracking) {
            return;
        }
        ForgeTimeTracker.INSTANCE.trackTileStart(tileEntity, System.nanoTime());
    }
    
    public static void trackEnd(final asp tileEntity) {
        if (!ForgeTimeTracker.tileEntityTracking) {
            return;
        }
        ForgeTimeTracker.INSTANCE.trackTileEnd(tileEntity, System.nanoTime());
    }
    
    public static void trackStart(final nn par1Entity) {
    }
    
    public static void trackEnd(final nn par1Entity) {
    }
    
    static {
        INSTANCE = new ForgeTimeTracker();
    }
}



================================================
FILE: net/minecraftforge/server/command/ForgeCommand.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.server.command;

import net.minecraftforge.common.DimensionManager;
import net.minecraftforge.server.ForgeTimeTracker;
import java.text.DecimalFormat;
import net.minecraft.server.MinecraftServer;

public class ForgeCommand extends z
{
    private MinecraftServer server;
    private static final DecimalFormat timeFormatter;
    
    public ForgeCommand(final MinecraftServer server) {
        this.server = server;
    }
    
    public String c() {
        return "forge";
    }
    
    public String c(final ad icommandsender) {
        return "commands.forge.usage";
    }
    
    public int a() {
        return 2;
    }
    
    public void b(final ad sender, final String[] args) {
        if (args.length == 0) {
            throw new bd("commands.forge.usage", new Object[0]);
        }
        if ("help".equals(args[0])) {
            throw new bd("commands.forge.usage", new Object[0]);
        }
        if ("tps".equals(args[0])) {
            this.displayTPS(sender, args);
        }
        else if ("tpslog".equals(args[0])) {
            this.doTPSLog(sender, args);
        }
        else {
            if (!"track".equals(args[0])) {
                throw new bd("commands.forge.usage", new Object[0]);
            }
            this.handleTracking(sender, args);
        }
    }
    
    private void handleTracking(final ad sender, final String[] args) {
        if (args.length != 3) {
            throw new bd("commands.forge.usage.tracking", new Object[0]);
        }
        final String type = args[1];
        final int duration = a(sender, args[2], 1, 60);
        if ("te".equals(type)) {
            this.doTurnOnTileEntityTracking(sender, duration);
            return;
        }
        throw new bd("commands.forge.usage.tracking", new Object[0]);
    }
    
    private void doTurnOnTileEntityTracking(final ad sender, final int duration) {
        ForgeTimeTracker.tileEntityTrackingDuration = duration;
        ForgeTimeTracker.tileEntityTracking = true;
        sender.a(cv.b("commands.forge.tracking.te.enabled", new Object[] { duration }));
    }
    
    private void doTPSLog(final ad sender, final String[] args) {
    }
    
    private void displayTPS(final ad sender, final String[] args) {
        int dim = 0;
        boolean summary = true;
        if (args.length > 1) {
            dim = a(sender, args[1]);
            summary = false;
        }
        if (summary) {
            for (final Integer dimId : DimensionManager.getIDs()) {
                final double worldTickTime = mean(this.server.worldTickTimes.get(dimId)) * 1.0E-6;
                final double worldTPS = Math.min(1000.0 / worldTickTime, 20.0);
                sender.a(cv.b("commands.forge.tps.summary", new Object[] { String.format("Dim %d", dimId), ForgeCommand.timeFormatter.format(worldTickTime), ForgeCommand.timeFormatter.format(worldTPS) }));
            }
            final double meanTickTime = mean(this.server.j) * 1.0E-6;
            final double meanTPS = Math.min(1000.0 / meanTickTime, 20.0);
            sender.a(cv.b("commands.forge.tps.summary", new Object[] { "Overall", ForgeCommand.timeFormatter.format(meanTickTime), ForgeCommand.timeFormatter.format(meanTPS) }));
        }
        else {
            final double worldTickTime2 = mean(this.server.worldTickTimes.get(dim)) * 1.0E-6;
            final double worldTPS2 = Math.min(1000.0 / worldTickTime2, 20.0);
            sender.a(cv.b("commands.forge.tps.summary", new Object[] { String.format("Dim %d", dim), ForgeCommand.timeFormatter.format(worldTickTime2), ForgeCommand.timeFormatter.format(worldTPS2) }));
        }
    }
    
    private static long mean(final long[] values) {
        long sum = 0L;
        for (final long v : values) {
            sum += v;
        }
        return sum / values.length;
    }
    
    static {
        timeFormatter = new DecimalFormat("########0.000");
    }
}



================================================
FILE: net/minecraftforge/transformers/EventTransformer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.transformers;

import java.util.Iterator;
import org.objectweb.asm.tree.TypeInsnNode;
import org.objectweb.asm.tree.FrameNode;
import org.objectweb.asm.tree.JumpInsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.FieldInsnNode;
import org.objectweb.asm.tree.InsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.VarInsnNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.Type;
import net.minecraftforge.event.Event;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.ClassReader;
import net.minecraft.launchwrapper.IClassTransformer;

public class EventTransformer implements IClassTransformer
{
    public byte[] transform(final String name, final String transformedName, final byte[] bytes) {
        if (bytes == null || name.equals("net.minecraftforge.event.Event") || name.startsWith("net.minecraft.") || name.indexOf(46) == -1) {
            return bytes;
        }
        final ClassReader cr = new ClassReader(bytes);
        final ClassNode classNode = new ClassNode();
        cr.accept((ClassVisitor)classNode, 0);
        try {
            if (this.buildEvents(classNode)) {
                final ClassWriter cw = new ClassWriter(3);
                classNode.accept((ClassVisitor)cw);
                return cw.toByteArray();
            }
            return bytes;
        }
        catch (final ClassNotFoundException ex) {}
        catch (final Exception e) {
            e.printStackTrace();
        }
        return bytes;
    }
    
    private boolean buildEvents(final ClassNode classNode) throws Exception {
        final Class<?> parent = this.getClass().getClassLoader().loadClass(classNode.superName.replace('/', '.'));
        if (!Event.class.isAssignableFrom(parent)) {
            return false;
        }
        boolean hasSetup = false;
        boolean hasGetListenerList = false;
        boolean hasDefaultCtr = false;
        final Class<?> listenerListClazz = Class.forName("net.minecraftforge.event.ListenerList", false, this.getClass().getClassLoader());
        final Type tList = Type.getType((Class)listenerListClazz);
        for (final MethodNode method : classNode.methods) {
            if (method.name.equals("setup") && method.desc.equals(Type.getMethodDescriptor(Type.VOID_TYPE, new Type[0])) && (method.access & 0x4) == 0x4) {
                hasSetup = true;
            }
            if (method.name.equals("getListenerList") && method.desc.equals(Type.getMethodDescriptor(tList, new Type[0])) && (method.access & 0x1) == 0x1) {
                hasGetListenerList = true;
            }
            if (method.name.equals("<init>") && method.desc.equals(Type.getMethodDescriptor(Type.VOID_TYPE, new Type[0]))) {
                hasDefaultCtr = true;
            }
        }
        if (!hasSetup) {
            final Type tSuper = Type.getType(classNode.superName);
            classNode.fields.add(new FieldNode(10, "LISTENER_LIST", tList.getDescriptor(), (String)null, (Object)null));
            MethodNode method = new MethodNode(262144, 1, "<init>", Type.getMethodDescriptor(Type.VOID_TYPE, new Type[0]), (String)null, (String[])null);
            method.instructions.add((AbstractInsnNode)new VarInsnNode(25, 0));
            method.instructions.add((AbstractInsnNode)new MethodInsnNode(183, tSuper.getInternalName(), "<init>", Type.getMethodDescriptor(Type.VOID_TYPE, new Type[0])));
            method.instructions.add((AbstractInsnNode)new InsnNode(177));
            if (!hasDefaultCtr) {
                classNode.methods.add(method);
            }
            method = new MethodNode(262144, 4, "setup", Type.getMethodDescriptor(Type.VOID_TYPE, new Type[0]), (String)null, (String[])null);
            method.instructions.add((AbstractInsnNode)new VarInsnNode(25, 0));
            method.instructions.add((AbstractInsnNode)new MethodInsnNode(183, tSuper.getInternalName(), "setup", Type.getMethodDescriptor(Type.VOID_TYPE, new Type[0])));
            method.instructions.add((AbstractInsnNode)new FieldInsnNode(178, classNode.name, "LISTENER_LIST", tList.getDescriptor()));
            final LabelNode initLisitener = new LabelNode();
            method.instructions.add((AbstractInsnNode)new JumpInsnNode(198, initLisitener));
            method.instructions.add((AbstractInsnNode)new InsnNode(177));
            method.instructions.add((AbstractInsnNode)initLisitener);
            method.instructions.add((AbstractInsnNode)new FrameNode(3, 0, (Object[])null, 0, (Object[])null));
            method.instructions.add((AbstractInsnNode)new TypeInsnNode(187, tList.getInternalName()));
            method.instructions.add((AbstractInsnNode)new InsnNode(89));
            method.instructions.add((AbstractInsnNode)new VarInsnNode(25, 0));
            method.instructions.add((AbstractInsnNode)new MethodInsnNode(183, tSuper.getInternalName(), "getListenerList", Type.getMethodDescriptor(tList, new Type[0])));
            method.instructions.add((AbstractInsnNode)new MethodInsnNode(183, tList.getInternalName(), "<init>", Type.getMethodDescriptor(Type.VOID_TYPE, new Type[] { tList })));
            method.instructions.add((AbstractInsnNode)new FieldInsnNode(179, classNode.name, "LISTENER_LIST", tList.getDescriptor()));
            method.instructions.add((AbstractInsnNode)new InsnNode(177));
            classNode.methods.add(method);
            method = new MethodNode(262144, 1, "getListenerList", Type.getMethodDescriptor(tList, new Type[0]), (String)null, (String[])null);
            method.instructions.add((AbstractInsnNode)new FieldInsnNode(178, classNode.name, "LISTENER_LIST", tList.getDescriptor()));
            method.instructions.add((AbstractInsnNode)new InsnNode(176));
            classNode.methods.add(method);
            return true;
        }
        if (!hasGetListenerList) {
            throw new RuntimeException("Event class defines setup() but does not define getListenerList! " + classNode.name);
        }
        return false;
    }
}



================================================
FILE: net/minecraftforge/transformers/ForgeAccessTransformer.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package net.minecraftforge.transformers;

import java.io.IOException;
import cpw.mods.fml.common.asm.transformers.AccessTransformer;

public class ForgeAccessTransformer extends AccessTransformer
{
    public ForgeAccessTransformer() throws IOException {
        super("forge_at.cfg");
    }
}



================================================
FILE: paulscode/sound/codecs/CodecIBXM.java
================================================
// 
// Decompiled by Procyon v0.6.0
// 

package paulscode.sound.codecs;

import java.nio.ShortBuffer;
import java.nio.ByteOrder;
import java.nio.ByteBuffer;
import ibxm.ProTracker;
import ibxm.ScreamTracker3;
import java.io.DataInput;
import ibxm.FastTracker2;
import java.io.DataInputStream;
import paulscode.sound.SoundBuffer;
import java.io.InputStream;
import java.io.IOException;
import java.net.URL;
import paulscode.sound.SoundSystemConfig;
import paulscode.sound.SoundSystemLogger;
import ibxm.Module;
import ibxm.IBXM;
import javax.sound.sampled.AudioFormat;
import paulscode.sound.ICodec;

public class CodecIBXM implements ICodec
{
    private static final boolean GET = false;
    private static final boolean SET = true;
    private static final boolean XXX = false;
    private boolean endOfStream;
    private boolean initialized;
    private AudioFormat myAudioFormat;
    private boolean reverseBytes;
    private IBXM ibxm;
    private Module module;
    private int songDuration;
    private int playPosition;
    private SoundSystemLogger logger;
    
    public CodecIBXM() {
        this.endOfStream = false;
        this.initialized = false;
        this.myAudioFormat = null;
        this.reverseBytes = false;
        this.logger = SoundSystemConfig.getLogger();
    }
    
    public void reverseByteOrder(final boolean b) {
        this.reverseBytes = b;
    }
    
    public boolean initialize(final URL url) {
        this.initialized(true, false);
        this.cleanup();
        if (url == null) {
            this.errorMessage("url null in method 'initialize'");
            this.cleanup();
            return false;
        }
        InputStream is = null;
        try {
            is = url.openStream();
        }
        catch (final IOException ioe) {
            this.errorMessage("Unable to open stream in method 'initialize'");
            this.printStackTrace(ioe);
            return false;
        }
        if (this.ibxm == null) {
            this.ibxm = new IBXM(48000);
        }
        if (this.myAudioFormat == null) {
            this.myAudioFormat = new AudioFormat(48000.0f, 16, 2, true, true);
        }
        try {
            this.setModule(loadModule(is));
        }
        catch (final IllegalArgumentException iae) {
            this.errorMessage("Illegal argument in method 'initialize'");
            this.printStackTrace(iae);
            if (is != null) {
                try {
                    is.close();
                }
                catch (final IOException ex) {}
            }
            return false;
        }
        catch (final IOException ioe) {
            this.errorMessage("Error loading module in method 'initialize'");
            this.printStackTrace(ioe);
            if (is != null) {
                try {
                    is.close();
                }
                catch (final IOException ex2) {}
            }
            return false;
        }
        if (is != null) {
            try {
                is.close();
            }
            catch (final IOException ex3) {}
        }
        this.endOfStream(true, false);
        this.initialized(true, true);
        return true;
    }
    
    public boolean initialized() {
        return this.initialized(false, false);
    }
    
    public SoundBuffer read() {
        if (this.endOfStream(false, false)) {
            return null;
        }
        if (this.module == null) {
            this.errorMessage("Module null in method 'read'");
            return null;
        }
        if (this.myAudioFormat == null) {
            this.errorMessage("Audio Format null in method 'read'");
            return null;
        }
        final int bufferFrameSize = SoundSystemConfig.getStreamingBufferSize() / 4;
        int frames = this.songDuration - this.playPosition;
        if (frames > bufferFrameSize) {
            frames = bufferFrameSize;
        }
        if (frames <= 0) {
            this.endOfStream(true, true);
            return null;
        }
        final byte[] outputBuffer = new byte[frames * 4];
        this.ibxm.get_audio(outputBuffer, frames);
        this.playPosition += frames;
        if (this.playPosition >= this.songDuration) {
            this.endOfStream(true, true);
        }
        if (this.reverseBytes) {
            reverseBytes(outputBuffer, 0, frames * 4);
        }
        final SoundBuffer buffer = new SoundBuffer(outputBuffer, this.myAudioFormat);
        return buffer;
    }
    
    public SoundBuffer readAll() {
        if (this.module == null) {
            this.errorMessage("Module null in method 'readAll'");
            return null;
        }
        if (this.myAudioFormat == null) {
            this.errorMessage("Audio Format null in method 'readAll'");
            return null;
        }
        final int bufferFrameSize = SoundSystemConfig.getFileChunkSize() / 4;
        final byte[] outputBuffer = new byte[bufferFrameSize * 4];
        byte[] fullBuffer = null;
        int totalBytes = 0;
        while (!this.endOfStream(false, false) && totalBytes < SoundSystemConfig.getMaxFileSize()) {
            int frames = this.songDuration - this.playPosition;
            if (frames > bufferFrameSize) {
                frames = bufferFrameSize;
            }
            this.ibxm.get_audio(outputBuffer, frames);
            totalBytes += frames * 4;
            fullBuffer = appendByteArrays(fullBuffer, outputBuffer, frames * 4);
            this.playPosition += frames;
            if (this.playPosition >= this.songDuration) {
                this.endOfStream(true, true);
            }
        }
        if (this.reverseBytes) {
            reverseBytes(fullBuffer, 0, totalBytes);
        }
        final SoundBuffer buffer = new SoundBuffer(fullBuffer, this.myAudioFormat);
        return buffer;
    }
    
    public boolean endOfStream() {
        return this.endOfStream(false, false);
    }
    
    public void cleanup() {
        this.playPosition = 0;
    }
    
    public AudioFormat getAudioFormat() {
        return this.myAudioFormat;
    }
    
    private static Module loadModule(final InputStream input) throws IllegalArgumentException, IOException {
        final DataInputStream data_input_stream = new DataInputStream(input);
        final byte[] xm_header = new byte[60];
        data_input_stream.readFully(xm_header);
        if (FastTracker2.is_xm(xm_header)) {
            return FastTracker2.load_xm(xm_header, data_input_stream);
        }
        final byte[] s3m_header = new byte[96];
        System.arraycopy(xm_header, 0, s3m_header, 0, 60);
        data_input_stream.readFully(s3m_header, 60, 36);
        if (ScreamTracker3.is_s3m(s3m_header)) {
            return ScreamTracker3.load_s3m(s3m_header, data_input_stream);
        }
        final byte[] mod_header = new byte[1084];
        System.arraycopy(s3m_header, 0, mod_header, 0, 96);
        data_input_stream.readFully(mod_header, 96, 988);
        return ProTracker.load_mod(mod_header, data_input_stream);
    }
    
    private void setModule(final Module m) {
        if (m != null) {
            this.module = m;
        }
        this.ibxm.set_module(this.module);
        this.songDuration = this.ibxm.calculate_song_duration();
    }
    
    private synchronized boolean initialized(final boolean action, final boolean value) {
        if (action) {
            this.initialized = value;
        }
        return this.initialized;
    }
    
    private synchronized boolean endOfStream(final boolean action, final boolean value) {
        if (action) {
            this.endOfStream = value;
        }
        return this.endOfStream;
    }
    
    private static byte[] trimArray(final byte[] array, final int maxLength) {
        byte[] trimmedArray = null;
        if (array != null && array.length > maxLength) {
            trimmedArray = new byte[maxLength];
            System.arraycopy(array, 0, trimmedArray, 0, maxLength);
        }
        return trimmedArray;
    }
    
    public static void reverseBytes(final byte[] buffer) {
        reverseBytes(buffer, 0, buffer.length);
    }
    
    public static void reverseBytes(final byte[] buffer, final int offset, final int size) {
        for (int i = offset; i < offset + size; i += 2) {
            final byte b = buffer[i];
            buffer[i] = buffer[i + 1];
            buffer[i + 1] = b;
        }
    }
    
    private static byte[] convertAudioBytes(final byte[] audio_bytes, final boolean two_bytes_data) {
        final ByteBuffer dest = ByteBuffer.allocateDirect(audio_bytes.length);
        dest.order(ByteOrder.nativeOrder());
        final ByteBuffer src = ByteBuffer.wrap(audio_bytes);
        src.order(ByteOrder.LITTLE_ENDIAN);
        if (two_bytes_data) {
            final ShortBuffer dest_short = dest.asShortBuffer();
            final ShortBuffer src_short = src.asShortBuffer();
            while (src_short.hasRemaining()) {
                dest_short.put(src_short.get());
            }
        }
        else {
            while (src.hasRemaining()) {
                dest.put(src.get());
            }
        }
        dest.rewind();
        if (!dest.hasArray()) {
            final byte[] arrayBackedBuffer = new byte[dest.capacity()];
            dest.get(arrayBackedBuffer);
            dest.clear();
            return arrayBackedBuffer;
        }
        return dest.array();
    }
    
    private static byte[] appendByteArrays(byte[] arrayOne, byte[] arrayTwo, final int length) {
        if (arrayOne == null && arrayTwo == null) {
            return null;
        }
        byte[] newArray;
        if (arrayOne == null) {
            newArray = new byte[length];
            System.arraycopy(arrayTwo, 0, newArray, 0, length);
            arrayTwo = null;
        }
        else if (arrayTwo == null) {
            newArray = new byte[arrayOne.length];
            System.arraycopy(arrayOne, 0, newArray, 0, arrayOne.length);
            arrayOne = null;
        }
        else {
            newArray = new byte[arrayOne.length + length];
            System.arraycopy(arrayOne, 0, newArray, 0, arrayOne.length);
            System.arraycopy(arrayTwo, 0, newArray, arrayOne.length, length);
            arrayOne = null;
            arrayTwo = null;
        }
        return newArray;
    }
    
    private void errorMessage(final String message) {
        this.logger.errorMessage("CodecWav", message, 0);
    }
    
    private void printStackTrace(final Exception e) {
        this.logger.printStackTrace(e, 1);
    }
}


